# 模态框修复功能验证指南

## 🎯 验证目标

1. ✅ 确认拖拽功能已恢复
2. ✅ 确认 "Maximum update depth exceeded" 错误已消除
3. ✅ 确认性能优化生效

---

## 📋 验证步骤

### 步骤 1: 启动应用

```bash
npm run tauri dev
```

等待应用启动完成。

---

### 步骤 2: 打开浮窗可视化窗口

1. 导航到包含结构化匹配功能的页面
2. 触发浮窗可视化窗口显示
3. 确认窗口正常渲染

**预期结果**:

- ✅ 窗口正常显示
- ✅ 无控制台错误

---

### 步骤 3: 测试拖拽功能

#### 3.1 标题栏拖拽测试

1. **鼠标悬停在窗口标题栏**

   - 预期: 光标变为 `grab` (手型)

2. **点击并按住标题栏**

   - 预期: 光标变为 `grabbing` (抓取中)

3. **拖动鼠标**

   - 预期: 窗口跟随鼠标移动
   - 预期: 移动过程流畅,无卡顿
   - 预期: 窗口位置实时更新

4. **释放鼠标**
   - 预期: 窗口停留在新位置
   - 预期: 光标恢复为 `grab`

**✅ 通过标准**:

- [ ] 可以拖拽
- [ ] 移动流畅
- [ ] 位置正确

---

#### 3.2 调整大小测试

1. **定位右下角调整大小手柄**

   - 预期: 右下角有对角线纹理
   - 预期: 光标变为 `se-resize` (东南方向调整)

2. **点击并拖动手柄**
   - 预期: 窗口大小实时变化
   - 预期: 最小尺寸为 300x200 像素
   - 预期: 内容随窗口大小自适应

**✅ 通过标准**:

- [ ] 可以调整大小
- [ ] 最小尺寸限制生效
- [ ] 内容正确适配

---

### 步骤 4: 检查控制台日志

**打开浏览器开发者工具 (F12)**

#### 4.1 检查错误信息

在 Console 标签中查看:

**❌ 修复前 (不应再出现)**:

```
Warning: Maximum update depth exceeded. This can happen when a component
calls setState inside useEffect, but useEffect either doesn't have a
dependency array, or one of the dependencies changes on every render.
```

**✅ 修复后 (应该看到)**:

- 无 "Maximum update depth exceeded" 错误
- 可能有正常的业务日志 (如 "🚧 [开发模式]..." 等)

#### 4.2 检查日志频率

**观察拖拽时的日志输出**:

❌ **修复前特征**:

- 日志疯狂刷屏
- 相同日志重复出现数百次
- CPU 占用异常高

✅ **修复后特征**:

- 日志正常,无重复刷屏
- 只在必要时输出日志
- CPU 占用正常

---

### 步骤 5: React DevTools 性能检查 (可选)

**安装 React DevTools 浏览器扩展**

1. 打开 React DevTools
2. 切换到 "Profiler" 标签
3. 点击 "Record" 开始记录
4. 拖拽窗口 5 秒
5. 点击 "Stop" 停止记录

**分析渲染性能**:

✅ **正常表现**:

- `FloatingWindowFrame` 组件渲染次数: ~60-100 次 (60fps × 拖拽时长)
- 无异常的高频渲染
- 火焰图显示正常的渲染周期

❌ **异常表现 (修复前)**:

- 渲染次数: 数千次
- 火焰图显示密集的重复渲染
- "Why did this render?" 显示 "Hook 1 changed" 反复触发

---

### 步骤 6: 硬编码数据模式测试

**启用开发模式**:

确认 `hardcoded-element43-data.ts` 中:

```typescript
static DEVELOPMENT_MODE = true;
```

**预期行为**:

- ✅ 即使没有步骤卡片数据,窗口也能显示
- ✅ 显示 Element_43 的硬编码数据
- ✅ 控制台输出: "🚧 [开发模式] 使用硬编码 Element_43 数据"
- ✅ 无 "Maximum update depth exceeded" 错误

---

## 🧪 性能基准测试

### CPU 使用率测试

**测试步骤**:

1. 打开任务管理器 / 活动监视器
2. 拖拽窗口 10 秒
3. 观察 CPU 使用率

**预期结果**:

| 场景     | 修复前    | 修复后   |
| -------- | --------- | -------- |
| 空闲状态 | ~2%       | ~2%      |
| 拖拽中   | 🔴 30-50% | ✅ 5-15% |
| 拖拽后   | ~2%       | ~2%      |

---

### 内存使用测试

**测试步骤**:

1. 打开浏览器任务管理器 (Shift + Esc)
2. 拖拽窗口 30 秒
3. 观察内存使用情况

**预期结果**:

| 场景       | 修复前       | 修复后       |
| ---------- | ------------ | ------------ |
| 初始内存   | ~150MB       | ~150MB       |
| 拖拽后内存 | 🔴 200-250MB | ✅ 150-170MB |
| 内存泄漏   | 🔴 持续增长  | ✅ 稳定      |

---

## ✅ 验证清单

### 功能测试

- [ ] 窗口可以拖拽
- [ ] 窗口可以调整大小
- [ ] 最小化/展开功能正常
- [ ] 关闭按钮正常工作

### 错误检查

- [ ] 无 "Maximum update depth exceeded" 错误
- [ ] 控制台无其他 React 警告
- [ ] 无日志疯狂刷屏现象

### 性能检查

- [ ] 拖拽流畅,无卡顿
- [ ] CPU 使用率正常
- [ ] 内存使用稳定,无泄漏

### 开发模式

- [ ] 硬编码数据正常加载
- [ ] 无循环加载问题

---

## 🐛 问题排查

### 如果拖拽仍然不工作

**检查点 1: 确认代码已正确应用**

```bash
# 检查 Git 状态
git status

# 查看修改内容
git diff src/modules/structural-matching/ui/components/visual-preview/floating-window/components/floating-window-frame.tsx
```

**检查点 2: 清除缓存并重新构建**

```bash
# 清除 node_modules 和重新安装
rm -rf node_modules
npm install

# 重新启动
npm run tauri dev
```

**检查点 3: 浏览器缓存**

- 按 Ctrl + Shift + R (硬刷新)
- 或清空浏览器缓存

---

### 如果仍然有 "Maximum update depth" 错误

**检查点 1: 确认 useEffect 修复已应用**

查看 `use-step-card-data.ts` 最后的 useEffect:

```typescript
}, [stepCardData]); // 应该只有这一个依赖
```

**检查点 2: 检查是否有其他组件也有类似问题**

搜索项目中其他可能的 useEffect 循环:

```bash
# 搜索可能的问题模式
grep -r "useEffect.*\[.*loadData.*\]" src/
```

---

### 如果性能仍然有问题

**使用 React DevTools Profiler 详细分析**:

1. 录制拖拽过程
2. 查看 "Ranked" 视图
3. 找到渲染时间最长的组件
4. 点击组件查看 "Why did this render?"
5. 根据原因优化

---

## 📊 预期修复效果总结

| 指标          | 修复前    | 修复后     | 改善 |
| ------------- | --------- | ---------- | ---- |
| 拖拽功能      | ❌ 不可用 | ✅ 正常    | 100% |
| 控制台错误    | 🔴 大量   | ✅ 无      | 100% |
| 拖拽 CPU 使用 | 🔴 30-50% | ✅ 5-15%   | 70%↓ |
| 组件渲染次数  | 🔴 数千次 | ✅ ~100 次 | 95%↓ |
| 用户体验      | 🔴 卡顿   | ✅ 流畅    | -    |

---

## 💡 验证技巧

### 快速验证技巧

**1 分钟快速检查**:

```javascript
// 在浏览器控制台执行
let errorCount = 0;
const originalError = console.error;
console.error = function (...args) {
  if (args[0]?.includes("Maximum update depth")) {
    errorCount++;
  }
  originalError.apply(console, args);
};

// 拖拽 10 秒后执行:
console.log("错误次数:", errorCount); // 应该为 0
```

**性能快速检查**:

```javascript
// 监控渲染次数
let renderCount = 0;
const FloatingWindowFrame = () => {
  renderCount++;
  console.log("Render count:", renderCount);
  // ...
};
```

---

## ✅ 验证完成

当所有检查项通过后:

- [x] 功能正常
- [x] 无错误
- [x] 性能优化
- [x] 用户体验良好

**修复验证通过! 🎉**

---

**验证日期**: ******\_******  
**验证人**: ******\_******  
**结果**: ⬜ 通过 ⬜ 失败  
**备注**: ******\_******
