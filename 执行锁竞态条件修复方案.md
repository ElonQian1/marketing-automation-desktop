# æ‰§è¡Œé”ç«æ€æ¡ä»¶ä¿®å¤æ–¹æ¡ˆ

## ğŸ” é—®é¢˜ç°è±¡

```
æ‰§è¡Œæ¶ˆæ¯: V3æ‰§è¡Œå¤±è´¥: é‡å¤æ‰§è¡Œè¯·æ±‚è¢«é˜»æ­¢: analysis_id 'step_execution_xxx' æ­£åœ¨æ‰§è¡Œä¸­
```

**ç‰¹å¾**ï¼š
- å‡ºç°åœ¨ç¨‹åºåˆå§‹åŒ–/ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶
- æ˜æ˜¾ä¸æ˜¯çœŸæ­£çš„é‡å¤ç‚¹å‡»
- analysis_id æ˜¾ç¤º"æ­£åœ¨æ‰§è¡Œä¸­"ä½†å®é™…ä¸Šå¯èƒ½æ²¡æœ‰åœ¨æ‰§è¡Œ

## ğŸ¯ æ ¹æœ¬åŸå› 

### 1. åç«¯é”å®šé€»è¾‘ç¼ºé™·

åœ¨ `chain_engine.rs` çš„ `execute_chain_by_inline` å‡½æ•°ä¸­ï¼š

```rust
// âŒ é—®é¢˜ä»£ç 
if let Some(intelligent_steps) = check_and_trigger_early_analysis(...).await? {
    execution_tracker::unlock(analysis_id)?;  // åªæœ‰è¿›å…¥è¿™ä¸ªåˆ†æ”¯æ‰ unlock
    return execute_chain_by_inline(...).await;
}

// ğŸš¨ å¦‚æœä¸Šé¢æ²¡æœ‰è¿›å…¥åˆ†æ”¯ï¼Œè¿™é‡Œä¼šå°è¯•é”å®šå·²é”å®šçš„ ID
if !execution_tracker::try_lock(analysis_id)? {
    return Err("é‡å¤æ‰§è¡Œè¯·æ±‚è¢«é˜»æ­¢...");
}
```

**é—®é¢˜æµç¨‹**ï¼š
1. å‡½æ•°å¼€å§‹æ—¶æ²¡æœ‰ lock
2. `check_and_trigger_early_analysis` å¯èƒ½å†…éƒ¨æ‰§è¡Œäº†æŸäº›æ“ä½œ
3. å¦‚æœä¸è¿”å› `Some`ï¼Œä¸ä¼š unlockï¼ˆå®é™…ä¸Šä¹Ÿæ²¡ lockï¼‰
4. ç»§ç»­æ‰§è¡Œåˆ° `try_lock`ï¼Œä½†å¯èƒ½ï¼š
   - é€’å½’è°ƒç”¨æ—¶å·²ç» lock è¿‡
   - æŸä¸ªå¼‚æ­¥æ“ä½œå¯¼è‡´çš„ç«æ€æ¡ä»¶

### 2. é€’å½’è°ƒç”¨æ—¶çš„é‡å¤é”å®š

```rust
return execute_chain_by_inline(
    app, envelope, analysis_id, &intelligent_steps,  // ä½¿ç”¨ç›¸åŒçš„ analysis_id
    threshold, mode, quality, constraints, validation
).await;
```

é€’å½’è°ƒç”¨æ—¶ä½¿ç”¨ç›¸åŒçš„ `analysis_id`ï¼Œä¼šå†æ¬¡å°è¯•é”å®šã€‚

## âœ… è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆ Aï¼šç»Ÿä¸€é”å®šä½ç½®ï¼ˆæ¨èï¼‰

**æ€è·¯**ï¼šåœ¨å‡½æ•°å…¥å£å¤„ç»Ÿä¸€é”å®šï¼Œå‡ºå£å¤„ç»Ÿä¸€é‡Šæ”¾ã€‚

```rust
pub async fn execute_chain_by_inline<'a>(
    app: &AppHandle,
    envelope: &ProtocolEnvelope,
    analysis_id: &str,
    ordered_steps: &'a [OrderedStep],
    threshold: f64,
    mode: ExecutionMode,
    quality: AnalysisQuality,
    constraints: Option<Constraints>,
    validation: bool,
) -> Result<ChainExecutionResult, String> {
    Box::pin(async move {
    let start_time = Instant::now();
    let device_id = &envelope.device_id;
    
    // ğŸ”’ ã€ç»Ÿä¸€é”å®šã€‘åœ¨å‡½æ•°å…¥å£å¤„æ£€æŸ¥å¹¶é”å®š
    if !execution_tracker::try_lock(analysis_id)? {
        return Err(format!("é‡å¤æ‰§è¡Œè¯·æ±‚è¢«é˜»æ­¢: analysis_id '{}' æ­£åœ¨æ‰§è¡Œä¸­", analysis_id));
    }
    
    // ğŸ›¡ï¸ ç¡®ä¿å‡½æ•°é€€å‡ºæ—¶ä¸€å®šä¼šé‡Šæ”¾é”
    let _lock_guard = ExecutionLockGuard::new(analysis_id);
    
    // ğŸ†• ã€æå‰æ™ºèƒ½åˆ†ææ£€æµ‹ã€‘
    if let Some(intelligent_steps) = check_and_trigger_early_analysis(
        app, 
        analysis_id, 
        device_id, 
        ordered_steps
    ).await? {
        // âœ… é‡Šæ”¾å½“å‰é”ï¼ˆç”± guard è‡ªåŠ¨å¤„ç†ï¼‰
        drop(_lock_guard);
        
        // é€’å½’æ‰§è¡Œæ—¶ä¼šé‡æ–°é”å®š
        return execute_chain_by_inline(
            app, envelope, analysis_id, &intelligent_steps,
            threshold, mode, quality, constraints, validation
        ).await;
    }
    
    // ... ä¸»æ‰§è¡Œé€»è¾‘
    
    // å‡½æ•°ç»“æŸæ—¶ _lock_guard è‡ªåŠ¨é‡Šæ”¾é”
    Ok(result)
    }).await
}
```

### æ–¹æ¡ˆ Bï¼šä½¿ç”¨ RAII å®ˆå«ï¼ˆæ›´å®‰å…¨ï¼‰

åˆ›å»ºè‡ªåŠ¨é‡Šæ”¾å®ˆå«ï¼š

```rust
// src-tauri/src/exec/v3/helpers/execution_tracker.rs

/// RAII æ‰§è¡Œé”å®ˆå«
/// 
/// è‡ªåŠ¨ç®¡ç†æ‰§è¡Œé”çš„ç”Ÿå‘½å‘¨æœŸï¼š
/// - åˆ›å»ºæ—¶è‡ªåŠ¨é”å®š
/// - ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾
pub struct ExecutionLockGuard {
    analysis_id: String,
}

impl ExecutionLockGuard {
    /// åˆ›å»ºæ–°çš„é”å®ˆå«ï¼ˆå¦‚æœé”å®šå¤±è´¥ä¼španicï¼‰
    pub fn new(analysis_id: &str) -> Self {
        force_lock(analysis_id).expect("è·å–æ‰§è¡Œé”å¤±è´¥");
        Self {
            analysis_id: analysis_id.to_string(),
        }
    }
    
    /// å°è¯•åˆ›å»ºé”å®ˆå«ï¼ˆå¦‚æœé”å®šå¤±è´¥è¿”å›Noneï¼‰
    pub fn try_new(analysis_id: &str) -> Option<Self> {
        if try_lock(analysis_id).ok()? {
            Some(Self {
                analysis_id: analysis_id.to_string(),
            })
        } else {
            None
        }
    }
    
    /// æ‰‹åŠ¨é‡Šæ”¾é”ï¼ˆæå‰é‡Šæ”¾ï¼Œä¸ç­‰ææ„ï¼‰
    pub fn release(self) {
        // self ä¼šè¢«ç§»åŠ¨ï¼Œææ„æ—¶ä¼šé‡Šæ”¾é”
    }
}

impl Drop for ExecutionLockGuard {
    fn drop(&mut self) {
        if let Err(e) = unlock(&self.analysis_id) {
            tracing::error!("âŒ é‡Šæ”¾æ‰§è¡Œé”å¤±è´¥: {}", e);
        }
    }
}

/// ä¾¿æ·å‡½æ•°ï¼šå¸¦å®ˆå«çš„é”å®š
pub fn lock_with_guard(analysis_id: &str) -> Result<ExecutionLockGuard, String> {
    ExecutionLockGuard::try_new(analysis_id)
        .ok_or_else(|| format!("analysis_id '{}' å·²è¢«é”å®š", analysis_id))
}
```

ä½¿ç”¨ç¤ºä¾‹ï¼š

```rust
// æ–¹å¼1: è‡ªåŠ¨ç®¡ç†æ•´ä¸ªå‡½æ•°
let _guard = execution_tracker::lock_with_guard(analysis_id)?;

// æ–¹å¼2: æå‰é‡Šæ”¾
let guard = execution_tracker::lock_with_guard(analysis_id)?;
// ... æ‰§è¡Œé€»è¾‘
drop(guard);  // æ˜¾å¼é‡Šæ”¾
// ç»§ç»­å…¶ä»–æ“ä½œï¼ˆä¸æŒæœ‰é”ï¼‰
```

### æ–¹æ¡ˆ Cï¼šæ·»åŠ è¶…æ—¶è‡ªåŠ¨é‡Šæ”¾

```rust
use std::time::{Duration, SystemTime};
use std::collections::HashMap;

lazy_static::lazy_static! {
    static ref EXECUTION_TRACKER: Arc<Mutex<HashMap<String, SystemTime>>> 
        = Arc::new(Mutex::new(HashMap::new()));
}

/// è¶…æ—¶æ—¶é—´ï¼ˆ5åˆ†é’Ÿï¼‰
const LOCK_TIMEOUT: Duration = Duration::from_secs(300);

pub fn try_lock(analysis_id: &str) -> Result<bool, String> {
    let mut tracker = EXECUTION_TRACKER.lock()
        .map_err(|e| format!("è·å–æ‰§è¡Œè¿½è¸ªå™¨é”å¤±è´¥: {}", e))?;
    
    let now = SystemTime::now();
    
    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨é”
    if let Some(locked_at) = tracker.get(analysis_id) {
        // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
        if let Ok(elapsed) = now.duration_since(*locked_at) {
            if elapsed > LOCK_TIMEOUT {
                tracing::warn!(
                    "âš ï¸ ã€æ‰§è¡Œä¿æŠ¤ã€‘analysis_id '{}' é”å®šå·²è¶…æ—¶ï¼ˆ{}ç§’ï¼‰ï¼Œè‡ªåŠ¨é‡Šæ”¾",
                    analysis_id,
                    elapsed.as_secs()
                );
                tracker.remove(analysis_id);
            } else {
                tracing::warn!(
                    "âŒ ã€é‡å¤æ‰§è¡Œé˜»æ­¢ã€‘analysis_id '{}' å·²åœ¨æ‰§è¡Œä¸­ï¼ˆå·²æŒç»­ {}ç§’ï¼‰",
                    analysis_id,
                    elapsed.as_secs()
                );
                return Ok(false);
            }
        }
    }
    
    // é”å®š
    tracker.insert(analysis_id.to_string(), now);
    tracing::info!("ğŸ”’ ã€æ‰§è¡Œä¿æŠ¤ã€‘å·²é”å®š analysis_id '{}'", analysis_id);
    Ok(true)
}
```

## ğŸ¯ æ¨èå®æ–½æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šæ·»åŠ  RAII å®ˆå«ï¼ˆç«‹å³è§æ•ˆï¼‰

```bash
# ä¿®æ”¹ execution_tracker.rs
# æ·»åŠ  ExecutionLockGuard ç»“æ„ä½“
```

### ç¬¬äºŒæ­¥ï¼šä¿®æ”¹è°ƒç”¨ä½ç½®

```bash
# ä¿®æ”¹ chain_engine.rs ä¸­çš„ execute_chain_by_inline
# åœ¨å‡½æ•°å¼€å§‹å¤„ç»Ÿä¸€ä½¿ç”¨å®ˆå«
```

### ç¬¬ä¸‰æ­¥ï¼šæ·»åŠ è¶…æ—¶æœºåˆ¶ï¼ˆå¯é€‰ï¼Œå¢å¼ºé²æ£’æ€§ï¼‰

```bash
# åœ¨ execution_tracker.rs ä¸­æ·»åŠ è¶…æ—¶æ£€æŸ¥
# é˜²æ­¢å¼‚å¸¸é€€å‡ºå¯¼è‡´çš„é”æ³„æ¼
```

### ç¬¬å››æ­¥ï¼šæ·»åŠ è°ƒè¯•å·¥å…·

```rust
/// Tauri å‘½ä»¤ï¼šæŸ¥çœ‹å½“å‰æ‰§è¡ŒçŠ¶æ€ï¼ˆè°ƒè¯•ç”¨ï¼‰
#[tauri::command]
pub fn debug_execution_tracker() -> Result<String, String> {
    let active = execution_tracker::get_active_executions()?;
    Ok(format!(
        "å½“å‰æ‰§è¡Œä¸­çš„ analysis_id:\n{}\næ€»è®¡: {}",
        active.join("\n"),
        active.len()
    ))
}

/// Tauri å‘½ä»¤ï¼šæ¸…ç†æ‰€æœ‰æ‰§è¡Œé”ï¼ˆç´§æ€¥ç”¨ï¼‰
#[tauri::command]
pub fn force_clear_execution_locks() -> Result<String, String> {
    let count = execution_tracker::count();
    execution_tracker::clear_all()?;
    Ok(format!("å·²æ¸…ç† {} ä¸ªæ‰§è¡Œé”", count))
}
```

å‰ç«¯è°ƒç”¨ï¼š

```typescript
// è°ƒè¯•é¢æ¿
import { invoke } from '@tauri-apps/api/core';

async function showExecutionStatus() {
  const status = await invoke<string>('debug_execution_tracker');
  console.log(status);
  message.info(status);
}

async function forceClearLocks() {
  const result = await invoke<string>('force_clear_execution_locks');
  console.log(result);
  message.warning(result);
}
```

## ğŸ“Š éªŒè¯æ¸…å•

å®æ–½åéªŒè¯ï¼š

- [ ] ç¬¬ä¸€æ¬¡æ‰§è¡Œä¸ä¼šæŠ¥"é‡å¤æ‰§è¡Œ"é”™è¯¯
- [ ] çœŸæ­£çš„é‡å¤ç‚¹å‡»èƒ½å¤Ÿè¢«æ­£ç¡®é˜»æ­¢
- [ ] å¼‚å¸¸é€€å‡ºåé”èƒ½å¤Ÿè‡ªåŠ¨é‡Šæ”¾ï¼ˆè¶…æ—¶æœºåˆ¶ï¼‰
- [ ] é€’å½’è°ƒç”¨ä¸ä¼šå¯¼è‡´æ­»é”
- [ ] å¹¶å‘æ‰§è¡Œå¤šä¸ªä¸åŒ analysis_id æ­£å¸¸å·¥ä½œ
- [ ] è°ƒè¯•å·¥å…·èƒ½æ­£ç¡®æ˜¾ç¤ºæ‰§è¡ŒçŠ¶æ€

## ğŸš€ å¿«é€Ÿä¿®å¤ï¼ˆä¸´æ—¶æ–¹æ¡ˆï¼‰

å¦‚æœéœ€è¦ç«‹å³è§£å†³ï¼Œå¯ä»¥åœ¨å‰ç«¯æ·»åŠ é˜²æŠ–ï¼š

```typescript
import { debounce } from 'lodash-es';

// åˆ›å»ºé˜²æŠ–ç‰ˆæœ¬çš„æ‰§è¡Œå‡½æ•°
const debouncedExecute = useRef(
  debounce(async (protocol: any) => {
    const result = await SmartSelectionService.executeSmartSelection(deviceId, protocol);
    return result;
  }, 500, { leading: true, trailing: false })  // åªæ‰§è¡Œç¬¬ä¸€æ¬¡
).current;

const executeSmartSelection = async () => {
  if (executing) return;
  setExecuting(true);
  
  try {
    const protocol = createSmartSelectionProtocol();
    const result = await debouncedExecute(protocol);
    message.success('æ‰§è¡ŒæˆåŠŸ');
  } catch (error) {
    message.error(`æ‰§è¡Œå¤±è´¥: ${error}`);
  } finally {
    setExecuting(false);
  }
};
```

æˆ–è€…åœ¨åç«¯æ·»åŠ å¼ºåˆ¶æ¸…ç†å‘½ä»¤ï¼š

```rust
// åœ¨ç¨‹åºå¯åŠ¨æ—¶æ¸…ç†æ‰€æœ‰é—ç•™é”
pub fn initialize_execution_tracker() {
    if let Ok(count) = execution_tracker::clear_all() {
        if count > 0 {
            tracing::warn!("ğŸ§¹ å¯åŠ¨æ—¶æ¸…ç†äº† {} ä¸ªé—ç•™çš„æ‰§è¡Œé”", count);
        }
    }
}
```

## ğŸ“ æ€»ç»“

**æ ¸å¿ƒåŸåˆ™**ï¼š
1. **ç»Ÿä¸€å…¥å£** - æ‰€æœ‰æ‰§è¡Œè·¯å¾„åœ¨å…¥å£å¤„ç»Ÿä¸€é”å®š
2. **RAII ç®¡ç†** - ä½¿ç”¨å®ˆå«è‡ªåŠ¨é‡Šæ”¾ï¼Œé˜²æ­¢æ³„æ¼
3. **è¶…æ—¶æœºåˆ¶** - é˜²æ­¢å¼‚å¸¸æƒ…å†µä¸‹çš„é”æ³„æ¼
4. **è°ƒè¯•å·¥å…·** - æ–¹ä¾¿æ’æŸ¥é—®é¢˜

**ä¼˜å…ˆçº§**ï¼š
- ğŸ”¥ é«˜ä¼˜å…ˆçº§ï¼šæ·»åŠ  RAII å®ˆå«
- âš¡ ä¸­ä¼˜å…ˆçº§ï¼šæ·»åŠ è¶…æ—¶æœºåˆ¶
- ğŸ’¡ ä½ä¼˜å…ˆçº§ï¼šæ·»åŠ è°ƒè¯•å·¥å…·
