import React, { useState } from 'react';
import { invoke } from '@tauri-apps/api/core';
import {
  Card,
  Row,
  Col,
  Button,
  Space,
  Typography,
  Divider,
  List,
  Modal,
  Form,
  Input,
  Select,
  InputNumber,
  message,
  Timeline,
  Tag,
  Popconfirm,
  Tooltip,
} from 'antd';
import {
  PlusOutlined,
  PlayCircleOutlined,
  SaveOutlined,
  UploadOutlined,
  EditOutlined,
  DeleteOutlined,
  CopyOutlined,
  ArrowUpOutlined,
  ArrowDownOutlined,
  AimOutlined,
} from '@ant-design/icons';
import CoordinateCapture from '../components/device/CoordinateCapture';

const { Title, Text, Paragraph } = Typography;
const { Option } = Select;
const { TextArea } = Input;

// Êìç‰ΩúÁ±ªÂûãÂÆö‰πâ
export enum ActionType {
  TAP = 'tap',
  SWIPE = 'swipe',
  INPUT = 'input',
  WAIT = 'wait',
  FIND_ELEMENT = 'find_element',
  CHECK_CONDITION = 'check_condition',
  LOOP = 'loop',
  IF_CONDITION = 'if_condition',
  SCREENSHOT = 'screenshot',
  OPEN_APP = 'open_app',
}

// ËÑöÊú¨Ê≠•È™§Êé•Âè£
export interface ScriptStep {
  id: string;
  type: ActionType;
  name: string;
  description: string;
  parameters: Record<string, any>;
  enabled: boolean;
  order: number;
}

// ËÑöÊú¨ÊâßË°åÁªìÊûúÊé•Âè£
export interface ScriptExecutionResult {
  success: boolean;
  executed_steps: number;
  failed_steps?: number;
  duration?: number;
  error?: string;
}

// Êìç‰ΩúÁ±ªÂûãÈÖçÁΩÆ
const ACTION_CONFIGS = {
  [ActionType.TAP]: {
    name: 'ÁÇπÂáªÊìç‰Ωú',
    description: 'ÁÇπÂáªÊåáÂÆöÂùêÊ†áÊàñUIÂÖÉÁ¥†',
    icon: 'üëÜ',
    color: 'blue',
    parameters: [
      { key: 'coordinate', label: 'ÁÇπÂáªÂùêÊ†á', type: 'coordinate', required: true },
      { key: 'wait_after', label: 'Êìç‰ΩúÂêéÁ≠âÂæÖ(ms)', type: 'number', default: 1000 },
    ]
  },
  [ActionType.SWIPE]: {
    name: 'ÊªëÂä®Êìç‰Ωú',
    description: '‰ªéËµ∑ÂßãÁÇπÊªëÂä®Âà∞ÁªìÊùüÁÇπ',
    icon: 'üëã',
    color: 'green',
    parameters: [
      { key: 'start_coordinate', label: 'Ëµ∑ÂßãÂùêÊ†á', type: 'coordinate', required: true },
      { key: 'end_coordinate', label: 'ÁªìÊùüÂùêÊ†á', type: 'coordinate', required: true },
      { key: 'duration', label: 'ÊªëÂä®Êó∂Èïø(ms)', type: 'number', default: 1000 },
    ]
  },
  [ActionType.INPUT]: {
    name: 'ËæìÂÖ•ÊñáÊú¨',
    description: 'Âú®ÊåáÂÆö‰ΩçÁΩÆËæìÂÖ•ÊñáÊú¨ÂÜÖÂÆπ',
    icon: '‚å®Ô∏è',
    color: 'orange',
    parameters: [
      { key: 'text', label: 'ËæìÂÖ•ÂÜÖÂÆπ', type: 'text', required: true },
      { key: 'clear_first', label: 'ÂÖàÊ∏ÖÁ©∫', type: 'boolean', default: true },
    ]
  },
  [ActionType.WAIT]: {
    name: 'Á≠âÂæÖ',
    description: 'Á≠âÂæÖÊåáÂÆöÊó∂Èó¥',
    icon: '‚è±Ô∏è',
    color: 'purple',
    parameters: [
      { key: 'duration', label: 'Á≠âÂæÖÊó∂Èïø(ms)', type: 'number', required: true, default: 3000 },
    ]
  },
  [ActionType.FIND_ELEMENT]: {
    name: 'Êü•ÊâæÂÖÉÁ¥†',
    description: 'Êü•ÊâæUIÂÖÉÁ¥†Âπ∂ÂèØÈÄâÊã©ÊÄßÁÇπÂáª',
    icon: 'üîç',
    color: 'cyan',
    parameters: [
      { key: 'text', label: 'ÂÖÉÁ¥†ÊñáÊú¨', type: 'text', required: true },
      { key: 'click_if_found', label: 'ÊâæÂà∞ÂêéÁÇπÂáª', type: 'boolean', default: true },
      { key: 'timeout', label: 'Ë∂ÖÊó∂Êó∂Èó¥(ms)', type: 'number', default: 5000 },
    ]
  },
  [ActionType.CHECK_CONDITION]: {
    name: 'Êù°‰ª∂Ê£ÄÊü•',
    description: 'Ê£ÄÊü•È°µÈù¢ÊòØÂê¶Êª°Ë∂≥ÁâπÂÆöÊù°‰ª∂',
    icon: '‚úÖ',
    color: 'red',
    parameters: [
      { key: 'condition_text', label: 'Ê£ÄÊü•ÊñáÊú¨', type: 'text', required: true },
      { key: 'action_if_true', label: 'Êª°Ë∂≥Êó∂ÊâßË°å', type: 'select', options: ['continue', 'skip_next', 'goto_step'] },
      { key: 'action_if_false', label: '‰∏çÊª°Ë∂≥Êó∂ÊâßË°å', type: 'select', options: ['continue', 'skip_next', 'stop'] },
    ]
  },
};

/**
 * Ëá™Âä®ÂåñËÑöÊú¨ÊûÑÂª∫Âô®‰∏ªÈ°µÈù¢
 */
const ScriptBuilderPage: React.FC = () => {
  const [steps, setSteps] = useState<ScriptStep[]>([]);
  const [selectedStep, setSelectedStep] = useState<ScriptStep | null>(null);
  const [isModalVisible, setIsModalVisible] = useState(false);
  const [isExecuting, setIsExecuting] = useState(false);
  const [editingStep, setEditingStep] = useState<ScriptStep | null>(null);
  const [coordinateCaptureVisible, setCoordinateCaptureVisible] = useState(false);
  const [capturingForField, setCapturingForField] = useState<string | null>(null);
  const [form] = Form.useForm();

  // Ê∑ªÂä†Êñ∞Ê≠•È™§
  const handleAddStep = () => {
    setEditingStep(null);
    form.resetFields();
    setIsModalVisible(true);
  };

  // ÁºñËæëÊ≠•È™§
  const handleEditStep = (step: ScriptStep) => {
    setEditingStep(step);
    form.setFieldsValue({
      type: step.type,
      name: step.name,
      description: step.description,
      ...step.parameters,
    });
    setIsModalVisible(true);
  };

  // ‰øùÂ≠òÊ≠•È™§
  const handleSaveStep = async () => {
    try {
      const values = await form.validateFields();
      const { type, name, description, ...parameters } = values;

      const step: ScriptStep = {
        id: editingStep?.id || `step_${Date.now()}`,
        type,
        name,
        description,
        parameters,
        enabled: true,
        order: editingStep?.order || steps.length,
      };

      if (editingStep) {
        // Êõ¥Êñ∞Áé∞ÊúâÊ≠•È™§
        setSteps(prev => prev.map(s => s.id === editingStep.id ? step : s));
        message.success('Ê≠•È™§Êõ¥Êñ∞ÊàêÂäüÔºÅ');
      } else {
        // Ê∑ªÂä†Êñ∞Ê≠•È™§
        setSteps(prev => [...prev, step]);
        message.success('Ê≠•È™§Ê∑ªÂä†ÊàêÂäüÔºÅ');
      }

      setIsModalVisible(false);
      form.resetFields();
    } catch (error) {
      console.error('‰øùÂ≠òÊ≠•È™§Â§±Ë¥•:', error);
      message.error('‰øùÂ≠òÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÂøÖÂ°´È°π');
    }
  };

  // Âà†Èô§Ê≠•È™§
  const handleDeleteStep = (stepId: string) => {
    setSteps(prev => prev.filter(s => s.id !== stepId));
    message.success('Ê≠•È™§Âà†Èô§ÊàêÂäüÔºÅ');
  };

  // ÁßªÂä®Ê≠•È™§
  const moveStep = (stepId: string, direction: 'up' | 'down') => {
    const currentIndex = steps.findIndex(s => s.id === stepId);
    if (currentIndex === -1) return;

    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    if (newIndex < 0 || newIndex >= steps.length) return;

    const newSteps = [...steps];
    [newSteps[currentIndex], newSteps[newIndex]] = [newSteps[newIndex], newSteps[currentIndex]];
    
    // Êõ¥Êñ∞order
    newSteps.forEach((step, index) => {
      step.order = index;
    });

    setSteps(newSteps);
  };

  // Â§çÂà∂Ê≠•È™§
  const handleCopyStep = (step: ScriptStep) => {
    const newStep: ScriptStep = {
      ...step,
      id: `step_${Date.now()}`,
      name: `${step.name} (ÂâØÊú¨)`,
      order: steps.length,
    };
    setSteps(prev => [...prev, newStep]);
    message.success('Ê≠•È™§Â§çÂà∂ÊàêÂäüÔºÅ');
  };

  // ÂàáÊç¢Ê≠•È™§ÂêØÁî®Áä∂ÊÄÅ
  const toggleStepEnabled = (stepId: string) => {
    setSteps(prev => prev.map(s => 
      s.id === stepId ? { ...s, enabled: !s.enabled } : s
    ));
  };

  // Ê∏≤ÊüìÂèÇÊï∞ËæìÂÖ•ÁªÑ‰ª∂
  const renderParameterInput = (param: any) => {
    if (param.type === 'coordinate') {
      return (
        <Input
          placeholder={`ËØ∑ËæìÂÖ•${param.label}ÔºåÊ†ºÂºèÔºöx,y`}
          addonAfter={
            <Tooltip title="ÁÇπÂáªÊçïËé∑ÂùêÊ†á">
              <AimOutlined 
                style={{ cursor: 'pointer' }}
                onClick={() => handleCoordinateCapture(param.key)}
              />
            </Tooltip>
          }
        />
      );
    }
    
    if (param.type === 'number') {
      return (
        <InputNumber 
          placeholder={`ËØ∑ËæìÂÖ•${param.label}`}
          className="w-full"
          min={0}
        />
      );
    }
    
    if (param.type === 'boolean') {
      return (
        <Select placeholder={`ÈÄâÊã©${param.label}`}>
          <Option value={true}>ÊòØ</Option>
          <Option value={false}>Âê¶</Option>
        </Select>
      );
    }
    
    if (param.type === 'select' && param.options) {
      return (
        <Select placeholder={`ÈÄâÊã©${param.label}`}>
          {param.options.map((option: string) => (
            <Option key={option} value={option}>
              {option}
            </Option>
          ))}
        </Select>
      );
    }
    
    if (param.type === 'text' && param.key === 'text') {
      return (
        <TextArea 
          placeholder={`ËØ∑ËæìÂÖ•${param.label}`}
          rows={3}
        />
      );
    }
    
    return <Input placeholder={`ËØ∑ËæìÂÖ•${param.label}`} />;
  };

  // ÊâßË°åËÑöÊú¨
  const handleExecuteScript = async () => {
    if (steps.length === 0) {
      message.warning('ËØ∑ÂÖàÊ∑ªÂä†ËÑöÊú¨Ê≠•È™§');
      return;
    }

    const enabledSteps = steps.filter(s => s.enabled);
    if (enabledSteps.length === 0) {
      message.warning('Ê≤°ÊúâÂêØÁî®ÁöÑÊ≠•È™§ÂèØÊâßË°å');
      return;
    }

    setIsExecuting(true);
    try {
      // Ë∞ÉÁî®ÂêéÁ´ØAPIÊâßË°åËÑöÊú¨
      const result = await invoke('execute_automation_script', {
        deviceId: 'emulator-5554', // TODO: ‰ªéËÆæÂ§áÈÄâÊã©Âô®Ëé∑Âèñ
        steps: enabledSteps,
      }) as ScriptExecutionResult;

      console.log('ËÑöÊú¨ÊâßË°åÁªìÊûú:', result);
      
      if (result.success) {
        message.success(`ËÑöÊú¨ÊâßË°åÊàêÂäüÔºÅÊâßË°å‰∫Ü ${result.executed_steps} ‰∏™Ê≠•È™§ÔºåËÄóÊó∂ ${result.duration || 0} Áßí`);
      } else {
        message.warning(`ËÑöÊú¨ÊâßË°åÂÆåÊàêÔºå${result.executed_steps} ‰∏™ÊàêÂäüÔºå${result.failed_steps || 0} ‰∏™Â§±Ë¥•`);
      }
    } catch (error) {
      console.error('ËÑöÊú¨ÊâßË°åÂ§±Ë¥•:', error);
      message.error(`ËÑöÊú¨ÊâßË°åÂ§±Ë¥•: ${error}`);
    } finally {
      setIsExecuting(false);
    }
  };

  // ÂùêÊ†áÊçïËé∑Â§ÑÁêÜ
  const handleCoordinateCapture = (field: string) => {
    setCapturingForField(field);
    setCoordinateCaptureVisible(true);
  };

  const handleCoordinateSelect = (x: number, y: number) => {
    if (capturingForField) {
      if (capturingForField === 'coordinate') {
        form.setFieldsValue({ coordinate: `${x},${y}` });
      } else if (capturingForField === 'start_coordinate') {
        form.setFieldsValue({ start_coordinate: `${x},${y}` });
      } else if (capturingForField === 'end_coordinate') {
        form.setFieldsValue({ end_coordinate: `${x},${y}` });
      }
    }
    setCoordinateCaptureVisible(false);
    setCapturingForField(null);
  };

  // ‰øùÂ≠òËÑöÊú¨
  const handleSaveScript = () => {
    if (steps.length === 0) {
      message.warning('Ê≤°ÊúâÊ≠•È™§ÂèØ‰øùÂ≠ò');
      return;
    }
    // Ê®°Êãü‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®
    const scriptData = {
      name: `Script_${Date.now()}`,
      steps: steps,
      createdAt: new Date().toISOString(),
    };
    localStorage.setItem('automation_script', JSON.stringify(scriptData));
    message.success('ËÑöÊú¨‰øùÂ≠òÊàêÂäüÔºÅ');
  };

  // Ê∏≤ÊüìÊ≠•È™§ÂàóË°®È°π
  const renderStepItem = (step: ScriptStep, index: number) => {
    const config = ACTION_CONFIGS[step.type];
    
    return (
      <List.Item
        key={step.id}
        className={`transition-all duration-200 ${!step.enabled ? 'opacity-50' : ''}`}
        style={{
          border: selectedStep?.id === step.id ? '2px solid #1890ff' : '1px solid #d9d9d9',
          borderRadius: '8px',
          margin: '8px 0',
          padding: '12px',
          background: step.enabled ? '#fff' : '#f5f5f5',
        }}
        onClick={() => setSelectedStep(step)}
      >
        <div className="w-full">
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center space-x-3">
              <span className="text-lg">{config.icon}</span>
              <div>
                <Text strong className={step.enabled ? '' : 'text-gray-400'}>
                  {index + 1}. {step.name}
                </Text>
                <br />
                <Text type="secondary" className="text-sm">
                  {step.description}
                </Text>
              </div>
            </div>
            
            <div className="flex items-center space-x-2">
              <Tag color={config.color}>{config.name}</Tag>
              <Space size="small">
                <Tooltip title="ÁºñËæë">
                  <Button 
                    type="text" 
                    size="small" 
                    icon={<EditOutlined />}
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEditStep(step);
                    }}
                  />
                </Tooltip>
                
                <Tooltip title="Â§çÂà∂">
                  <Button 
                    type="text" 
                    size="small" 
                    icon={<CopyOutlined />}
                    onClick={(e) => {
                      e.stopPropagation();
                      handleCopyStep(step);
                    }}
                  />
                </Tooltip>
                
                <Tooltip title="‰∏äÁßª">
                  <Button 
                    type="text" 
                    size="small" 
                    icon={<ArrowUpOutlined />}
                    disabled={index === 0}
                    onClick={(e) => {
                      e.stopPropagation();
                      moveStep(step.id, 'up');
                    }}
                  />
                </Tooltip>
                
                <Tooltip title="‰∏ãÁßª">
                  <Button 
                    type="text" 
                    size="small" 
                    icon={<ArrowDownOutlined />}
                    disabled={index === steps.length - 1}
                    onClick={(e) => {
                      e.stopPropagation();
                      moveStep(step.id, 'down');
                    }}
                  />
                </Tooltip>
                
                <Tooltip title={step.enabled ? 'Á¶ÅÁî®' : 'ÂêØÁî®'}>
                  <Button 
                    type="text" 
                    size="small" 
                    onClick={(e) => {
                      e.stopPropagation();
                      toggleStepEnabled(step.id);
                    }}
                  >
                    {step.enabled ? 'üü¢' : '‚≠ï'}
                  </Button>
                </Tooltip>
                
                <Popconfirm
                  title="Á°ÆÂÆöÂà†Èô§Ëøô‰∏™Ê≠•È™§ÂêóÔºü"
                  onConfirm={(e) => {
                    e?.stopPropagation();
                    handleDeleteStep(step.id);
                  }}
                  okText="Âà†Èô§"
                  cancelText="ÂèñÊ∂à"
                >
                  <Button 
                    type="text" 
                    size="small" 
                    danger
                    icon={<DeleteOutlined />}
                    onClick={(e) => e.stopPropagation()}
                  />
                </Popconfirm>
              </Space>
            </div>
          </div>
          
          {/* ÂèÇÊï∞È¢ÑËßà */}
          <div className="text-xs text-gray-500 mt-2">
            {Object.entries(step.parameters).map(([key, value]) => (
              <span key={key} className="mr-3">
                {key}: <Text code>{String(value)}</Text>
              </span>
            ))}
          </div>
        </div>
      </List.Item>
    );
  };

  return (
    <div className="h-full p-6 overflow-auto">
      {/* È°µÈù¢Ê†áÈ¢ò */}
      <div className="mb-6">
        <Title level={2} className="mb-2">
          üîß Ëá™Âä®ÂåñËÑöÊú¨ÊûÑÂª∫Âô®
        </Title>
        <Paragraph type="secondary">
          ÈÄöËøáÂèØËßÜÂåñÁïåÈù¢ÊûÑÂª∫Ëá™Âä®ÂåñËÑöÊú¨ÔºåÊîØÊåÅÊãñÊãΩÊéíÂ∫è„ÄÅÂèÇÊï∞ÈÖçÁΩÆ„ÄÅÂÆûÊó∂È¢ÑËßàÂíåÊµãËØïÊâßË°å
        </Paragraph>
      </div>

      <Row gutter={16} className="h-full">
        {/* Â∑¶‰æßÔºöÊ≠•È™§ÂàóË°® */}
        <Col span={16}>
          <Card 
            title={
              <div className="flex items-center justify-between">
                <span>üìã ËÑöÊú¨Ê≠•È™§ ({steps.length})</span>
                <Space>
                  <Button 
                    type="primary" 
                    icon={<PlusOutlined />}
                    onClick={handleAddStep}
                  >
                    Ê∑ªÂä†Ê≠•È™§
                  </Button>
                </Space>
              </div>
            }
            className="h-full"
            bodyStyle={{ padding: '16px', height: 'calc(100% - 57px)', overflow: 'auto' }}
          >
            {steps.length === 0 ? (
              <div className="text-center py-16">
                <div className="text-6xl mb-4">üìù</div>
                <Title level={4} type="secondary">ËøòÊ≤°ÊúâÊ∑ªÂä†‰ªª‰ΩïÊ≠•È™§</Title>
                <Paragraph type="secondary">ÁÇπÂáª‰∏äÊñπ"Ê∑ªÂä†Ê≠•È™§"ÊåâÈíÆÂºÄÂßãÊûÑÂª∫‰Ω†ÁöÑËá™Âä®ÂåñËÑöÊú¨</Paragraph>
                <Button type="primary" size="large" icon={<PlusOutlined />} onClick={handleAddStep}>
                  Ê∑ªÂä†Á¨¨‰∏Ä‰∏™Ê≠•È™§
                </Button>
              </div>
            ) : (
              <List
                dataSource={[...steps].sort((a, b) => a.order - b.order)}
                renderItem={renderStepItem}
                pagination={false}
              />
            )}
          </Card>
        </Col>

        {/* Âè≥‰æßÔºöÊìç‰ΩúÈù¢Êùø */}
        <Col span={8}>
          <Space direction="vertical" size="middle" className="w-full">
            {/* ËÑöÊú¨ÊéßÂà∂ */}
            <Card title="üéÆ ËÑöÊú¨ÊéßÂà∂">
              <Space direction="vertical" className="w-full">
                <Button 
                  type="primary" 
                  block 
                  size="large"
                  icon={<PlayCircleOutlined />}
                  loading={isExecuting}
                  disabled={steps.length === 0}
                  onClick={handleExecuteScript}
                >
                  {isExecuting ? 'ÊâßË°å‰∏≠...' : 'ÊâßË°åËÑöÊú¨'}
                </Button>
                
                <Row gutter={8}>
                  <Col span={12}>
                    <Button 
                      block 
                      icon={<SaveOutlined />}
                      onClick={handleSaveScript}
                      disabled={steps.length === 0}
                    >
                      ‰øùÂ≠òËÑöÊú¨
                    </Button>
                  </Col>
                  <Col span={12}>
                    <Button 
                      block 
                      icon={<UploadOutlined />}
                    >
                      Âä†ËΩΩËÑöÊú¨
                    </Button>
                  </Col>
                </Row>
              </Space>
            </Card>

            {/* ËÑöÊú¨È¢ÑËßà */}
            <Card title="üëÅÔ∏è ËÑöÊú¨È¢ÑËßà" size="small">
              <Timeline>
                {steps.filter(s => s.enabled).slice(0, 5).map((step, index) => {
                  const config = ACTION_CONFIGS[step.type];
                  return (
                    <Timeline.Item 
                      key={step.id}
                      color={config.color}
                      dot={<span className="text-xs">{config.icon}</span>}
                    >
                      <Text className="text-sm">{step.name}</Text>
                    </Timeline.Item>
                  );
                })}
                {steps.filter(s => s.enabled).length > 5 && (
                  <Timeline.Item color="gray">
                    <Text type="secondary" className="text-sm">
                      ...ËøòÊúâ {steps.filter(s => s.enabled).length - 5} ‰∏™Ê≠•È™§
                    </Text>
                  </Timeline.Item>
                )}
              </Timeline>
            </Card>

            {/* Âø´ÈÄüÊ∑ªÂä† */}
            <Card title="‚ö° Âø´ÈÄüÊ∑ªÂä†" size="small">
              <Space direction="vertical" className="w-full" size="small">
                <Button 
                  block 
                  size="small"
                  onClick={() => {
                    setEditingStep(null);
                    form.setFieldsValue({ type: ActionType.TAP });
                    setIsModalVisible(true);
                  }}
                >
                  üëÜ Ê∑ªÂä†ÁÇπÂáª
                </Button>
                <Button 
                  block 
                  size="small"
                  onClick={() => {
                    setEditingStep(null);
                    form.setFieldsValue({ type: ActionType.WAIT });
                    setIsModalVisible(true);
                  }}
                >
                  ‚è±Ô∏è Ê∑ªÂä†Á≠âÂæÖ
                </Button>
                <Button 
                  block 
                  size="small"
                  onClick={() => {
                    setEditingStep(null);
                    form.setFieldsValue({ type: ActionType.FIND_ELEMENT });
                    setIsModalVisible(true);
                  }}
                >
                  üîç Êü•ÊâæÂÖÉÁ¥†
                </Button>
              </Space>
            </Card>
          </Space>
        </Col>
      </Row>

      {/* Ê≠•È™§ÁºñËæëÊ®°ÊÄÅÊ°Ü */}
      <Modal
        title={editingStep ? 'ÁºñËæëÊ≠•È™§' : 'Ê∑ªÂä†Êñ∞Ê≠•È™§'}
        open={isModalVisible}
        onOk={handleSaveStep}
        onCancel={() => {
          setIsModalVisible(false);
          form.resetFields();
        }}
        width={600}
        okText="‰øùÂ≠ò"
        cancelText="ÂèñÊ∂à"
      >
        <Form form={form} layout="vertical" initialValues={{ enabled: true }}>
          <Form.Item
            name="type"
            label="Êìç‰ΩúÁ±ªÂûã"
            rules={[{ required: true, message: 'ËØ∑ÈÄâÊã©Êìç‰ΩúÁ±ªÂûã' }]}
          >
            <Select placeholder="ÈÄâÊã©Êìç‰ΩúÁ±ªÂûã">
              {Object.entries(ACTION_CONFIGS).map(([key, config]) => (
                <Option key={key} value={key}>
                  {config.icon} {config.name} - {config.description}
                </Option>
              ))}
            </Select>
          </Form.Item>

          <Row gutter={16}>
            <Col span={12}>
              <Form.Item
                name="name"
                label="Ê≠•È™§ÂêçÁß∞"
                rules={[{ required: true, message: 'ËØ∑ËæìÂÖ•Ê≠•È™§ÂêçÁß∞' }]}
              >
                <Input placeholder="‰æãÂ¶ÇÔºöÁÇπÂáªÁôªÂΩïÊåâÈíÆ" />
              </Form.Item>
            </Col>
            <Col span={12}>
              <Form.Item name="description" label="Ê≠•È™§ÊèèËø∞">
                <Input placeholder="ËØ¶ÁªÜÊèèËø∞Ëøô‰∏™Ê≠•È™§ÁöÑ‰ΩúÁî®" />
              </Form.Item>
            </Col>
          </Row>

          {/* Âä®ÊÄÅÂèÇÊï∞Ë°®Âçï */}
          <Form.Item shouldUpdate={(prevValues, currentValues) => prevValues.type !== currentValues.type}>
            {({ getFieldValue }) => {
              const actionType = getFieldValue('type');
              if (!actionType || !ACTION_CONFIGS[actionType]) return null;

              const config = ACTION_CONFIGS[actionType];
              return (
                <div>
                  <Divider>ÂèÇÊï∞ÈÖçÁΩÆ</Divider>
                  <Row gutter={16}>
                    {config.parameters.map((param) => (
                      <Col span={param.type === 'text' ? 24 : 12} key={param.key}>
                        <Form.Item
                          name={param.key}
                          label={param.label}
                          rules={param.required ? [{ required: true, message: `ËØ∑ËæìÂÖ•${param.label}` }] : []}
                          initialValue={param.default}
                        >
                          {renderParameterInput(param)}
                        </Form.Item>
                      </Col>
                    ))}
                  </Row>
                </div>
              );
            }}
          </Form.Item>
        </Form>
      </Modal>

      {/* ÂùêÊ†áÊçïËé∑Â∑•ÂÖ∑ */}
      <CoordinateCapture
        visible={coordinateCaptureVisible}
        onClose={() => {
          setCoordinateCaptureVisible(false);
          setCapturingForField(null);
        }}
        onCoordinateSelect={handleCoordinateSelect}
        deviceId="emulator-5554"
      />
    </div>
  );
};

export default ScriptBuilderPage;

