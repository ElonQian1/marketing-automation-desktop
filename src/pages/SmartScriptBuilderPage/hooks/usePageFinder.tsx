import React, { useState, useCallback, useMemo } from "react";
import { message, FormInstance } from "antd";
import SmartStepGenerator from "../../../modules/SmartStepGenerator";
import {
  ElementLocator,
  XmlSnapshot,
  createXmlSnapshot,
} from "../../../types/selfContainedScript";
import {
  SmartActionType,
} from "../../../types/smartComponents";
import { ExtendedSmartScriptStep } from "../../../types/loopScript";
import {
  parseBoundsString,
  rectToBoundsString,
} from "../../../components/universal-ui/utils/bounds";
import XmlCacheManager from "../../../services/XmlCacheManager";
import { Device } from "../../../domain/adb/entities/Device";
import {
  buildShortTitleFromCriteria,
  buildShortDescriptionFromCriteria,
} from "../helpers/titleBuilder";
import { buildAndCacheDefaultMatchingFromElement } from "../helpers/matchingHelpers";
import buildXmlSnapshotFromContext from "../helpers/xmlSnapshotHelper";
import sanitizeContentDesc from "../helpers/contentDescSanitizer";
import type { NodeLocator } from "../../../domain/inspector/entities/NodeLocator";
import type {
  MatchCriteria as UIMatchCriteria,
  MatchStrategy as UIMatchStrategy,
} from "../../../components/universal-ui/views/grid-view/panels/node-detail/types";
import { createBindingFromSnapshotAndXPath } from "../../../components/step-card/element-binding/helpers";

// üÜï ÂØºÂÖ•Â¢ûÂº∫ÂåπÈÖçÁ≥ªÁªü
import { EnhancedMatchingHelper } from "../../../modules/enhanced-matching/integration/EnhancedMatchingHelper";

// ËΩªÈáèÊ≠£ÂàôËΩ¨‰πâÔºåÈÅøÂÖçÁî®Êà∑ËæìÂÖ•ÂΩ±Âìç ^...$ Ê®°Âºè
const escapeRegex = (input: string): string => input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

export interface SnapshotFixMode {
  enabled: boolean;
  forStepId?: string;
}

export interface UsePageFinderDeps {
  steps: ExtendedSmartScriptStep[];
  setSteps: React.Dispatch<React.SetStateAction<ExtendedSmartScriptStep[]>>;
  form: FormInstance;
  currentDeviceId: string;
  devices: Device[];
  showAddModal: (options?: { resetFields?: boolean }) => void;
  // Êñ∞Â¢û‰æùËµñ
  setEditingStep: React.Dispatch<React.SetStateAction<ExtendedSmartScriptStep | null>>;
  handleSaveStep: () => Promise<void>;
}

export function usePageFinder(deps: UsePageFinderDeps) {
  const {
    steps,
    setSteps,
    form,
    currentDeviceId,
    devices,
    showAddModal,
    setEditingStep,
    handleSaveStep,
  } = deps;

  const [showPageAnalyzer, setShowPageAnalyzer] = useState(false);
  const [snapshotFixMode, setSnapshotFixMode] = useState<SnapshotFixMode>({
    enabled: false,
  });
  const [pendingAutoResave, setPendingAutoResave] = useState<boolean>(false);
  const [isQuickAnalyzer, setIsQuickAnalyzer] = useState(false);
  const [editingStepForParams, setEditingStepForParams] = useState<ExtendedSmartScriptStep | null>(null);
  const [allowSaveWithoutXmlOnce, setAllowSaveWithoutXmlOnce] = useState<boolean>(false);
  const [currentXmlContent, setCurrentXmlContent] = useState<string>("");
  const [currentDeviceInfo, setCurrentDeviceInfo] = useState<Partial<XmlSnapshot["deviceInfo"]>>({});
  const [currentPageInfo, setCurrentPageInfo] = useState<Partial<XmlSnapshot["pageInfo"]>>({});

  const openPageAnalyzer = (options: {
    quick?: boolean;
    forStep?: ExtendedSmartScriptStep | null;
    fixSnapshot?: boolean;
    stepIdToFix?: string;
  }) => {
    setIsQuickAnalyzer(options.quick || false);
    setEditingStepForParams(options.forStep || null);
    if (options.fixSnapshot && options.stepIdToFix) {
      setSnapshotFixMode({ enabled: true, forStepId: options.stepIdToFix });
      setPendingAutoResave(true);
    }
    setShowPageAnalyzer(true);
  };

  const updateCurrentXmlContext = useCallback(
    (
      xmlContent: string,
      deviceInfo?: Partial<XmlSnapshot["deviceInfo"]>,
      pageInfo?: Partial<XmlSnapshot["pageInfo"]>
    ) => {
      if (currentXmlContent === xmlContent) return;
      setCurrentXmlContent(xmlContent);
      if (deviceInfo) setCurrentDeviceInfo((prev) => ({ ...prev, ...deviceInfo }));
      if (pageInfo) setCurrentPageInfo((prev) => ({ ...prev, ...pageInfo }));
    },
    [currentXmlContent]
  );

  const openPageFinderForStep = (step: ExtendedSmartScriptStep) => {
    setEditingStepForParams(step);
    setIsQuickAnalyzer(false);
    setShowPageAnalyzer(true);
  };

  const openQuickPageFinder = () => {
    setIsQuickAnalyzer(true);
    setEditingStepForParams(null);
    setShowPageAnalyzer(true);
  };

  const openSnapshotFixer = (stepId: string) => {
    setSnapshotFixMode({ enabled: true, forStepId: stepId });
    setPendingAutoResave(true);
    setIsQuickAnalyzer(false);
    setEditingStepForParams(null);
    setShowPageAnalyzer(true);
    message.info("Ê≠£Âú®ÈááÈõÜÈ°µÈù¢Âø´ÁÖß‰ª•‰øÆÂ§çÂΩìÂâçÊ≠•È™§ÔºåËØ∑Á®çÂÄô‚Ä¶");
  };

  const onSnapshotCaptured = (snapshot: XmlSnapshot) => {
    form.setFieldValue("xmlSnapshot", snapshot);
    updateCurrentXmlContext(
      snapshot.xmlContent,
      snapshot.deviceInfo,
      snapshot.pageInfo
    );
    message.success("Â∑≤ÂõûÂ°´ÊúÄÊñ∞È°µÈù¢Âø´ÁÖß");
    setSnapshotFixMode({ enabled: false, forStepId: undefined });
    if (pendingAutoResave) {
      setPendingAutoResave(false);
      setTimeout(() => {
        handleSaveStep();
      }, 0);
    }
  };

  const onSnapshotUpdated = (snapshot: XmlSnapshot) => {
    try {
      form.setFieldValue("xmlSnapshot", snapshot);
      updateCurrentXmlContext(
        snapshot.xmlContent,
        snapshot.deviceInfo,
        snapshot.pageInfo
      );
    } catch (e) {
      console.warn("onSnapshotUpdated Â§ÑÁêÜÂ§±Ë¥•ÔºàÂèØÂøΩÁï•Ôºâ:", e);
    }
  };

  const onElementSelected = (element: any) => {
    console.log("üéØ Êé•Êî∂Âà∞Â¢ûÂº∫Êô∫ËÉΩÂàÜÊûêÂÖÉÁ¥†:", element);
    console.log("üéØ ÂΩìÂâçÊ®°ÂºèÊ£ÄÊü•:", {
      isQuickAnalyzer,
      editingStepForParams: editingStepForParams?.id,
    });

    try {
      const stepInfo = SmartStepGenerator.generateStepInfo(element);

      form.setFieldValue("step_type", SmartActionType.SMART_FIND_ELEMENT);
      form.setFieldValue("search_criteria", stepInfo.searchCriteria);
      form.setFieldValue("name", stepInfo.name);
      form.setFieldValue("description", stepInfo.description);
      form.setFieldValue("click_if_found", true);

      const builtLocator: ElementLocator | undefined = element.bounds
        ? {
            selectedBounds:
              typeof (element as any).bounds === "string"
                ? parseBoundsString((element as any).bounds) || {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0,
                  }
                : (element as any).bounds,
            elementPath:
              (element as any).xpath || (element as any).element_path || "",
            confidence: (element as any).smartAnalysis?.confidence || 0.8,
            additionalInfo: {
              xpath: (element as any).xpath,
              resourceId: (element as any).resource_id,
              text: (element as any).text,
              contentDesc: (element as any).content_desc,
              className: (element as any).class_name,
              bounds: ((): string | undefined => {
                const b = (element as any).bounds;
                if (!b) return undefined;
                if (typeof b === "string") return b;
                return rectToBoundsString(b);
              })(),
            },
          }
        : undefined;

      if (builtLocator) {
        form.setFieldValue("elementLocator", builtLocator);
        const sb = builtLocator.selectedBounds;
        form.setFieldValue("boundsRect", sb);
        form.setFieldValue("bounds", rectToBoundsString(sb));
      }

      const snap = buildXmlSnapshotFromContext({
        currentXmlContent,
        currentDeviceInfo,
        currentPageInfo,
        element: element as any,
        fallbackDeviceId: currentDeviceId,
        fallbackDeviceName: devices.find((d) => d.id === currentDeviceId)
            ?.name,
      });
      if (snap) {
        form.setFieldValue("xmlSnapshot", snap);
        // üÜï Ë°®ÂçïÊÄÅÔºö‰ºòÂÖà‰ΩøÁî® enhancedElement.nodePath.xpath + xmlSnapshot ÁîüÊàêÂÖÉÁ¥†ÁªëÂÆö
        try {
          const eeXPath: string | undefined = (element as any)?.enhancedElement?.nodePath?.xpath;
          const xpathFromElement: string | undefined = eeXPath || (element as any).xpath || (element as any).element_path;
          if (xpathFromElement && typeof xpathFromElement === 'string') {
            const bindingSnapshot = {
              source: 'memory' as const,
              text: snap.xmlContent,
              sha1: snap.xmlHash,
              capturedAt: snap.timestamp || Date.now(),
              deviceId: snap.deviceInfo?.deviceId,
            };
            const binding = createBindingFromSnapshotAndXPath(bindingSnapshot, xpathFromElement);
            if (binding) {
              form.setFieldValue('elementBinding', binding);
            }
          }
        } catch (e) {
          console.warn('elementBindingÔºàË°®ÂçïÊÄÅÔºâÁîüÊàêÂ§±Ë¥•ÔºàÂÖÅËÆ∏Ë∑≥ËøáÔºâÔºö', e);
        }
      }

      // üîß ÂÆâÂÖ®Â§çÂà∂Â§çÊùÇÂØπË±°ÔºåÈÅøÂÖçÂæ™ÁéØÂºïÁî®ÂØºËá¥Ë°®ÂçïËÆæÁΩÆÂ§±Ë¥•
      const safeSmartAnalysis = element.smartAnalysis ? {
        confidence: element.smartAnalysis.confidence,
        reasoning: element.smartAnalysis.reasoning,
        context: element.smartAnalysis.context
      } : undefined;

      const basicParams = {
        text: element.text,
        element_text: element.text,
        element_type: element.element_type,
        resource_id: element.resource_id,
        content_desc: sanitizeContentDesc(element.content_desc),
        bounds: element.bounds
          ? `[${element.bounds.left},${element.bounds.top}][${element.bounds.right},${element.bounds.bottom}]`
          : undefined,
        smartDescription: element.smartDescription,
        smartAnalysis: safeSmartAnalysis,
      };
      Object.entries(basicParams).forEach(([key, value]) => {
        try {
          form.setFieldValue(key, value);
        } catch (e) {
          console.warn(`ËÆæÁΩÆË°®ÂçïÂ≠óÊÆµ ${key} Â§±Ë¥•:`, e);
        }
      });

      // üÜï ‰ΩøÁî®Â¢ûÂº∫ÂåπÈÖçÁ≥ªÁªüÁîüÊàêÂåπÈÖçÊù°‰ª∂
      // ‰ºòÂÖà‰ΩøÁî®Â¢ûÂº∫ÂÖÉÁ¥†ÁöÑËäÇÁÇπË∑ØÂæÑ‰∏éËäÇÁÇπËØ¶ÊÉÖÔºåÈÅøÂÖç xpath ‰∏çÂêàÊ≥ïÊàñ class_name Êò†Â∞ÑÁº∫Â§±
      const ee: any = (element as any)?.enhancedElement;
      const xmlForMatch = ee?.xmlContext?.xmlSourceContent || currentXmlContent;
      const enhancedElement = {
        resource_id: ee?.nodeDetails?.resourceId ?? element.resource_id,
        text: ee?.nodeDetails?.text ?? element.text,
        content_desc: ee?.nodeDetails?.contentDesc ?? element.content_desc,
        class_name: ee?.nodeDetails?.className ?? (element as any).class_name ?? element.element_type,
        bounds: ee?.nodeDetails?.bounds ?? element.bounds,
        xpath: ee?.nodePath?.xpath ?? (element as any).xpath ?? (element as any).element_path,
        element_path: (element as any).element_path,
        // Ê∑ªÂä†ÂèØËÉΩÂ≠òÂú®ÁöÑÊâ©Â±ïÂ±ûÊÄßÔºà‰ªé‰∫§‰∫íÁä∂ÊÄÅÊò†Â∞ÑÔºâ
        clickable: ee?.nodeDetails?.interactionStates?.clickable?.toString() ?? (element as any).clickable,
        enabled: ee?.nodeDetails?.interactionStates?.enabled?.toString() ?? (element as any).enabled,
        selected: ee?.nodeDetails?.interactionStates?.selected?.toString() ?? (element as any).selected,
        checkable: ee?.nodeDetails?.interactionStates?.checkable?.toString() ?? (element as any).checkable,
        checked: ee?.nodeDetails?.interactionStates?.checked?.toString() ?? (element as any).checked,
        scrollable: ee?.nodeDetails?.interactionStates?.scrollable?.toString() ?? (element as any).scrollable,
        package: (element as any).package,
        index: (element as any).index,
      };

      if (process.env.NODE_ENV === 'development') {
        console.log('üß© EnhancedMatching ÂÖ•ÂèÇÈ¢ÑËßà:', {
          xpath: enhancedElement.xpath,
          class_name: enhancedElement.class_name,
          text: enhancedElement.text,
          resource_id: enhancedElement.resource_id,
          hasXml: !!xmlForMatch,
        });
      }

      const built = EnhancedMatchingHelper.buildEnhancedMatching(enhancedElement, {
        useEnhancedMatching: true,
        xmlContext: xmlForMatch,
        optimizationOptions: {
          enableParentContext: true,
          enableChildContext: true,
          enableDescendantSearch: false, // ‰øùÂÆàËÆæÁΩÆÔºåÈÅøÂÖçÊÄßËÉΩÈóÆÈ¢ò
          maxDepth: 2,
          prioritizeSemanticFields: true,
          excludePositionalFields: false // ÂÖÅËÆ∏‰ΩçÁΩÆÂ≠óÊÆµ‰Ωú‰∏∫Â§áÈÄâ
        },
        fallbackToLegacy: true, // Â¢ûÂº∫ÂåπÈÖçÂ§±Ë¥•Êó∂ÈôçÁ∫ßÂà∞ÂéüÊúâÈÄªËæë
        debug: process.env.NODE_ENV === 'development' // ÂºÄÂèëÊ®°Âºè‰∏ãÂêØÁî®Ë∞ÉËØï
      });
      if (built && built.fields.length > 0) {
        // ‰∏∫ÊñáÊú¨Áõ∏ÂÖ≥Â≠óÊÆµÈªòËÆ§Ê≥®ÂÖ•Á≤æÁ°ÆÊ≠£Âàô ^ËØç$Ôºå‰æø‰∫éÂêéÁ´Ø enhanced_unified Áõ¥Êé•ÈááÁî®
        const textLike = ["text", "content-desc"] as const;
        const matchMode: Record<string, "equals" | "contains" | "regex"> = {};
        const regexIncludes: Record<string, string[]> = {};
        for (const f of built.fields) {
          if ((textLike as readonly string[]).includes(f) && typeof built.values[f] === 'string') {
            const v = String(built.values[f]).trim();
            if (v) {
              matchMode[f] = 'regex';
              regexIncludes[f] = [`^${escapeRegex(v)}$`];
            }
          }
        }
        form.setFieldValue("matching", {
          strategy: built.strategy,
          fields: built.fields,
          values: built.values,
          ...(Object.keys(matchMode).length ? { matchMode } : {}),
          ...(Object.keys(regexIncludes).length ? { regexIncludes } : {}),
          updatedAt: Date.now(),
        });
      }

      setShowPageAnalyzer(false);
      setIsQuickAnalyzer(false);
      setEditingStepForParams(null);

      if (editingStepForParams) {
        const updatedSteps = steps.map((existingStep) => {
          if (existingStep.id === editingStepForParams.id) {
            const updatedParameters: any = {
              ...existingStep.parameters,
              text: element.text,
              element_text: element.text,
              element_type: element.element_type,
              resource_id: element.resource_id,
              content_desc: sanitizeContentDesc(element.content_desc),
              bounds: element.bounds
                ? `[${element.bounds.left},${element.bounds.top}][${element.bounds.right},${element.bounds.bottom}]`
                : existingStep.parameters?.bounds,
              smartDescription: element.smartDescription,
              smartAnalysis: element.smartAnalysis ? {
                confidence: element.smartAnalysis.confidence,
                reasoning: element.smartAnalysis.reasoning,
                context: element.smartAnalysis.context
              } : undefined,
              ...(builtLocator ? { elementLocator: builtLocator } : {}),
            };
            if (built && built.fields.length > 0) {
              const textLike = ["text", "content-desc"] as const;
              const matchMode: Record<string, "equals" | "contains" | "regex"> = {};
              const regexIncludes: Record<string, string[]> = {};
              for (const f of built.fields) {
                if ((textLike as readonly string[]).includes(f) && typeof built.values[f] === 'string') {
                  const v = String(built.values[f]).trim();
                  if (v) {
                    matchMode[f] = 'regex';
                    regexIncludes[f] = [`^${escapeRegex(v)}$`];
                  }
                }
              }
              updatedParameters.matching = {
                strategy: built.strategy,
                fields: built.fields,
                values: built.values,
                ...(Object.keys(matchMode).length ? { matchMode } : {}),
                ...(Object.keys(regexIncludes).length ? { regexIncludes } : {}),
                updatedAt: Date.now(),
              };
            }
            if (currentXmlContent) {
              updatedParameters.xmlSnapshot = createXmlSnapshot(
                currentXmlContent,
                {
                  deviceId: currentDeviceInfo.deviceId || currentDeviceId || "unknown",
                  deviceName:
                    currentDeviceInfo.deviceName ||
                    devices.find((d) => d.id === currentDeviceId)?.name ||
                    "unknown",
                  appPackage: currentDeviceInfo.appPackage || "com.xingin.xhs",
                  activityName: currentDeviceInfo.activityName || "unknown",
                },
                {
                  pageTitle: currentPageInfo.pageTitle || "Â∞èÁ∫¢‰π¶È°µÈù¢",
                  pageType: currentPageInfo.pageType || "unknown",
                  elementCount: currentPageInfo.elementCount || 0,
                  appVersion: currentPageInfo.appVersion,
                }
              );
              // üÜï ÁºñËæëÁé∞ÊúâÊ≠•È™§Ôºö‰ºòÂÖà‰ΩøÁî® enhancedElement.nodePath.xpath ÁîüÊàê elementBinding
              try {
                const eeXPath: string | undefined = (element as any)?.enhancedElement?.nodePath?.xpath;
                const xpathFromElement: string | undefined = eeXPath || (element as any).xpath || (element as any).element_path;
                if (xpathFromElement) {
                  const bindingSnapshot = {
                    source: 'memory' as const,
                    text: updatedParameters.xmlSnapshot.xmlContent,
                    sha1: updatedParameters.xmlSnapshot.xmlHash,
                    capturedAt: updatedParameters.xmlSnapshot.timestamp || Date.now(),
                    deviceId: updatedParameters.xmlSnapshot.deviceInfo?.deviceId,
                  };
                  const binding = createBindingFromSnapshotAndXPath(bindingSnapshot, xpathFromElement);
                  if (binding) {
                    updatedParameters.elementBinding = binding;
                  }
                }
              } catch (e) {
                console.warn('elementBindingÔºàÁºñËæëÊ≠•È™§ÔºâÁîüÊàêÂ§±Ë¥•ÔºàÂÖÅËÆ∏Ë∑≥ËøáÔºâÔºö', e);
              }
            }
            return {
              ...existingStep,
              name: stepInfo.name,
              description: stepInfo.description,
              parameters: updatedParameters,
            };
          }
          return existingStep;
        });
        setSteps(updatedSteps);
        message.success({
          content: (
            <div>
              <div style={{ fontWeight: "bold", marginBottom: "4px" }}>
                ‚úèÔ∏è Ê≠•È™§ÂèÇÊï∞‰øÆÊîπÊàêÂäüÔºÅ
              </div>
              <div style={{ fontSize: "12px", color: "#666" }}>
                {editingStepForParams.name} ‚Üí {stepInfo.name}
              </div>
            </div>
          ),
          duration: 3,
        });
      } else if (isQuickAnalyzer) {
        setEditingStep(null);
        showAddModal({ resetFields: false });
        message.success({
          content: (
            <div>
              <div style={{ fontWeight: "bold", marginBottom: "4px" }}>
                üöÄ Âø´Êç∑Ê≠•È™§ÁîüÊàêÊàêÂäüÔºÅ
              </div>
              <div style={{ fontSize: "12px", color: "#666" }}>
                {stepInfo.name} - ËØ∑ÁÇπÂáªÁ°ÆÂÆöÂÆåÊàêÂàõÂª∫
              </div>
            </div>
          ),
          duration: 4,
        });
        // üÜï Âø´Êç∑Ê®°Âºè‰∏ãÂ∞ùËØïËá™Âä®‰øùÂ≠òÔºöÂú®ÊâìÂºÄÂºπÁ™óÂêéÁü≠Âª∂Êó∂Ëß¶Âèë‰øùÂ≠òÔºåÈÅøÂÖçÁî®Êà∑ÂøòËÆ∞ÁÇπÂáª"Á°ÆÂÆö"ÂØºËá¥Êú™ÁîüÊàêÊ≠•È™§
        // ËØ¥ÊòéÔºöËã•Ë°®ÂçïÈ°πÂ∞öÊú™ÂÆåÊàêÊåÇËΩΩÊàñÊ†°È™å‰∏çÈÄöËøáÔºåhandleSaveStep ÂÜÖÈÉ®‰ºöÂÆâÂÖ®Âú∞ËÆ∞ÂΩïÂπ∂‰øùÁïôÂºπÁ™óÔºåÁî®Êà∑‰ªçÂèØÊâãÂä®Á°ÆËÆ§
        setTimeout(async () => {
          console.log('ü§ñ [Âø´Êç∑Ê®°Âºè] ÂºÄÂßãËá™Âä®‰øùÂ≠òÊ≠•È™§...');
          console.log('üîç [Âø´Êç∑Ê®°Âºè] Ë°®ÂçïÂ≠óÊÆµÁä∂ÊÄÅÊ£ÄÊü•:', {
            step_type: form.getFieldValue('step_type'),
            name: form.getFieldValue('name'),
            description: form.getFieldValue('description'),
            matching: form.getFieldValue('matching'),
            elementBinding: form.getFieldValue('elementBinding'),
            xmlSnapshot: form.getFieldValue('xmlSnapshot')
          });
          // üîß Âø´Êç∑Ê®°ÂºèÂÖÅËÆ∏Ë∑≥Ëøá‰∏•Ê†ºXMLÈ™åËØÅ
          setAllowSaveWithoutXmlOnce(true);
          try {
            await handleSaveStep();
            console.log('‚úÖ [Âø´Êç∑Ê®°Âºè] Ëá™Âä®‰øùÂ≠òÊàêÂäü');
          } catch (e) {
            console.warn('‚ö†Ô∏è [Âø´Êç∑Ê®°Âºè] Ëá™Âä®‰øùÂ≠òÂ§±Ë¥•ÔºàÁî®Êà∑ÂèØÊâãÂä®ÁÇπÂáªÁ°ÆÂÆöÔºâ:', e);
          }
        }, 200);
      } else {
        message.success({
          content: (
            <div>
              <div style={{ fontWeight: "bold", marginBottom: "4px" }}>
                üéØ Êô∫ËÉΩÊ≠•È™§ÁîüÊàêÊàêÂäüÔºÅ
              </div>
              <div style={{ fontSize: "12px", color: "#666" }}>
                {stepInfo.name}
              </div>
            </div>
          ),
          duration: 3,
        });
      }
      SmartStepGenerator.previewStepInfo(element);
    } catch (error) {
      console.error("‚ùå Êô∫ËÉΩÊ≠•È™§ÁîüÊàêÂ§±Ë¥•:", error);
      message.error("Êô∫ËÉΩÊ≠•È™§ÁîüÊàêÂ§±Ë¥•");
    }
  };

  const onApplyCriteria = (criteria: any) => {
    console.log('üéØ [usePageFinder] onApplyCriteria Ë¢´Ë∞ÉÁî®Ôºåcriteria:', criteria);
    try {
      const matchCriteria: UIMatchCriteria = {
        strategy: criteria.strategy as UIMatchStrategy,
        fields: criteria.fields,
        values: criteria.values,
        includes: criteria.includes,
        excludes: criteria.excludes,
      };
      const nextTitle: string = buildShortTitleFromCriteria(matchCriteria);
      const nextDesc: string = buildShortDescriptionFromCriteria(matchCriteria);

      if (editingStepForParams) {
        const stepId = editingStepForParams.id;
        setSteps((prev) =>
          prev.map((s) => {
            if (s.id !== stepId) return s;
            const p: any = { ...(s.parameters || {}) };
            p.matching = {
              strategy: criteria.strategy,
              fields: criteria.fields,
              values: criteria.values,
              includes: criteria.includes,
              excludes: criteria.excludes,
              // üÜï Ê∑ªÂä†Ê≠£ÂàôË°®ËææÂºèÁõ∏ÂÖ≥ÂèÇÊï∞
              ...(criteria.matchMode && { matchMode: criteria.matchMode }),
              ...(criteria.regexIncludes && { regexIncludes: criteria.regexIncludes }),
              ...(criteria.regexExcludes && { regexExcludes: criteria.regexExcludes }),
              updatedAt: Date.now(),
            };
            p.elementLocator = p.elementLocator || {};
            p.elementLocator.additionalInfo = {
              ...(p.elementLocator.additionalInfo || {}),
              xpath: criteria.preview?.xpath || p.elementLocator.additionalInfo?.xpath,
              resourceId: p.elementLocator.additionalInfo?.resourceId || criteria.values["resource-id"],
              text: p.elementLocator.additionalInfo?.text || criteria.values["text"],
              contentDesc: p.elementLocator.additionalInfo?.contentDesc || criteria.values["content-desc"],
              className: p.elementLocator.additionalInfo?.className || criteria.values["class"],
              bounds: criteria.preview?.bounds || p.elementLocator.additionalInfo?.bounds || p.bounds,
            };
            if (criteria.preview?.bounds) {
              p.bounds = criteria.preview.bounds;
            } else if (criteria.values["bounds"]) {
              p.bounds = criteria.values["bounds"];
            }
            if (criteria.values["resource-id"]) p.resource_id = criteria.values["resource-id"];
            if (criteria.values["text"]) p.text = criteria.values["text"];
            if (criteria.values["content-desc"]) p.content_desc = criteria.values["content-desc"];
            if (criteria.values["class"]) p.class_name = criteria.values["class"];

            // üÜï ‰øùÂ≠òÂÖÉÁ¥†ÁªëÂÆöÔºàelementBindingÔºâÔºöÈúÄË¶Å xmlSnapshot ‰∏é preview.xpathÔºà‰ºòÂÖàÊù•Ëá™ enhancedElement.nodePath.xpathÔºâ
            try {
              const snap = (p.xmlSnapshot || form.getFieldValue("xmlSnapshot")) as XmlSnapshot | undefined;
              const xpath: string | undefined = criteria.preview?.xpath;
              if (snap && typeof snap.xmlContent === 'string' && xpath && xpath.trim()) {
                const bindingSnapshot = {
                  source: 'memory' as const,
                  text: snap.xmlContent,
                  sha1: snap.xmlHash,
                  capturedAt: snap.timestamp || Date.now(),
                  deviceId: snap.deviceInfo?.deviceId,
                };
                // Âª∂ËøüÂä†ËΩΩ‰ª•ÈÅøÂÖçÈ°∂ÈÉ®Âæ™ÁéØ‰æùËµñ
                const binding = createBindingFromSnapshotAndXPath(bindingSnapshot, xpath);
                if (binding) {
                  p.elementBinding = binding;
                }
              }
            } catch (e) {
              console.warn('elementBinding ÁîüÊàêÂ§±Ë¥•ÔºàÂÖÅËÆ∏Ë∑≥ËøáÔºâÔºö', e);
            }
            
            const patched = { ...s, parameters: p } as any;
            patched.name = nextTitle || s.name;
            patched.description = nextDesc || s.description;
            return patched;
          })
        );
        setShowPageAnalyzer(false);
        setIsQuickAnalyzer(false);
        setEditingStepForParams(null);
      } else {
        form.setFieldValue("step_type", SmartActionType.SMART_FIND_ELEMENT);
        form.setFieldValue("name", nextTitle || "Êü•ÊâæÂÖÉÁ¥†");
        form.setFieldValue("description", nextDesc || "Ê†πÊçÆÂåπÈÖçÊù°‰ª∂Êü•ÊâæÂÖÉÁ¥†");
        form.setFieldValue("matching", {
          strategy: criteria.strategy,
          fields: criteria.fields,
          values: criteria.values,
          includes: criteria.includes,
          excludes: criteria.excludes,
          // üÜï ÂêåÊ≠•Ê≠£Âàô/ÂåπÈÖçÊ®°ÂºèÂà∞Ë°®Âçï
          ...(criteria.matchMode ? { matchMode: criteria.matchMode } : {}),
          ...(criteria.regexIncludes ? { regexIncludes: criteria.regexIncludes } : {}),
          ...(criteria.regexExcludes ? { regexExcludes: criteria.regexExcludes } : {}),
          updatedAt: Date.now(),
        });

        const additionalInfo = {
          xpath: criteria.preview?.xpath,
          resourceId: criteria.values["resource-id"],
          text: criteria.values["text"],
          contentDesc: criteria.values["content-desc"],
          className: criteria.values["class"],
          bounds: criteria.preview?.bounds,
        };
        const builtLocator: ElementLocator | undefined =
          additionalInfo.xpath || criteria.preview?.bounds
            ? {
                selectedBounds: (() => {
                  const b = criteria.preview?.bounds;
                  if (!b) return { left: 0, top: 0, right: 0, bottom: 0 };
                  if (typeof b === "string") {
                    return parseBoundsString(b) || { left: 0, top: 0, right: 0, bottom: 0 };
                  }
                  return b;
                })(),
                elementPath: criteria.preview?.xpath || "",
                confidence: 0.8,
                additionalInfo: {
                  ...additionalInfo,
                  bounds:
                    typeof criteria.preview?.bounds === "string"
                      ? criteria.preview?.bounds
                      : criteria.preview?.bounds
                      ? rectToBoundsString(criteria.preview?.bounds)
                      : undefined,
                },
              }
            : undefined;
        if (builtLocator) {
          form.setFieldValue("elementLocator", builtLocator);
        }

        const snap = buildXmlSnapshotFromContext({
          currentXmlContent,
          currentDeviceInfo,
          currentPageInfo,
          fallbackDeviceId: currentDeviceId,
          fallbackDeviceName: devices.find((d) => d.id === currentDeviceId)?.name,
        });
        if (snap) form.setFieldValue("xmlSnapshot", snap);

        // üÜï Êñ∞Âª∫Ê≠•È™§Ë°®ÂçïÊÄÅÔºöÁîüÊàêÂπ∂ÂÜôÂÖ• elementBindingÔºàÈöèË°®Âçï‰øùÂ≠òÔºâ
        try {
          const xpath: string | undefined = criteria.preview?.xpath;
          const effectiveSnap: XmlSnapshot | undefined = snap || form.getFieldValue("xmlSnapshot");
          if (effectiveSnap && typeof effectiveSnap.xmlContent === 'string' && xpath && xpath.trim()) {
            const bindingSnapshot = {
              source: 'memory' as const,
              text: effectiveSnap.xmlContent,
              sha1: effectiveSnap.xmlHash,
              capturedAt: effectiveSnap.timestamp || Date.now(),
              deviceId: effectiveSnap.deviceInfo?.deviceId,
            };
            const binding = createBindingFromSnapshotAndXPath(bindingSnapshot, xpath);
            if (binding) {
              form.setFieldValue('elementBinding', binding);
            }
          }
        } catch (e) {
          console.warn('elementBindingÔºàÊñ∞Âª∫Ë°®ÂçïÔºâÁîüÊàêÂ§±Ë¥•ÔºàÂÖÅËÆ∏Ë∑≥ËøáÔºâÔºö', e);
        }

        setShowPageAnalyzer(false);
        setIsQuickAnalyzer(false);
        setEditingStepForParams(null);
  setEditingStep(null);
  setAllowSaveWithoutXmlOnce(true);
  showAddModal({ resetFields: false });

        message.success({
          content: (
            <div>
              <div style={{ fontWeight: "bold", marginBottom: 4 }}>
                üöÄ Â∑≤Ê†πÊçÆÂåπÈÖçÊù°‰ª∂È¢ÑÂ°´Êñ∞Ê≠•È™§
              </div>
              <div style={{ fontSize: 12, color: "#666" }}>{nextTitle}</div>
            </div>
          ),
          duration: 3,
        });
      }
    } catch (e) {
      console.warn("Â∫îÁî®ÂåπÈÖçÁ≠ñÁï•Âà∞Ê≠•È™§Â§±Ë¥•:", e);
    }
  };

  const onClose = () => {
    setShowPageAnalyzer(false);
    setIsQuickAnalyzer(false);
    setEditingStepForParams(null);
    if (snapshotFixMode.enabled) {
      setSnapshotFixMode({ enabled: false, forStepId: undefined });
      setPendingAutoResave(false);
    }
  };

  const loadFromStepXml = useMemo(
    () =>
      editingStepForParams
        ? {
            stepId: editingStepForParams.id,
            xmlCacheId: editingStepForParams.parameters?.xmlCacheId,
            xmlContent:
              editingStepForParams.parameters?.xmlSnapshot?.xmlContent ||
              editingStepForParams.parameters?.xmlContent,
            deviceId:
              editingStepForParams.parameters?.xmlSnapshot?.deviceInfo?.deviceId ||
              editingStepForParams.parameters?.deviceId,
            deviceName:
              editingStepForParams.parameters?.xmlSnapshot?.deviceInfo?.deviceName ||
              editingStepForParams.parameters?.deviceName,
          }
        : undefined,
    [
      editingStepForParams?.id,
      editingStepForParams?.parameters?.xmlSnapshot?.xmlContent,
      editingStepForParams?.parameters?.xmlContent,
      editingStepForParams?.parameters?.xmlCacheId,
    ]
  );

  const preselectLocator = useMemo(() => {
    if (!editingStepForParams) return undefined;
    const p: any = editingStepForParams.parameters || {};
    const locator: NodeLocator = {} as any;
    const preferXPath: string | undefined =
      p.elementLocator?.additionalInfo?.xpath || p.xpath;
    if (preferXPath && typeof preferXPath === "string" && preferXPath.trim()) {
      if (/^\s*\//.test(preferXPath))
        locator.absoluteXPath = String(preferXPath).trim();
      else locator.predicateXPath = String(preferXPath).trim();
    }
    locator.attributes = {
      resourceId: p.resource_id || p.element_resource_id || undefined,
      text: p.element_text || p.text || undefined,
      className: p.class_name || undefined,
      contentDesc: p.content_desc || undefined,
      packageName: p.package_name || undefined,
    };
    if (p.bounds && typeof p.bounds === "string") {
      locator.bounds = p.bounds;
    } else {
      const sb = p.elementLocator?.selectedBounds;
      if (sb && typeof sb.left === "number") {
        locator.bounds = `[${sb.left},${sb.top}][${sb.right},${sb.bottom}]`;
      } else if (p.elementLocator?.additionalInfo?.bounds) {
        locator.bounds = p.elementLocator.additionalInfo.bounds;
      }
    }
    const hasAny =
      locator.absoluteXPath ||
      locator.predicateXPath ||
      locator.bounds ||
      (locator.attributes && Object.values(locator.attributes).some(Boolean));
    
    console.log('üîß [usePageFinder] ÊûÑÂª∫ preselectLocator:', {
      hasAny,
      locator,
      stepId: editingStepForParams?.id,
      stepParameters: p
    });
    
    return hasAny ? locator : undefined;
  }, [editingStepForParams]);

  const initialMatching = useMemo(() => {
    if (!editingStepForParams) return undefined;
    const m: any = editingStepForParams.parameters?.matching;
    if (m && Array.isArray(m.fields) && m.fields.length > 0) {
      return {
        strategy: (m.strategy || "standard") as UIMatchStrategy,
        fields: m.fields as string[],
        values: (m.values || {}) as Record<string, string>,
        includes: m.includes as Record<string, string[]>,
        excludes: m.excludes as Record<string, string[]>,
      };
    }
    return undefined;
  }, [editingStepForParams?.id]);

  const pageFinderProps = {
    visible: showPageAnalyzer,
    initialViewMode: (editingStepForParams ? "grid" : "visual") as "grid" | "visual",
    snapshotOnlyMode: snapshotFixMode.enabled,
    onSnapshotCaptured,
    onSnapshotUpdated,
    loadFromStepXml,
    preselectLocator,
    initialMatching,
    onXmlContentUpdated: updateCurrentXmlContext,
    onApplyCriteria,
    onClose,
    onElementSelected,
  };

  console.log('üìã [usePageFinder] pageFinderProps ÈÖçÁΩÆ:', {
    visible: pageFinderProps.visible,
    initialViewMode: pageFinderProps.initialViewMode,
    preselectLocator: pageFinderProps.preselectLocator,
    initialMatching: pageFinderProps.initialMatching,
    editingStepId: editingStepForParams?.id
  });  return {
    pageFinderProps,
    openPageFinderForStep,
    openQuickPageFinder,
    openSnapshotFixer,
    editingStepForParams,
    currentXmlContent,
    currentDeviceInfo,
    currentPageInfo,
    updateCurrentXmlContext,
    setEditingStepForParams,
    showPageAnalyzer,
    setShowPageAnalyzer,
    snapshotFixMode,
    setSnapshotFixMode,
    pendingAutoResave,
    setPendingAutoResave,
    isQuickAnalyzer,
    setIsQuickAnalyzer,
    allowSaveWithoutXmlOnce,
    setAllowSaveWithoutXmlOnce,
  };
}
