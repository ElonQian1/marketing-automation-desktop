/**
 * 查重频控服务
 * 
 * 实现四级去重机制：
 * 1. 评论级去重 - 防止对同一条评论重复操作
 * 2. 用户级去重 - 防止对同一用户重复操作
 * 3. 跨设备查重 - 避免多设备对同一目标操作
 * 4. 频控策略 - 控制操作频率和时间间隔
 */

import { invoke } from '@tauri-apps/api/core';
import { 
  Comment, 
  Task, 
  WatchTarget, 
  Platform,
  TaskType 
} from '../../shared/types/core';
import { generateId } from '../../shared/utils';

/**
 * 去重级别枚举
 */
export enum DedupLevel {
  COMMENT = 'comment',    // 评论级去重
  USER = 'user',          // 用户级去重
  DEVICE = 'device',      // 设备级去重
  FREQUENCY = 'frequency' // 频率去重
}

/**
 * 频控策略枚举
 */
export enum RateLimitStrategy {
  FIXED_INTERVAL = 'fixed_interval',     // 固定间隔
  EXPONENTIAL_BACKOFF = 'exponential_backoff', // 指数退避
  ADAPTIVE = 'adaptive',                 // 自适应调整
  TIME_WINDOW = 'time_window'           // 时间窗口
}

/**
 * 去重记录
 */
export interface DedupRecord {
  id: string;
  level: DedupLevel;
  key: string;              // 去重键
  value: string;            // 去重值
  platform: Platform;
  task_type: TaskType;
  device_id?: string;
  created_at: Date;
  expires_at?: Date;        // 过期时间
  metadata?: Record<string, any>;
}

/**
 * 频控配置
 */
export interface RateLimitConfig {
  strategy: RateLimitStrategy;
  base_interval_ms: number;     // 基础间隔（毫秒）
  max_interval_ms: number;      // 最大间隔
  max_operations_per_hour: number; // 每小时最大操作数
  max_operations_per_day: number;  // 每天最大操作数
  cooldown_after_failure_ms: number; // 失败后冷却时间
  burst_size: number;           // 突发容量
  window_size_minutes: number;  // 时间窗口大小（分钟）
}

/**
 * 去重检查结果
 */
export interface DedupCheckResult {
  allowed: boolean;
  reason?: string;
  conflicting_record?: DedupRecord;
  suggested_delay_ms?: number;
  next_available_time?: Date;
}

/**
 * 频控检查结果  
 */
export interface RateLimitCheckResult {
  allowed: boolean;
  reason?: string;
  current_rate: number;
  limit: number;
  reset_time: Date;
  retry_after_ms?: number;
}

/**
 * 去重统计
 */
export interface DedupStats {
  total_records: number;
  by_level: Record<DedupLevel, number>;
  by_platform: Record<Platform, number>;
  by_task_type: Record<TaskType, number>;
  recent_blocks: Array<{
    timestamp: Date;
    level: DedupLevel;
    key: string;
    reason: string;
  }>;
  effectiveness_rate: number; // 有效去重率
}

export class RateLimitService {
  private defaultConfig: RateLimitConfig = {
    strategy: RateLimitStrategy.ADAPTIVE,
    base_interval_ms: 3000,
    max_interval_ms: 60000,
    max_operations_per_hour: 120,
    max_operations_per_day: 1000,
    cooldown_after_failure_ms: 30000,
    burst_size: 5,
    window_size_minutes: 15
  };

  /**
   * 评论级去重检查
   */
  async checkCommentDedup(
    comment: Comment, 
    taskType: TaskType, 
    deviceId: string
  ): Promise<DedupCheckResult> {
    const dedupKey = this.generateCommentDedupKey(comment, taskType);
    
    try {
      const existingRecord = await this.findDedupRecord(
        DedupLevel.COMMENT, 
        dedupKey
      );

      if (existingRecord) {
        return {
          allowed: false,
          reason: '该评论已存在相同类型的操作记录',
          conflicting_record: existingRecord
        };
      }

      return { allowed: true };

    } catch (error) {
      console.error('Comment dedup check failed:', error);
      return {
        allowed: false,
        reason: '去重检查失败，为安全起见拒绝操作'
      };
    }
  }

  /**
   * 用户级去重检查
   */
  async checkUserDedup(
    userId: string,
    platform: Platform,
    taskType: TaskType,
    deviceId: string
  ): Promise<DedupCheckResult> {
    const dedupKey = this.generateUserDedupKey(userId, platform, taskType);
    
    try {
      const existingRecord = await this.findDedupRecord(
        DedupLevel.USER, 
        dedupKey
      );

      if (existingRecord) {
        // 检查是否在冷却期内
        const cooldownEnd = new Date(existingRecord.created_at.getTime() + this.defaultConfig.cooldown_after_failure_ms);
        if (new Date() < cooldownEnd) {
          return {
            allowed: false,
            reason: '用户操作冷却期内，请稍后再试',
            conflicting_record: existingRecord,
            next_available_time: cooldownEnd
          };
        }
      }

      return { allowed: true };

    } catch (error) {
      console.error('User dedup check failed:', error);
      return {
        allowed: false,
        reason: '用户去重检查失败'
      };
    }
  }

  /**
   * 跨设备查重检查
   */
  async checkCrossDeviceDedup(
    target: WatchTarget,
    taskType: TaskType,
    currentDeviceId: string
  ): Promise<DedupCheckResult> {
    const dedupKey = this.generateTargetDedupKey(target, taskType);
    
    try {
      const records = await this.findDedupRecords(DedupLevel.DEVICE, dedupKey);
      
      // 查找其他设备的记录
      const otherDeviceRecords = records.filter(
        record => record.device_id && record.device_id !== currentDeviceId
      );

      if (otherDeviceRecords.length > 0) {
        const latestRecord = otherDeviceRecords
          .sort((a, b) => b.created_at.getTime() - a.created_at.getTime())[0];

        // 检查时间间隔
        const minInterval = 10 * 60 * 1000; // 10分钟最小间隔
        const timeSinceLastOp = Date.now() - latestRecord.created_at.getTime();
        
        if (timeSinceLastOp < minInterval) {
          return {
            allowed: false,
            reason: `其他设备最近已操作此目标，请等待 ${Math.ceil((minInterval - timeSinceLastOp) / 60000)} 分钟`,
            conflicting_record: latestRecord,
            suggested_delay_ms: minInterval - timeSinceLastOp
          };
        }
      }

      return { allowed: true };

    } catch (error) {
      console.error('Cross-device dedup check failed:', error);
      return {
        allowed: false,
        reason: '跨设备查重检查失败'
      };
    }
  }

  /**
   * 频控检查
   */
  async checkRateLimit(
    deviceId: string,
    platform: Platform,
    taskType: TaskType,
    config?: Partial<RateLimitConfig>
  ): Promise<RateLimitCheckResult> {
    const effectiveConfig = { ...this.defaultConfig, ...config };
    
    try {
      // 检查时间窗口内的操作数量
      const windowStart = new Date();
      windowStart.setMinutes(windowStart.getMinutes() - effectiveConfig.window_size_minutes);
      
      const recentOperations = await this.getRecentOperations(
        deviceId,
        platform,
        taskType,
        windowStart
      );

      // 检查突发容量
      const burstOperations = recentOperations.filter(
        op => Date.now() - op.created_at.getTime() < effectiveConfig.base_interval_ms * effectiveConfig.burst_size
      );

      if (burstOperations.length >= effectiveConfig.burst_size) {
        const oldestBurstOp = burstOperations
          .sort((a, b) => a.created_at.getTime() - b.created_at.getTime())[0];
        const retryAfter = effectiveConfig.base_interval_ms * effectiveConfig.burst_size - 
          (Date.now() - oldestBurstOp.created_at.getTime());

        return {
          allowed: false,
          reason: '操作频率过高，已触发突发限制',
          current_rate: burstOperations.length,
          limit: effectiveConfig.burst_size,
          reset_time: new Date(Date.now() + retryAfter),
          retry_after_ms: retryAfter
        };
      }

      // 检查每小时限制
      const hourOperations = recentOperations.filter(
        op => Date.now() - op.created_at.getTime() < 60 * 60 * 1000
      );

      if (hourOperations.length >= effectiveConfig.max_operations_per_hour) {
        const oldestHourOp = hourOperations
          .sort((a, b) => a.created_at.getTime() - b.created_at.getTime())[0];
        const resetTime = new Date(oldestHourOp.created_at.getTime() + 60 * 60 * 1000);

        return {
          allowed: false,
          reason: '已达到每小时操作限制',
          current_rate: hourOperations.length,
          limit: effectiveConfig.max_operations_per_hour,
          reset_time: resetTime,
          retry_after_ms: resetTime.getTime() - Date.now()
        };
      }

      // 检查每日限制
      const dayOperations = recentOperations.filter(
        op => Date.now() - op.created_at.getTime() < 24 * 60 * 60 * 1000
      );

      if (dayOperations.length >= effectiveConfig.max_operations_per_day) {
        const oldestDayOp = dayOperations
          .sort((a, b) => a.created_at.getTime() - b.created_at.getTime())[0];
        const resetTime = new Date(oldestDayOp.created_at.getTime() + 24 * 60 * 60 * 1000);

        return {
          allowed: false,
          reason: '已达到每日操作限制',
          current_rate: dayOperations.length,
          limit: effectiveConfig.max_operations_per_day,
          reset_time: resetTime,
          retry_after_ms: resetTime.getTime() - Date.now()
        };
      }

      return {
        allowed: true,
        current_rate: recentOperations.length,
        limit: effectiveConfig.max_operations_per_hour,
        reset_time: new Date(Date.now() + effectiveConfig.window_size_minutes * 60 * 1000)
      };

    } catch (error) {
      console.error('Rate limit check failed:', error);
      return {
        allowed: false,
        reason: '频控检查失败',
        current_rate: 0,
        limit: effectiveConfig.max_operations_per_hour,
        reset_time: new Date()
      };
    }
  }

  /**
   * 综合去重检查
   */
  async performComprehensiveCheck(
    task: Task,
    comment?: Comment,
    target?: WatchTarget
  ): Promise<{
    allowed: boolean;
    reasons: string[];
    suggested_delay_ms?: number;
  }> {
    const results: DedupCheckResult[] = [];
    const reasons: string[] = [];

    try {
      // 1. 评论级去重检查
      if (comment && task.assigned_device_id) {
        const commentResult = await this.checkCommentDedup(
          comment, 
          task.task_type, 
          task.assigned_device_id
        );
        results.push(commentResult);
        if (!commentResult.allowed) {
          reasons.push(commentResult.reason!);
        }
      }

      // 2. 用户级去重检查  
      if (task.target_user_id && task.assigned_device_id) {
        const userResult = await this.checkUserDedup(
          task.target_user_id,
          task.platform,
          task.task_type,
          task.assigned_device_id
        );
        results.push(userResult);
        if (!userResult.allowed) {
          reasons.push(userResult.reason!);
        }
      }

      // 3. 跨设备查重检查
      if (target && task.assigned_device_id) {
        const deviceResult = await this.checkCrossDeviceDedup(
          target,
          task.task_type,
          task.assigned_device_id
        );
        results.push(deviceResult);
        if (!deviceResult.allowed) {
          reasons.push(deviceResult.reason!);
        }
      }

      // 4. 频控检查
      if (task.assigned_device_id) {
        const rateLimitResult = await this.checkRateLimit(
          task.assigned_device_id,
          task.platform,
          task.task_type
        );
        if (!rateLimitResult.allowed) {
          reasons.push(rateLimitResult.reason!);
        }
      }

      const allowed = results.every(result => result.allowed);
      const maxDelay = Math.max(
        ...results
          .map(r => r.suggested_delay_ms || 0)
          .filter(delay => delay > 0)
      );

      return {
        allowed,
        reasons,
        suggested_delay_ms: maxDelay > 0 ? maxDelay : undefined
      };

    } catch (error) {
      console.error('Comprehensive check failed:', error);
      return {
        allowed: false,
        reasons: ['综合去重检查失败，为安全起见拒绝操作']
      };
    }
  }

  /**
   * 记录操作
   */
  async recordOperation(
    task: Task,
    comment?: Comment,
    target?: WatchTarget
  ): Promise<void> {
    const records: DedupRecord[] = [];

    try {
      // 记录评论级操作
      if (comment) {
        records.push({
          id: generateId(),
          level: DedupLevel.COMMENT,
          key: this.generateCommentDedupKey(comment, task.task_type),
          value: comment.id,
          platform: task.platform,
          task_type: task.task_type,
          device_id: task.assigned_device_id,
          created_at: new Date(),
          expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7天过期
          metadata: {
            comment_content: comment.content.substring(0, 100),
            comment_author: comment.author_id
          }
        });
      }

      // 记录用户级操作
      if (task.target_user_id) {
        records.push({
          id: generateId(),
          level: DedupLevel.USER,
          key: this.generateUserDedupKey(task.target_user_id, task.platform, task.task_type),
          value: task.target_user_id,
          platform: task.platform,
          task_type: task.task_type,
          device_id: task.assigned_device_id,
          created_at: new Date(),
          expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24小时过期
          metadata: {
            task_id: task.id
          }
        });
      }

      // 记录设备级操作
      if (target) {
        records.push({
          id: generateId(),
          level: DedupLevel.DEVICE,
          key: this.generateTargetDedupKey(target, task.task_type),
          value: target.id,
          platform: task.platform,
          task_type: task.task_type,
          device_id: task.assigned_device_id,
          created_at: new Date(),
          expires_at: new Date(Date.now() + 60 * 60 * 1000), // 1小时过期
          metadata: {
            target_title: target.title,
            target_url: target.platform_id_or_url
          }
        });
      }

      // 记录频率操作
      records.push({
        id: generateId(),
        level: DedupLevel.FREQUENCY,
        key: this.generateFrequencyKey(task.assigned_device_id!, task.platform, task.task_type),
        value: task.id,
        platform: task.platform,
        task_type: task.task_type,
        device_id: task.assigned_device_id,
        created_at: new Date(),
        expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24小时过期
        metadata: {
          task_priority: task.priority
        }
      });

      // 批量保存记录
      await this.saveDedupRecords(records);

    } catch (error) {
      console.error('Failed to record operation:', error);
      // 记录失败不影响主流程，但需要记录日志
    }
  }

  /**
   * 获取去重统计
   */
  async getDedupStats(since?: Date): Promise<DedupStats> {
    try {
      const stats = await invoke<DedupStats>('get_dedup_stats', {
        since: since?.toISOString()
      });

      return stats;
    } catch (error) {
      console.error('Failed to get dedup stats:', error);
      throw new Error(`获取去重统计失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 清理过期记录
   */
  async cleanupExpiredRecords(): Promise<number> {
    try {
      const deletedCount = await invoke<number>('cleanup_expired_dedup_records');
      return deletedCount;
    } catch (error) {
      console.error('Failed to cleanup expired records:', error);
      return 0;
    }
  }

  /**
   * 私有辅助方法
   */

  private generateCommentDedupKey(comment: Comment, taskType: TaskType): string {
    return `comment:${comment.platform}:${comment.id}:${taskType}`;
  }

  private generateUserDedupKey(userId: string, platform: Platform, taskType: TaskType): string {
    return `user:${platform}:${userId}:${taskType}`;
  }

  private generateTargetDedupKey(target: WatchTarget, taskType: TaskType): string {
    return `target:${target.platform}:${target.platform_id_or_url}:${taskType}`;
  }

  private generateFrequencyKey(deviceId: string, platform: Platform, taskType: TaskType): string {
    return `freq:${deviceId}:${platform}:${taskType}:${Math.floor(Date.now() / 60000)}`; // 按分钟分组
  }

  private async findDedupRecord(level: DedupLevel, key: string): Promise<DedupRecord | null> {
    try {
      const record = await invoke<DedupRecord | null>('find_dedup_record', {
        level,
        key
      });

      return record;
    } catch (error) {
      console.error('Failed to find dedup record:', error);
      return null;
    }
  }

  private async findDedupRecords(level: DedupLevel, key: string): Promise<DedupRecord[]> {
    try {
      const records = await invoke<DedupRecord[]>('find_dedup_records', {
        level,
        key
      });

      return records;
    } catch (error) {
      console.error('Failed to find dedup records:', error);
      return [];
    }
  }

  private async getRecentOperations(
    deviceId: string,
    platform: Platform,
    taskType: TaskType,
    since: Date
  ): Promise<DedupRecord[]> {
    try {
      const operations = await invoke<DedupRecord[]>('get_recent_operations', {
        device_id: deviceId,
        platform,
        task_type: taskType,
        since: since.toISOString()
      });

      return operations;
    } catch (error) {
      console.error('Failed to get recent operations:', error);
      return [];
    }
  }

  private async saveDedupRecords(records: DedupRecord[]): Promise<void> {
    try {
      await invoke('save_dedup_records', { records });
    } catch (error) {
      console.error('Failed to save dedup records:', error);
      throw error;
    }
  }
}