/**
 * 任务引擎服务
 * 
 * 负责任务的生成、分发、执行和状态管理
 * 实现状态机：NEW → READY → EXECUTING → DONE/FAILED
 */

import { invoke } from '@tauri-apps/api/core';
import { 
  Task, 
  TaskStatus, 
  TaskType, 
  WatchTarget, 
  Comment,
  Platform,
  TaskPriority,
  TaskAssignmentStrategy
} from '../../shared/types/core';
import { generateId } from '../../shared/utils';

/**
 * 任务生成配置
 */
export interface TaskGenerationConfig {
  target: WatchTarget;
  max_tasks_per_target: number;
  task_types: TaskType[];
  priority: TaskPriority;
  assignment_strategy: TaskAssignmentStrategy;
  schedule_delay_hours?: number;
  required_device_count?: number;
}

/**
 * 任务生成结果
 */
export interface TaskGenerationResult {
  generated_tasks: Task[];
  total_count: number;
  target_id: string;
  generation_time: Date;
  estimated_completion_time?: Date;
}

/**
 * 任务批量生成配置
 */
export interface BatchTaskGenerationConfig {
  targets: WatchTarget[];
  comments_per_target: Comment[][];
  base_config: Omit<TaskGenerationConfig, 'target'>;
  distribution_strategy: 'even' | 'weighted' | 'priority_based';
}

/**
 * 任务执行统计
 */
export interface TaskExecutionStats {
  total_tasks: number;
  completed_tasks: number;
  failed_tasks: number;
  pending_tasks: number;
  executing_tasks: number;
  success_rate: number;
  average_execution_time_ms: number;
  by_task_type: Record<TaskType, {
    total: number;
    completed: number;
    failed: number;
    success_rate: number;
  }>;
  by_platform: Record<Platform, {
    total: number;
    completed: number;
    failed: number;
  }>;
}

/**
 * 任务查询参数
 */
export interface TaskQuery {
  status?: TaskStatus[];
  task_type?: TaskType[];
  platform?: Platform[];
  assigned_device_id?: string;
  target_id?: string;
  created_since?: Date;
  created_until?: Date;
  priority?: TaskPriority[];
  limit?: number;
  offset?: number;
  order_by?: 'created_at' | 'updated_at' | 'priority' | 'deadline';
  order_direction?: 'asc' | 'desc';
}

export class TaskEngineService {
  /**
   * 根据目标和评论生成任务
   */
  async generateTasks(config: TaskGenerationConfig): Promise<TaskGenerationResult> {
    const startTime = Date.now();
    const generatedTasks: Task[] = [];

    try {
      // 根据任务类型生成不同的任务
      for (const taskType of config.task_types) {
        const tasks = await this.generateTasksByType(config, taskType);
        generatedTasks.push(...tasks);
      }

      // 限制任务数量
      const limitedTasks = generatedTasks.slice(0, config.max_tasks_per_target);

      // 保存任务到数据库
      await this.saveTasks(limitedTasks);

      const result: TaskGenerationResult = {
        generated_tasks: limitedTasks,
        total_count: limitedTasks.length,
        target_id: config.target.id,
        generation_time: new Date(),
        estimated_completion_time: this.estimateCompletionTime(limitedTasks)
      };

      // 记录生成日志
      await this.logTaskGeneration(result);

      return result;

    } catch (error) {
      console.error('Task generation failed:', error);
      throw new Error(`任务生成失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 批量生成任务
   */
  async batchGenerateTasks(config: BatchTaskGenerationConfig): Promise<TaskGenerationResult[]> {
    const results: TaskGenerationResult[] = [];

    for (let i = 0; i < config.targets.length; i++) {
      const target = config.targets[i];
      const comments = config.comments_per_target[i] || [];

      try {
        const taskConfig: TaskGenerationConfig = {
          ...config.base_config,
          target,
          // 可以基于评论数量动态调整任务数
          max_tasks_per_target: Math.min(
            config.base_config.max_tasks_per_target,
            Math.ceil(comments.length * 0.3) // 30%的评论生成任务
          )
        };

        const result = await this.generateTasks(taskConfig);
        results.push(result);

        // 避免过于频繁的生成
        await this.delay(100);

      } catch (error) {
        console.error(`Failed to generate tasks for target ${target.id}:`, error);
        // 继续处理其他目标
      }
    }

    return results;
  }

  /**
   * 根据任务类型生成具体任务
   */
  private async generateTasksByType(
    config: TaskGenerationConfig, 
    taskType: TaskType
  ): Promise<Task[]> {
    const tasks: Task[] = [];
    const baseTask = {
      id: '',
      task_type: taskType,
      platform: config.target.platform,
      status: TaskStatus.NEW,
      priority: config.priority,
      target_id: config.target.id,
      created_at: new Date(),
      updated_at: new Date(),
      retry_count: 0,
      max_retries: 3
    };

    switch (taskType) {
      case TaskType.FOLLOW:
        // 关注任务：基于作者
        tasks.push({
          ...baseTask,
          id: generateId(),
          action_params: {
            action: 'follow',
            target_user_id: config.target.platform_id_or_url,
            target_username: config.target.title
          },
          estimated_duration_ms: 3000
        });
        break;

      case TaskType.LIKE:
        // 点赞任务：基于视频
        tasks.push({
          ...baseTask,
          id: generateId(),
          action_params: {
            action: 'like',
            video_id: config.target.platform_id_or_url,
            video_title: config.target.title
          },
          estimated_duration_ms: 2000
        });
        break;

      case TaskType.COMMENT:
        // 评论任务：需要结合模板
        const commentCount = Math.min(3, config.max_tasks_per_target);
        for (let i = 0; i < commentCount; i++) {
          tasks.push({
            ...baseTask,
            id: generateId(),
            action_params: {
              action: 'comment',
              video_id: config.target.platform_id_or_url,
              video_title: config.target.title,
              comment_template_id: '', // 需要从模板管理器获取
              comment_sequence: i + 1
            },
            estimated_duration_ms: 5000,
            dependencies: i > 0 ? [tasks[i - 1].id] : undefined // 评论间需要间隔
          });
        }
        break;

      case TaskType.SHARE:
        // 分享任务
        tasks.push({
          ...baseTask,
          id: generateId(),
          action_params: {
            action: 'share',
            video_id: config.target.platform_id_or_url,
            share_type: 'copy_link'
          },
          estimated_duration_ms: 2500
        });
        break;

      case TaskType.VIEW:
        // 观看任务
        tasks.push({
          ...baseTask,
          id: generateId(),
          action_params: {
            action: 'view',
            video_id: config.target.platform_id_or_url,
            view_duration_seconds: Math.floor(Math.random() * 30) + 10 // 10-40秒
          },
          estimated_duration_ms: 45000 // 包含观看时间
        });
        break;
    }

    // 设置调度时间
    if (config.schedule_delay_hours) {
      const scheduleTime = new Date();
      scheduleTime.setHours(scheduleTime.getHours() + config.schedule_delay_hours);
      
      tasks.forEach(task => {
        task.scheduled_time = scheduleTime;
      });
    }

    return tasks;
  }

  /**
   * 获取任务列表
   */
  async getTasks(query: TaskQuery): Promise<{
    tasks: Task[];
    total_count: number;
    has_more: boolean;
  }> {
    try {
      const result = await invoke<{
        tasks: Task[];
        total_count: number;
        has_more: boolean;
      }>('get_tasks', { query });

      return result;
    } catch (error) {
      console.error('Failed to get tasks:', error);
      throw new Error(`获取任务失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 更新任务状态
   */
  async updateTaskStatus(
    taskId: string, 
    status: TaskStatus, 
    result?: any, 
    error?: string
  ): Promise<void> {
    try {
      await invoke('update_task_status', {
        task_id: taskId,
        status,
        result,
        error,
        updated_at: new Date()
      });

      // 如果任务完成或失败，检查是否需要重试
      if (status === TaskStatus.FAILED) {
        await this.handleTaskFailure(taskId);
      }

    } catch (error) {
      console.error('Failed to update task status:', error);
      throw new Error(`更新任务状态失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 分配任务给设备
   */
  async assignTasksToDevice(
    deviceId: string, 
    maxTasks: number = 10,
    taskTypes?: TaskType[]
  ): Promise<Task[]> {
    try {
      const query: TaskQuery = {
        status: [TaskStatus.READY],
        task_type: taskTypes,
        limit: maxTasks,
        order_by: 'priority',
        order_direction: 'desc'
      };

      const { tasks } = await this.getTasks(query);
      
      // 过滤出可以分配给该设备的任务
      const assignableTasks = await this.filterAssignableTasks(tasks, deviceId);
      
      // 更新任务状态为执行中
      for (const task of assignableTasks) {
        await invoke('assign_task_to_device', {
          task_id: task.id,
          device_id: deviceId,
          status: TaskStatus.EXECUTING,
          assigned_at: new Date()
        });
        
        task.assigned_device_id = deviceId;
        task.status = TaskStatus.EXECUTING;
        task.assigned_at = new Date();
      }

      return assignableTasks;

    } catch (error) {
      console.error('Failed to assign tasks to device:', error);
      throw new Error(`任务分配失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 获取任务执行统计
   */
  async getExecutionStats(since?: Date): Promise<TaskExecutionStats> {
    try {
      const stats = await invoke<TaskExecutionStats>('get_task_execution_stats', {
        since: since?.toISOString()
      });

      return stats;
    } catch (error) {
      console.error('Failed to get execution stats:', error);
      throw new Error(`获取执行统计失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 取消任务
   */
  async cancelTask(taskId: string, reason?: string): Promise<void> {
    try {
      await invoke('cancel_task', {
        task_id: taskId,
        reason,
        cancelled_at: new Date()
      });
    } catch (error) {
      console.error('Failed to cancel task:', error);
      throw new Error(`取消任务失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 重试失败的任务
   */
  async retryFailedTask(taskId: string): Promise<void> {
    try {
      await invoke('retry_failed_task', {
        task_id: taskId,
        reset_to_ready: true,
        increment_retry_count: true,
        updated_at: new Date()
      });
    } catch (error) {
      console.error('Failed to retry task:', error);
      throw new Error(`重试任务失败: ${error instanceof Error ? error.message : '未知错误'}`);
    }
  }

  /**
   * 私有辅助方法
   */
  
  private async saveTasks(tasks: Task[]): Promise<void> {
    try {
      await invoke('save_tasks', { tasks });
    } catch (error) {
      console.error('Failed to save tasks:', error);
      throw error;
    }
  }

  private estimateCompletionTime(tasks: Task[]): Date {
    const totalDuration = tasks.reduce((sum, task) => sum + (task.estimated_duration_ms || 0), 0);
    const completionTime = new Date();
    completionTime.setTime(completionTime.getTime() + totalDuration);
    return completionTime;
  }

  private async logTaskGeneration(result: TaskGenerationResult): Promise<void> {
    try {
      await invoke('log_task_generation', {
        target_id: result.target_id,
        task_count: result.total_count,
        generation_time: result.generation_time
      });
    } catch (error) {
      console.error('Failed to log task generation:', error);
      // 不抛出错误，因为这不是关键操作
    }
  }

  private async handleTaskFailure(taskId: string): Promise<void> {
    try {
      const task = await invoke<Task>('get_task_by_id', { task_id: taskId });
      
      if (task.retry_count < task.max_retries) {
        // 重置为就绪状态，等待重试
        await invoke('update_task_status', {
          task_id: taskId,
          status: TaskStatus.READY,
          retry_count: task.retry_count + 1,
          updated_at: new Date()
        });
      }
    } catch (error) {
      console.error('Failed to handle task failure:', error);
    }
  }

  private async filterAssignableTasks(tasks: Task[], deviceId: string): Promise<Task[]> {
    // TODO: 实现设备能力匹配逻辑
    // 例如：检查设备是否支持特定平台，是否有足够的权限等
    return tasks.filter(task => {
      // 简单的过滤逻辑，可以根据需要扩展
      return !task.assigned_device_id || task.assigned_device_id === deviceId;
    });
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}