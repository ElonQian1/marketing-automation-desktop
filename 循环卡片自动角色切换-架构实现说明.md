# 循环卡片自动角色切换 - 架构实现说明

## 🏗️ 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    UI Layer (React Components)              │
├─────────────────────────────────────────────────────────────┤
│  DraggableStepsContainer  →  SmartStepCardWrapper         │
│           ↓                           ↓                    │
│  useLoopDragManager      →      useLoopTestManager         │
├─────────────────────────────────────────────────────────────┤
│                Application Layer (Hooks & Use Cases)        │
├─────────────────────────────────────────────────────────────┤
│  LoopPairingService  →  LoopRoleSwitchService              │
├─────────────────────────────────────────────────────────────┤
│                     Domain Layer (Pure Logic)              │
└─────────────────────────────────────────────────────────────┘
```

## 🎯 核心模块详解

### 1. useLoopDragManager（应用层 Hook）

**职责**：
- 🎯 拖拽后自动检测和切换角色
- 🚀 性能优化：防抖处理避免频繁更新  
- 🔍 实时配对状态查询
- ✅ 循环配对验证

**关键特性**：
```typescript
// 防抖优化 - 150ms 平衡响应性和性能
const debouncedCheckAndSwitch = useMemo(
  () => debounce(checkAndSwitchRoles, 150),
  [checkAndSwitchRoles]
);

// 指纹避重 - 防止重复处理相同状态
const currentFingerprint = allSteps.map(s => `${s.id}:${s.step_type}`).join('|');
if (currentFingerprint === lastProcessedStepsRef.current) {
  return; // 没有变化，跳过处理
}
```

**API 设计**：
- `checkAndSwitchRoles()` - 防抖版角色切换检查
- `getLoopPairs()` - 获取所有循环配对信息
- `needsRoleSwitch(stepId)` - 检查指定步骤是否需要切换
- `getPairStatus(stepId)` - 获取步骤的详细配对状态
- `validateAllPairs()` - 验证所有循环配对有效性

### 2. LoopPairingService（领域服务）

**职责**：循环配对匹配和验证

**核心算法**：
```typescript
// 基于 loop_id 的精确配对
const pairs = loopSteps.reduce((acc, step) => {
  const loopId = step.parameters?.loop_id as string;
  if (!loopId) return acc;
  
  if (!acc[loopId]) {
    acc[loopId] = { start: null, end: null };
  }
  
  if (step.step_type === 'loop_start') {
    acc[loopId].start = step;
  } else if (step.step_type === 'loop_end') {
    acc[loopId].end = step;
  }
  
  return acc;
}, {} as LoopPairMap);
```

**验证规则**：
- ✅ 每个 `loop_id` 必须有且仅有一个开始和一个结束
- ✅ 开始步骤必须在结束步骤之前
- ✅ 嵌套循环检测和验证

### 3. LoopRoleSwitchService（领域服务）

**职责**：基于位置的自动角色切换

**核心逻辑**：
```typescript
export const autoSwitchRoles = (steps: SmartScriptStep[]): RoleSwitchResult => {
  const pairs = LoopPairingService.findAllPairs(steps);
  const invalidPairs = pairs.filter(p => !p.isValid && p.needsSwap);
  
  if (invalidPairs.length === 0) {
    return { needsSwitch: false, updatedSteps: steps, switchedSteps: [] };
  }
  
  let updatedSteps = [...steps];
  const switchedSteps: string[] = [];
  
  invalidPairs.forEach(pair => {
    // 交换 step_type
    const startIndex = updatedSteps.findIndex(s => s.id === pair.startStep.id);
    const endIndex = updatedSteps.findIndex(s => s.id === pair.endStep.id);
    
    if (startIndex !== -1 && endIndex !== -1) {
      updatedSteps[startIndex] = { ...updatedSteps[startIndex], step_type: 'loop_end' };
      updatedSteps[endIndex] = { ...updatedSteps[endIndex], step_type: 'loop_start' };
      
      switchedSteps.push(pair.startStep.id, pair.endStep.id);
    }
  });
  
  return { needsSwitch: true, updatedSteps, switchedSteps };
};
```

## 🔄 数据流转过程

### 拖拽触发流程
```
1. 用户拖拽循环卡片 
   ↓
2. DraggableStepsContainer.handleDragEnd()
   ↓
3. onStepsChange(reordered) - 更新步骤顺序
   ↓  
4. setTimeout(() => loopDragManager.checkAndSwitchRoles(), 0)
   ↓
5. LoopRoleSwitchService.autoSwitchRoles(allSteps)
   ↓
6. 检测位置冲突 → 自动交换 step_type
   ↓
7. onStepsChange(updatedSteps) - 应用角色切换
   ↓
8. React 重渲染 → UI 更新完成
```

### 状态同步机制
```
SmartStepCardWrapper:
  ↓
useLoopTestManager → 循环执行状态（idle/running/completed/error）
  ↓
LoopStartCard/LoopEndCard → 显示对应的执行状态和控制按钮
```

## 🚀 性能优化策略

### 1. 防抖优化
```typescript
// 150ms 防抖 - 避免拖拽过程中频繁触发
const debouncedCheckAndSwitch = useMemo(
  () => debounce(checkAndSwitchRoles, 150),
  [checkAndSwitchRoles]
);
```

### 2. 指纹避重
```typescript
// 使用步骤指纹避免重复处理
const currentFingerprint = allSteps.map(s => `${s.id}:${s.step_type}`).join('|');
if (currentFingerprint === lastProcessedStepsRef.current) {
  return; // 状态未变化，跳过处理
}
```

### 3. 轻量级状态查询
```typescript
// 分离状态查询和状态更新
export const useLoopPairStatus = (allSteps: SmartScriptStep[]) => {
  return useMemo(() => {
    const pairs = LoopPairingService.findAllPairs(allSteps);
    const errors = LoopPairingService.validatePairs(allSteps);
    return { pairs, errors, hasErrors: errors.length > 0 };
  }, [allSteps]);
};
```

### 4. 异步处理
```typescript
// 使用 setTimeout 确保 React 状态更新完成后再处理
setTimeout(() => {
  loopDragManager.checkAndSwitchRoles();
}, 0);
```

## 🛠️ 扩展点设计

### 1. 配对状态可视化
```typescript
// 未来可以增加 UI 状态指示
interface PairStatusProps {
  hasPair: boolean;
  isValid: boolean;
  needsSwap: boolean;
  partnerStepId?: string;
  partnerPosition?: number;
}
```

### 2. 自定义验证规则
```typescript
// 支持自定义验证逻辑
interface ValidationRule {
  name: string;
  validate: (pairs: LoopPair[]) => string[];
}
```

### 3. 批量操作支持
```typescript
// 支持批量循环操作
interface BatchLoopOperation {
  operation: 'create' | 'delete' | 'switch';
  loopIds: string[];
  target?: 'all' | 'selected';
}
```

## 🔒 约束与限制

### 硬约束
1. **loop_id 唯一性**：每个循环必须有唯一的 `loop_id`
2. **配对完整性**：每个循环必须有开始和结束步骤
3. **位置逻辑性**：开始步骤必须在结束步骤之前

### 软约束  
1. **防抖时间**：150ms 可根据性能需求调整
2. **嵌套深度**：理论上无限制，但建议最多 3 层嵌套
3. **批量处理**：单次最多处理 100 个步骤

### 性能限制
1. **大数据集**：1000+ 步骤时可能需要优化算法
2. **频繁拖拽**：防抖机制可能导致轻微延迟
3. **内存使用**：每个循环状态占用约 1KB 内存

## 🧪 测试策略

### 单元测试
```typescript
describe('LoopRoleSwitchService', () => {
  it('should switch roles when end step is before start step', () => {
    const steps = [createLoopEnd(), createLoopStart()];
    const result = LoopRoleSwitchService.autoSwitchRoles(steps);
    expect(result.needsSwitch).toBe(true);
    expect(result.updatedSteps[0].step_type).toBe('loop_start');
    expect(result.updatedSteps[1].step_type).toBe('loop_end');
  });
});
```

### 集成测试  
```typescript
describe('useLoopDragManager', () => {
  it('should handle multiple loops independently', () => {
    const { result } = renderHook(() => useLoopDragManager({
      allSteps: [loopA_end, loopB_start, loopA_start, loopB_end],
      onStepsChange: mockOnChange
    }));
    
    act(() => {
      result.current.checkAndSwitchRoles();
    });
    
    expect(mockOnChange).toHaveBeenCalledWith(expectedReorderedSteps);
  });
});
```

### 端到端测试
```typescript
// Cypress/Playwright 测试
it('should auto-switch roles on drag', () => {
  cy.createLoop();
  cy.dragStepToPosition('[data-testid="loop-end"]', 0);
  cy.get('[data-testid="loop-start"]').should('be.visible');
  cy.get('[data-testid="loop-end"]').should('be.visible');
});
```

## 📈 监控指标

### 性能指标
- 🕐 **角色切换耗时**：< 50ms（目标）
- 🔄 **防抖生效率**：> 80%（减少不必要的处理）
- 💾 **内存使用**：每循环 < 1KB

### 功能指标  
- ✅ **自动切换成功率**：> 99%
- 🔍 **配对验证准确率**：100%
- 🚫 **错误率**：< 0.1%

### 用户体验指标
- 📱 **拖拽响应时间**：< 16ms（60fps）
- 🎯 **操作成功率**：> 95%
- 😊 **用户满意度**：预期 > 4.5/5

---

## 🎯 关键决策记录

### 决策 1：为什么选择防抖而不是节流？
**原因**：拖拽是突发性操作，用户期望在拖拽结束后立即看到结果，防抖确保在操作停止后快速响应。

### 决策 2：为什么使用指纹避重？
**原因**：React 的状态更新可能触发多次重渲染，指纹机制避免重复计算相同的步骤配置。

### 决策 3：为什么分离查询和更新 Hook？
**原因**：允许组件只查询状态而不触发更新，提升性能并避免不必要的副作用。

### 决策 4：为什么选择 setTimeout(0)？
**原因**：确保 React 的状态批量更新完成后再进行角色切换检查，避免基于过期状态的计算。

---

*该架构设计完全遵循项目的 DDD 分层约束和模块化规范，确保了代码的可维护性和可扩展性。*