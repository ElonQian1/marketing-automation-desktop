# 同构决策链插件化系统 - 实施指南

## 🎯 一句话总结

**前端静态分析生成Plan配方，后端按配方插件化执行，通过统一评分算法保证"想的"和"做的"完全一致。**

---

## 📋 快速检查清单（照做就行）

### Phase 1: 基础架构 ✅ 
- [x] **Plan契约**: `src-tauri/src/shared/plan_schema.json` (版本化JSON Schema)
- [x] **策略插件接口**: `strategy_plugin.rs` (统一StrategyExecutor trait)
- [x] **策略注册表**: 8个核心插件自动注册
- [x] **安全闸门**: `gating.rs` (唯一性双判+容器拦截+轻校验)
- [x] **XML索引器**: `xml_indexer.rs` (按id/class/text建桶，提升搜索效率)
- [x] **回退控制器**: `FallbackController` (按Plan顺序受控回退)

### Phase 2: 核心执行引擎 ✅
- [x] **统一评分**: `UnifiedScoringCore` (三态评分：匹配/缺失/不一致)
- [x] **执行环境**: `ExecutionEnvironment` (真机上下文封装)
- [x] **插件化入口**: `run_decision_chain_v2` (新的Tauri命令)
- [x] **完整数据流**: 从Plan解析到策略执行的全Pipeline

### Phase 3: 测试验证 ✅
- [x] **集成测试**: `decision_chain_test.rs` (覆盖关键组件)
- [x] **Plan样例**: 完整的RegionTextToParent示例
- [x] **健康检查**: `get_decision_chain_stats` 命令

---

## 🚀 如何使用新系统

### 1️⃣ 前端发送Plan（新格式）

```javascript
const planV2 = {
  version: "v2",
  strategy: {
    selected: "RegionTextToParent#1",
    allow_backend_fallback: true,
    time_budget_ms: 1200,
    per_candidate_budget_ms: 180,
    require_uniqueness: true,
    min_confidence: 0.7,
    forbid_containers: true
  },
  context: {
    package: "com.app",
    activity: "MainActivity", 
    screen: {width: 1080, height: 2400, dpi: 480, orientation: "portrait"},
    absolute_xpath: "/hierarchy/android.widget.FrameLayout[1]/...",
    xml_hash: "abc123...",
    container_anchor: {
      by: "id",
      value: "com.app:id/bottom_navigation"
    },
    clickable_parent_hint: {up_levels: 1}
  },
  child_anchors: [
    {
      anchor_type: "text",
      equals: "收藏",
      i18n_alias: ["Favorites", "Starred"]
    }
  ],
  plan: [
    {
      id: "RegionTextToParent#1",
      kind: "RegionTextToParent", 
      scope: "regional",
      selectors: {
        parent: {class: "android.widget.LinearLayout", clickable: true},
        child: {text: {in_list: ["收藏", "Favorites", "Starred"]}}
      },
      checks: [{check_type: "child_text_contains_any", values: ["收", "Fav"]}],
      static_score: 0.92,
      explain: "容器内子文本锚点→父执行"
    }
    // ... 更多备选策略按优先级排序
  ]
};

// 调用新的插件化接口
const result = await invoke('run_decision_chain_v2', {
  planJson: JSON.stringify(planV2)
});
```

### 2️⃣ 后端自动处理（插件化Pipeline）

```rust
// 系统自动执行以下步骤：

// 1. Plan解析+JSON Schema验证
let plan: DecisionChainPlan = serde_json::from_str(&plan_json)?;

// 2. 构建真机执行环境
let env = ExecutionEnvironment { ui_xml, package, activity, ... };

// 3. 获取策略注册表+XML索引
let registry = StrategyRegistry::new(); // 8个插件自动注册
let indexer = XmlIndexer::build_from_xml(&ui_xml)?;

// 4. 执行selected策略
let executor = registry.get_executor("RegionTextToParent")?;
let matches = executor.find_matches(&env, &selected_variant)?;

// 5. 安全闸门验证
let validated = SafetyGatekeeper::comprehensive_validation(&matches, &variant, 0.7, true)?;

// 6. 执行动作
let result = executor.execute_action(&validated, &variant)?;

// 7. 失败时按Plan自动回退
if !result.success && allow_fallback {
    FallbackController::execute_with_fallback(&env, &plan, &registry).await?;
}
```

---

## 🧩 如何新增策略插件

### 步骤1: 在Schema中声明新策略
```json
// plan_schema.json
"kind": {
  "enum": [
    "SelfId", "SelfDesc", "ChildToParent", "RegionTextToParent",
    "NewCustomStrategy"  // 👈 新增
  ]
}
```

### 步骤2: 实现Executor插件
```rust
// 新建 strategies/new_custom_strategy.rs
pub struct NewCustomStrategyExecutor;

impl StrategyExecutor for NewCustomStrategyExecutor {
    fn name(&self) -> &'static str { "NewCustomStrategy" }
    
    fn can_execute(&self, variant: &StrategyVariant) -> bool {
        matches!(variant.kind, VariantKind::NewCustomStrategy)
    }
    
    fn find_matches(&self, env: &ExecutionEnvironment, variant: &StrategyVariant) -> Result<MatchSet> {
        // 实现自定义匹配逻辑
    }
    
    fn score_match(&self, evidence: &StaticEvidence, candidate: &UIElement) -> f32 {
        // 使用统一评分引擎
        UnifiedScoringCore::calculate_tristate_score(evidence, candidate)
    }
    
    fn execute_action(&self, target: &MatchCandidate, variant: &StrategyVariant) -> Result<ExecutionResult> {
        // 实现自定义执行逻辑
    }
}
```

### 步骤3: 注册到注册表
```rust
// strategy_plugin.rs
fn register_builtin_strategies(&mut self) {
    // ... 现有策略
    self.register(Box::new(NewCustomStrategyExecutor)); // 👈 新增
}
```

---

## 🛡️ 安全与性能保障

### 三重安全闸门
1. **唯一性双判**: 阈值唯一(confidence≥0.7且count=1) OR 间隔唯一(Top1-Top2≥0.15)
2. **容器拦截**: 自动拒绝整屏/容器类节点
3. **轻校验**: 命中后再确认clickable/enabled/子树文本

### 性能优化
- **XML索引**: 按resource-id/class/text建桶，O(1)查找
- **容器限定**: 优先在容器内搜索，减少搜索面
- **时间预算**: 总预算1200ms，单策略180ms，超时自动回退
- **智能回退**: 失败时按Plan顺序快速尝试，避免全量重试

### 可观测性
```json
// 返回结构化日志
{
  "success": true,
  "used_variant": "RegionTextToParent#1", 
  "match_count": 3,
  "final_confidence": 0.87,
  "execution_time_ms": 156,
  "tap_coordinates": [200, 225],
  "fallback_chain": ["SelfId:FAILED:NoMatch"],
  "telemetry": {
    "xml_hash": "abc123...",
    "strategy_count": 5,
    "registry_plugins": 8
  }
}
```

---

## 🔧 开发与调试

### 本地测试
```bash
# 运行决策链测试
cd src-tauri
cargo test decision_chain_test --nocapture

# 检查系统健康状态  
curl -X POST http://localhost:1420 \
  -H "Content-Type: application/json" \
  -d '{"cmd": "get_decision_chain_stats"}'
```

### 调试技巧
1. **开启详细日志**: `RUST_LOG=debug cargo run`
2. **Plan验证**: 使用JSON Schema在线验证器检查Plan格式
3. **单策略测试**: 临时设置`allow_backend_fallback: false`只测试selected
4. **XML检查**: 保存ui_xml到文件，人工检查节点结构

### 常见问题
- **"未找到策略执行器"**: 检查VariantKind枚举是否匹配插件名称
- **"安全闸门拒绝"**: 检查置信度阈值和唯一性条件
- **"XML索引构建失败"**: 检查XML格式，确保bounds属性正确

---

## 📊 迁移路线图

### Week 1: 基础验证
- [x] ✅ 部署插件化系统
- [ ] 🔄 前端适配新的Plan格式
- [ ] 🔄 选择3-5个典型场景做A/B测试

### Week 2: 策略完善  
- [ ] 📋 实现RegionTextToParent完整版
- [ ] 📋 实现ChildToParent插件
- [ ] 📋 实现RegionLocalIndexWithCheck插件

### Week 3: 全量切换
- [ ] 📋 所有策略插件就绪
- [ ] 📋 性能对比（新系统 vs 旧系统）
- [ ] 📋 灰度切换到新系统

### Week 4: 监控优化
- [ ] 📋 生产监控Dashboard
- [ ] 📋 失败分析和策略调优
- [ ] 📋 团队培训和文档完善

---

## 🎉 成功指标

### 技术指标
- **一致性**: 前后端评分偏差 < 5%
- **性能**: 平均执行时间 ≤ 200ms
- **稳定性**: 成功率 ≥ 95%  
- **可维护性**: 新策略开发时间 ≤ 2天

### 业务价值
- **开发效率**: 步骤卡片创建时间减少 60%
- **维护成本**: 多语言适配工作量减少 80%
- **故障率**: UI自动化故障减少 70%
- **团队效能**: 问题定位时间减少 50%

---

## 💡 关键设计亮点

1. **同构性**: 前后端使用完全相同的评分算法和决策逻辑
2. **可插拔**: 新策略像装插件一样简单，无需修改核心引擎
3. **可演进**: 通过版本化契约支持平滑升级
4. **高性能**: XML索引+容器限定+时间预算多重优化
5. **可观测**: 结构化日志+失败分类+执行链路追踪
6. **工程化**: JSON Schema验证+自动化测试+健康检查

这套系统让"静态分析如何想"与"真机如何做"**完全对齐**，是真正工程化的同构决策链实现！ 🚀