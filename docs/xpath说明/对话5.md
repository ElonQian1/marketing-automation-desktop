前端做“离线评估+可视化”，后端做“真机校验+执行”

前端都评估好了， 后端真机执行 是不是能直接采用 评估/手动选择 的最佳方式， 然后让 后端直接执行 这个 最佳匹配方式？

短答：**可以。**
后端完全可以“直接执行前端评估/手动选择出的**最佳策略**”。但为了**真机环境的不确定性**（界面刷新/语言/弹窗/排序变化等），建议在执行前加一个**极轻量的校验闸门**，并按需开启**受控回退**。这样既快，又不至于在界面轻微变化时直接失败。

下面把流程和契约整理成给开发同学看的“执行规范版”。

---

# 1) 快路径总原则（后端）

**快 = 只做 3 件事：Dump → 校验 → 执行。**

1. **Dump**：真机拉取最新 XML（记录 `dump_time_ms`、`dump_hash`、Activity/分辨率）。
2. **校验（轻）**：在**真机 XML**上，用前端选中的 `strategy.selected` 做一次**唯一性=1**匹配 + 轻校验（如 `clickable/enabled`、子树含“关键词”）。
3. **执行**：命中即点击/输入（必要时 `scrollIntoView`），返回坐标、bounds、截图与耗时。

> 若你只追求速度，可设置 `strict_mode=true`：**不回退**，命不中就立刻返回失败。
> 若要稳一些，允许**受控回退**（见第 4 节）。

---

# 2) 前后端“契约”字段（关键）

前端在 StepCard 里除了“三要素”外，建议携带这些控制参数，让后端**按你的偏好**执行：

* `strategy.selected`：当前要**直接执行**的最佳策略（必填）。
* `plan[]`：候选链（可选，用于后端回退时的顺序与解释）。
* `allow_backend_fallback: true|false`：是否允许后端自动按 `plan` 回退（默认 `true` 建议）。
* `time_budget_ms`：本次查找总预算（如 1200ms）；
  `per_candidate_budget_ms`：单候选预算（如 150–250ms）。
* `strict_mode: true|false`：严格模式（`true` 则只试 `selected`，不中即失败）。
* `assertions`：点击前/后轻断言（如“子树必须含‘收藏’”或“选中态切换为 true”）。
* `i18n_alias`：文本同义集合（如“收藏|Favorites|Starred|书签”）。
* `xml_hash` & `node_fingerprint`：用于**快诊断**“缓存 vs 真机”的差异。

> **结论**：**只要 `strategy.selected` 在，后端就能直奔快路径**；其余字段帮助“快诊断、快回退、快复盘”。

---

# 3) 后端“直接执行最佳策略”的标准流程（无代码版）

1. **接收 StepCard**
   读取：`strategy.selected`、`allow_backend_fallback`、预算、断言、i18n 等。

2. **Dump 真机 XML**
   记录：`dump_time_ms / dump_hash / activity / resolution`。

3. **快速一致性体检（≤ 1ms 级别哈希/存在性检查）**

   * 若提供了容器锚点（如 `bottom_navgation`），先判**容器存在**；
   * `xml_hash` 仅用于提示**“页面或语言可能有变”**（不阻断执行）。

4. **编译/执行 `strategy.selected`（快路径）**

   * **等值与区域限定**优先（`id/desc`、容器内查询）；
   * 文本匹配走 `i18n_alias` 集合（避免多次正则）；
   * 命中集合排序（稳定：`bounds.y → bounds.x`）；
   * **唯一性=1 且轻校验通过** → 进入步骤 5。

5. **动作前轻校验**

   * 目标 `clickable=true && enabled=true`；
   * 若不可见且容器可滚，做一次 `scrollIntoView`（有方向与步数上限）；
   * 可选：截一张小图用于审计。

6. **执行动作**

   * 点击/长按/输入等；
   * 可选：执行后做**后置断言**（如选中态变化、页面标题变化）。

7. **返回结果**

   * 成功：`used_variant`（本次真机实际用到哪条策略）、命中 XPath/UISelector、坐标、bounds、截图、耗时分解（dump/匹配/点击）。
   * 失败（仅当 `strict_mode=true` 或预算耗尽）：逐项失败原因（匹配数=0/>1、断言失败、滚动失败等）。

---

# 4) 何时建议“允许回退”？（稳中求快的配置）

现实里，**离线最佳 ≠ 在线最佳** 的几种常见原因：

* 页面刷新/异步加载顺序变化；
* A/B 文案或系统语言不同（中文 → 英文）；
* 厂商 UI 在真机与模拟器 dump 结构不一致；
* 弹窗/权限对话框覆盖；
* 列表插入广告位，**索引位移**；
* DPI/分辨率导致**布局换行**或控件合并/拆分。

**推荐默认**：`allow_backend_fallback=true`，并设置一个**小预算**（例如总 1200ms，单候选 150–200ms，最多尝试 3–4 个候选）。
**回退顺序（建议）**：
`SelfId/SelfDesc → Region + TextToParent → Region + LocalIndex + Check → NeighborRelative → GlobalIndex + StrongChecks（最后关卡）`

> 这样做的效果是：**大多数情况下仍然是一跳命中**；少数有漂移时，后端能在**毫秒级**退到第二候选继续命中，而不需要人介入。

---

# 5) 错误处理与可观测性（让问题“定位更快”）

* **错误类型**：`NO_MATCH`、`MULTI_MATCH`、`VISIBILITY_FAIL`、`ASSERT_FAIL`、`SCROLL_FAIL`、`TIMEOUT`。
* **日志最小集**：

  * `used_variant / try_count / time_ms_each`
  * `match_count`（每次匹配的数量）
  * 断言结果与失败原因
  * 差异摘要：容器是否存在、文本是否改、bounds 排序是否变化
* **返回建议**：发生失败时，把“**下一步推荐**”一并返回（例如：请开启回退 / 调整文本别名 / 改用区域限定）。

---

# 6) 推荐默认配置（开箱即用）

* `strict_mode=false`（默认允许回退）
* `allow_backend_fallback=true`
* `time_budget_ms=1200`，`per_candidate_budget_ms=180`，`max_candidates=4`
* **快路径**优先级：`id/desc/区域限定` > `区域文本锚点` > `局部索引+校验` > `邻居相对` > `全局索引+强校验（几乎不用）`
* **唯一性硬标准**：必须 `== 1` 才能执行动作

---

## 结论

* **是的**：后端可以直接采用前端评估/手选出的**最佳策略**进行真机执行；
* 为了应对线上轻微漂移，建议在执行前做**极轻校验**，并**小预算开启回退**（可通过 `strict_mode/allow_backend_fallback/time_budget_ms` 精确控制）；
* 这样你的系统能在“**速度优先**”与“**稳定命中**”之间取得最佳平衡，而且所有决定都有**可审计日志**支撑。
