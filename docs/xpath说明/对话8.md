我要做的是在 前端react+rust后端， 进行协作， 
 我在前端 把一个 缓存的XML 进行可视化分析，
在可视化视图上点选 元素， 会弹出 “确定”、“元素分析”等按钮
我直接点击 “确定”按钮
会生成一个步骤卡片，

步骤卡片 记录三大要素
1、记录原始XML快照
2、记录绝对的全局Xpath
3、记录选择的 适配/匹配策略

现在 我已经写了一些自定义的匹配策略， 如全局全局xpath索引 策略

我需要新增一个模块， 就是智能识别匹配策略。
原本我点选元素以后， 默认采用 全局xpath索引的 匹配策略。

现在我想 当我点选以后， 
算法会自动分析，
按照你上一个回答， 
评价 一个决策，
采用
 Step 0｜规范化输入 还是 
Step 1｜自我可定位性检查（Self-Anchor）
直到 最后step  全局索引兜底，
考虑到 子节点也没有依据时，优先“局部索引”

根据 算法评价
我在 步骤卡片 手动切换策略的按钮，  会看到  当前算法推荐的
step N  策略，
我可以来回在手动策略 以及算法推荐策略中 切换。
根据步骤卡片的三要素， 生成对应的  策略方法， 告知rust后端

当rust收到 一个个步骤卡片的时候， 首先会真机dump xml文件， 然后通过 步骤卡片 所选择的策略方法，进行适配， 比如 Step 2｜子树找锚点（Child-Driven）

然后后端就 按照 策略方法 执行 ，对真机进行 查找匹配。

请你跟好我说好整个流程。 我基本框架已经有了， 有一些静态选择方案了， 现在缺少  智能识别匹配策略 这一个模块。
不要先给代码， 先说好 整个程序架构

我这段话应该如何清晰简单的重构一下呢？ 让它清晰准确简单，适合开发人员看

下面是把你那段需求**重写为“给开发看的 1 页式说明”**——清晰、准确、简洁，无代码。

---

# 目标与范围

* **目标**：前端在缓存 XML 上**离线评估并推荐匹配策略**；用户点“确定”后生成**步骤卡片**。后端收到卡片，在真机上**校验并执行**（可选回退）。
* **范围**：新增“**智能识别匹配策略**”模块；保持原有“静态策略（全局 XPath 索引等）”兼容。

---

# 角色分工

* **前端（React）**：

  1. 可视化 XML；用户点选元素后点击「确定」。
  2. 本地**离线评估**生成**候选策略清单（Plan）**并给出**推荐**。
  3. 生成**步骤卡片 StepCard**（三要素 + 选中策略 + Plan 等扩展字段）并发到后端。
* **后端（Rust）**：

  1. 立即 **dump 真机 XML**。
  2. 按卡片所选策略**快速匹配**；若允许，按 Plan **小预算回退**。
  3. 命中则执行（点击/输入），返回结果与日志。

---

# 核心数据对象（对内约定）

* **StepCard（三要素必有）**

  1. `xml_snapshot`：原始 XML 快照
  2. `absolute_xpath`：绝对全局 XPath
  3. `strategy.selected`：本次要执行的**匹配策略**
     **建议附带**：`plan`（候选链+推荐索引）、`i18n_alias`（文本同义词）、`assertions`（轻校验）、`allow_backend_fallback`、`time_budget_ms`。
* **StrategyPlan（候选链）**

  * 多条候选策略（已**排序与打分**），每条含：`kind`、`scope`（global/regional）、`selectors`（id/desc/text…）、`structure`（父子/兄弟）、`index`（局部/全局）、`checks`（轻校验）、`score`、`explain`。

---

# 前端流程（点击“确定”即建卡）

1. **点选元素 N → 点击「确定」**。
2. 本地**离线评估**（对缓存 XML 干跑）：生成 **Plan** 并选出**推荐策略**。
3. 形成 **StepCard**：三要素 + `strategy.selected=推荐策略` + `plan` + 可选配置（回退/预算/同义词）。
4. 把 StepCard 发往后端；UI 上可**手动切换**策略并重发。

---

# 智能识别匹配策略：决策流（通用）

> 目标：从强到弱挑策略；能**一跳命中**就不回退；不行再退一步。

* **Step 0 规范化输入**：抽取点选节点属性（id/desc/text/class/clickable…）、最近可点父 P、稳定容器祖先 A（如 `bottom_navigation`）、子树潜在锚点、同级兄弟；准备多语言同义词（如“收藏|Favorites|Starred”）。
* **Step 1 自我可定位（Self-Anchor）**：
  `id`/`content-desc` 唯一 → 直接用（最快）；否则进下一步。
* **Step 2 子树找锚点（Child-Driven）**：
  在 N/P 子树里找稳定文本/图标锚点，**上溯到可点击父**。
* **Step 3 区域限定（Region-Scoped）**：
  先锁容器 A，再在 A 内找“**文本锚点 → 可点父**”（常为最佳）；如仍不稳 → A 内**局部索引 + 轻校验**（优先于全局索引）。
* **Step 4 邻居相对（Neighbor-Relative）**：
  用已稳命中的同级兄弟为参照，取前/后一个。
* **Step 5 索引兜底（Index Fallback）**：
  **优先局部索引**（容器/父内 `[n]`）+ 校验；**最后才全局索引** + 强校验（不推荐）。

> 每条候选都在本地验证“**唯一命中=1**”，打分排序，选**最高分且唯一**者为**推荐**。

---

# 后端流程（真机：快路径 + 受控回退）

1. **Dump** 真机 XML（记录耗时/分辨率/Activity）。
2. **快路径执行 `strategy.selected`**：

   * 等值优先（`id/desc/text`），**区域优先**（A 内检索），**局部索引要带轻校验**；
   * 要求**唯一命中=1**。命中即执行动作，返回结果。
3. **受控回退（可选）**：

   * 若允许回退且未命中：按 **Plan 顺序**，给每条候选**小时间片**（如 150–200ms）快速尝试；
   * 顺序建议：文本锚点→局部索引+校验→邻居相对→（最后）全局索引+强校验。
4. **返回**：成功（用到的策略/坐标/bounds/截图/耗时）或失败（每条候选的匹配数与原因）。

---

# 为什么这样做（设计取舍一句话）

* **速度**靠：属性等值、区域限定、局部索引 + 轻校验（命中即返回）。
* **稳健**靠：从强到弱的决策流 + 小预算回退链（毫秒级自救）。
* **可维护**靠：策略标准化（StrategyPlan/StepCard），前后端共用、可审计、易扩展。

---

# UI 与配置最小要求

* 卡片上显示：**“算法推荐：Step N（说明）”**；支持一键切换到其它候选。
* 可配置：`allow_backend_fallback`、`time_budget_ms`、`per_candidate_budget_ms`、`strict_mode`（只跑选中、不回退）。
* 失败提示包含：各候选匹配数/失败原因，方便改策略或重录。

---

# 验收标准（Done 的定义）

* 点“确定”即可生成**含推荐策略**的 StepCard，并能发送到后端。
* 在典型场景（如底部导航“电话/联系人/收藏”）：

  * **首选策略**在真机上**一跳命中率高**；
  * 轻微变化（文案/顺序微调）下，**回退链**在**预算内自动命中**。
* 日志可见：dump/匹配/点击耗时、各候选匹配数、最终选用策略与原因。

---

> 这份就是“清晰准确简单”的开发说明：按此实现即能把**智能识别模块**接入你现有的“步骤卡片 → 后端执行”框架，既快又稳。
