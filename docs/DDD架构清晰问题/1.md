太好了！下面给你一整套**“看得见、管得住”**的落地方案：做完后，**只看文件路径/文件头3行注释**，就能知道“这个文件属于哪个业务模块、哪一层、负责什么角色”。并且通过 ESLint/依赖巡航/提交钩子把“越层、跨模块乱导入”直接卡死，杜绝歧义。

---

# 总体思路（3件事就够）

1. **路径即边界**：所有业务代码进 `src/modules/<业务名>/...`，模块内再分 `domain/application/services/api/stores/hooks/ui`。
2. **文件头注释统一模板**：每个文件最前面 3 行写清楚 `路径/模块/分层/角色/摘要`。
3. **公共出口 + 规则强约束**：模块只从 `src/modules/<m>/index.ts` 暴露给外部；ESLint + dependency-cruiser + Git hooks 强化边界。

---

# 一次性配置（复制即可）

## 1) 约定好的文件头注释模板（务必所有代码统一）

> 你有“代码第一行写文件名路径”的习惯，我们在此基础上升级：三行头注释统一、可机审。

```ts
// src/modules/contact-import/application/ImportFromTxtUseCase.ts
// module: contact-import | layer: application | role: usecase
// summary: 从TXT读取号码→去重→入库→生成VCF→产出导入任务（纯编排，不含UI）

// ... 下面是你的实现 ...
```

* `module`: 业务模块名（adb / contact-import / prospecting / script-builder …）
* `layer`: 允许值（ui | hooks | application | domain | services | api | stores | pages）
* `role`: usecase / entity / value / repository / service / api-facade / store / component / page / hook 等
* `summary`: 1 句中文描述

---

## 2) 模块目录骨架（四个核心模块的标准形态）

以 **contact-import** 为例，其它模块同理（adb / prospecting / script-builder）：

```
src/modules/contact-import/
├── api/            # 仅封装 Tauri/HTTP 的“门面函数”
├── application/    # 用例编排（调用 domain + services + api）
├── domain/         # 纯模型/规则/仓储接口（不依赖UI/Tauri/浏览器）
├── services/       # 前端侧适配/编排（少量IO），聚合多个 api 调用
├── stores/         # 仅该模块的状态
├── hooks/          # 该模块的 React hooks（UI胶水）
├── ui/             # 组件（components）与模块内页面（pages，可选）
├── index.ts        # 模块“公共出口”：只导出允许被外部使用的内容
└── README.md       # 模块说明（见下文模板）
```

---

## 3) index.ts（公共出口）示例

```ts
// src/modules/contact-import/index.ts
// module: contact-import | layer: public | role: barrel
// summary: 对外公开的最小 API 面（usecases + hooks + 轻量类型）

export * from './application/ImportFromTxtUseCase';
export * from './application/PushVcfToDeviceUseCase';
export * from './hooks/useContactImportWizard';
export type { Contact } from './domain/Contact.entity';
```

> 规则：**其他模块引用 contact-import，只能从这里 import**。内部细节（如具体组件、内部服务）不允许跨模块直接 import。

---

## 4) TypeScript 路径别名（强引导“从出口导入”）

```json
// tsconfig.json（片段）
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@adb/*": ["src/modules/adb/*"],
      "@contact/*": ["src/modules/contact-import/*"],
      "@prospecting/*": ["src/modules/prospecting/*"],
      "@script/*": ["src/modules/script-builder/*"],
      "@shared/*": ["src/shared/*"]
    }
  }
}
```

> 建议：**只允许从 `@<module>/index` 导入**（见 ESLint 限制）。

---

## 5) ESLint 边界规则（禁止越层与“捅内部”导入）

```js
// .eslintrc.cjs
// module: root | layer: config | role: eslint
// summary: 限制层间依赖/跨模块导入，只从模块 index.ts 暴露的公共 API 引用

module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint', 'boundaries', 'import'],
  extends: ['eslint:recommended', 'plugin:@typescript-eslint/recommended'],
  settings: {
    'boundaries/elements': [
      { type: 'pages',       pattern: 'src/pages/**' },
      { type: 'modules',     pattern: 'src/modules/*' },
      { type: 'ui',          pattern: 'src/modules/*/ui/**' },
      { type: 'hooks',       pattern: 'src/modules/*/hooks/**' },
      { type: 'application', pattern: 'src/modules/*/application/**' },
      { type: 'domain',      pattern: 'src/modules/*/domain/**' },
      { type: 'services',    pattern: 'src/modules/*/services/**' },
      { type: 'api',         pattern: 'src/modules/*/api/**' },
      { type: 'stores',      pattern: 'src/modules/*/stores/**' }
    ]
  },
  rules: {
    // 1) 分层访问控制
    'boundaries/element-types': [2, {
      default: 'disallow',
      rules: [
        { from: 'pages',       allow: ['ui', 'hooks', 'application', 'stores'] },
        { from: 'ui',          allow: ['hooks', 'application', 'stores', 'domain'] },
        { from: 'hooks',       allow: ['application', 'stores', 'domain'] },
        { from: 'application', allow: ['domain', 'services', 'api', 'stores'] },
        { from: 'services',    allow: ['api', 'domain'] },
        { from: 'api',         allow: [] },
        { from: 'domain',      allow: [] },
        { from: 'stores',      allow: ['domain', 'application'] }
      ]
    }],
    'boundaries/no-unknown': 2,

    // 2) 只允许从模块 index.ts 暴露的公共 API 引用（禁止“捅内部路径”）
    'no-restricted-imports': ['error', {
      patterns: [
        {
          group: [
            'src/modules/*/*',           // 任何直捣模块内部子目录
            '@*/!(index|public)*'        // 任何别名下非 index/public 的深层
          ],
          message: '请从模块根 index.ts 导入（公共API），不要直捣内部实现。'
        }
      ]
    }]
  }
};
```

---

## 6) 依赖巡航（dependency-cruiser）再上“保险锁”

> 作用：可视化依赖&再次卡掉“跨模块内脏路径”。

```js
// .dependency-cruiser.cjs
// module: root | layer: config | role: depcruise
// summary: 禁止 domain 依赖 UI/IO，禁止跨模块引用对方内部实现

module.exports = {
  forbidden: [
    // (A) domain 不得依赖 ui/services/api/hooks/pages
    {
      name: 'no-ui-from-domain',
      severity: 'error',
      from: { path: '^src/modules/[^/]+/domain' },
      to:   { path: '^src/modules/[^/]+/(ui|services|api|hooks|pages)' }
    },
    // (B) application 不得依赖 ui
    {
      name: 'no-ui-from-application',
      severity: 'error',
      from: { path: '^src/modules/[^/]+/application' },
      to:   { path: '^src/modules/[^/]+/ui' }
    },
    // (C) 跨模块只能用对方 index.ts
    {
      name: 'no-cross-internals',
      severity: 'error',
      from: { path: '^src/modules/([^/]+)/' },
      to:   {
        path: '^src/modules/((?!\\1)[^/]+)/((?!index\\.ts$).+)$' // 非同模块且非 index.ts
      }
    }
  ],
  options: {
    doNotFollow: { path: 'node_modules' },
    tsConfig: { fileName: 'tsconfig.json' },
  }
};
```

---

## 7) 提交钩子（Husky + lint-staged + 自定义“文件头检查器”）

**package.json** 脚本片段：

```json
// package.json（片段）
// module: root | layer: config | role: npm-scripts
// summary: 统一的代码质量与边界检查命令

{
  "scripts": {
    "prepare": "husky install",
    "lint": "eslint --ext .ts,.tsx src",
    "dep:check": "depcruise --config .dependency-cruiser.cjs src --exclude '^src-tauri'",
    "headers:check": "node scripts/check_headers.js"
  },
  "lint-staged": {
    "src/**/*.{ts,tsx}": [
      "eslint --fix",
      "node scripts/check_headers.js"
    ]
  }
}
```

**安装依赖（示例）**：

```
pnpm add -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-boundaries dependency-cruiser husky lint-staged
```

**pre-commit**：

```bash
# .husky/pre-commit
# module: root | layer: config | role: git-hook
# summary: 提交前自动检查 ESLint/文件头/依赖边界
pnpm lint && pnpm headers:check && pnpm dep:check
```

**文件头检查脚本（可直接用）**：

```js
// scripts/check_headers.js
// module: root | layer: tooling | role: header-checker
// summary: 扫描 src 下 ts/tsx，强制三行文件头注释齐全且与真实路径一致

const fs = require('fs');
const path = require('path');

const root = path.resolve(__dirname, '..', 'src');

const HEADER_RE = /^\/\/\s*(?<path>src\/[^\n]+)\n\/\/\s*module:\s*(?<module>[\w-]+)\s*\|\s*layer:\s*(?<layer>[\w-]+)\s*\|\s*role:\s*(?<role>[^\n]+)\n\/\/\s*summary:\s*(?<summary>.+)\n/;

function walk(dir) {
  return fs.readdirSync(dir, { withFileTypes: true }).flatMap((ent) => {
    const p = path.join(dir, ent.name);
    if (ent.isDirectory()) return walk(p);
    if (/\.(ts|tsx)$/.test(ent.name)) return [p];
    return [];
  });
}

const files = walk(root);
let bad = 0;

for (const abs of files) {
  const rel = path.relative(path.resolve(__dirname, '..'), abs).replace(/\\/g, '/'); // win 兼容
  const content = fs.readFileSync(abs, 'utf8');

  const m = content.match(HEADER_RE);
  if (!m) {
    console.error(`✗ 缺少或不规范的文件头: ${rel}`);
    bad++;
    continue;
  }
  const declaredPath = m.groups.path.trim();
  if (declaredPath !== rel) {
    console.error(`✗ 文件头路径不匹配: 头=${declaredPath} 实际=${rel}`);
    bad++;
  }
}

if (bad > 0) {
  console.error(`\n共 ${bad} 处文件头问题，请修复后再提交。`);
  process.exit(1);
} else {
  console.log(`✓ 文件头检查通过（${files.length} 个文件）`);
}
```

---

## 8) 模块 README 模板（每个模块 1 份）

````md
<!-- src/modules/contact-import/README.md -->
# Contact Import（联系人导入）

## 本模块做什么
- TXT/CSV → 去重 → 入库 → 生成 VCF → 设备下发

## 目录速览
- **domain/** 纯模型与规则（无 UI/IO）
- **application/** 用例编排（ImportFromTxtUseCase/PushVcfToDeviceUseCase）
- **services/** 前端适配器（VcfBuildService、ContactNumberService）
- **api/** Tauri/HTTP 门面（contact.api.ts）
- **stores/** 模块状态（useContactImportStore）
- **hooks/** UI胶水（useContactImportWizard）
- **ui/** 组件与子页面（batch-manager 等）
- **index.ts** 公共出口（只导出对外 API）

## 对外公共API（从 index.ts 导入）
```ts
import { ImportFromTxtUseCase, useContactImportWizard } from '@contact';
````

## 不该跨模块引用的内部实现

* ui/components/*
* services/*
* api/*

```

---

# 日常使用方法（你团队只记这5条）

1. **新功能 → 先选模块**（adb / contact-import / prospecting / script-builder），在该模块内找对层目录：  
   - 业务规则 → `domain`  
   - 用例编排 → `application`  
   - 适配/聚合 IO → `services`  
   - Tauri/HTTP → `api`  
   - UI/组件/页面 → `ui` / `pages`  
   - React 状态/Hook → `stores` / `hooks`  
2. **每个新文件**：先粘贴 3 行头注释（路径/模块/层/角色/摘要），再写代码。  
3. **跨模块使用**：只从对方 `index.ts` 导出使用。  
4. **提交前**：自动跑 `eslint + headers:check + dep:check`，违规会被阻止。  
5. **阅读他人代码**：看文件头的 `module/layer/role/summary` 和所在路径，一眼明白。

---

# 给你的四个模块的一句话落位检查表

- **ADB**：  
  - 匹配策略规则 → `adb/domain/MatchStrategy.value.ts`  
  - 截图/抓XML/输入注入调用门面 → `adb/api/adb.api.ts`  
  - 组合多步 ADB 操作（前端侧）→ `adb/services/AdbDeviceService.ts`  
  - “选元素并匹配”的用例编排 → `adb/application/MatchElementUseCase.ts`  
  - 设备列表状态 → `adb/stores/useAdbStore.ts`

- **联系人导入**：  
  - `Contact/Batch/Session` 模型与去重规则 → `contact-import/domain/*`  
  - 导入用例（TXT→去重→VCF→下发）→ `contact-import/application/*`  
  - 生成 VCF 的具体实现 → `contact-import/services/VcfBuildService.ts`  
  - Tauri 命令门面（update/revert）→ `contact-import/api/contact.api.ts`  
  - 批次/会话的 UI 页面与组件 → `contact-import/ui/*`

- **精准获客**：  
  - 候选客户、来源、采集任务模型 → `prospecting/domain/*`  
  - 三轨编排（API/巨量/爬虫）→ `prospecting/application/BuildLeadPoolUseCase.ts`  
  - 平台/爬虫适配器 → `prospecting/services/*` + `prospecting/api/*`

- **智能脚本构建器**：  
  - `Script/Step/SelectorStrategy` → `script-builder/domain/*`  
  - 生成/运行/批量执行用例 → `script-builder/application/*`  
  - 决策流与执行器适配 → `script-builder/services/*`  
  - 步骤卡片 UI → `script-builder/ui/components/StepCard.tsx`

---

# 最后：一次性“落地清单”（按顺序做，半天能完成）

1. 建好四个模块的目录骨架与 `index.ts` + `README.md`。  
2. 把已有代码迁入对应模块与层（先 UI/服务/hooks/stores，风险最低）。  
3. 全仓批量加 3 行文件头（路径/模块/层/角色/摘要）。  
4. 加上 **tsconfig 路径别名**、**ESLint**、**dependency-cruiser**、**husky**、**header-checker** 脚本。  
5. 跑一遍 `pnpm lint && pnpm headers:check && pnpm dep:check`，修掉报错。  
6. 把跨模块导入改成只从 `index.ts` 导入。  
7. 在 `docs/architecture/` 写一页总览（可画个简单目录图和“谁可以依赖谁”的表）。  
8. 通知团队：**文件一创建就先填头注释**，不然提交流水线不会放行。

---

如果你愿意，我可以**读取你仓库当前文件清单**，给出一份“from → to 的迁移对照表”，以及把上面这些配置文件与脚本**按你的实际模块名**替换好，直接贴进项目就能用。你只需要说一句“开始迁移清单”，我就一次性给到。
::contentReference[oaicite:0]{index=0}
```
