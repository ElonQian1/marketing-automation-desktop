# 执行锁竞态条件修复方案

## 🔍 问题现象

```
执行消息: V3执行失败: 重复执行请求被阻止: analysis_id 'step_execution_xxx' 正在执行中
```

**特征**：
- 出现在程序初始化/第一次运行时
- 明显不是真正的重复点击
- analysis_id 显示"正在执行中"但实际上可能没有在执行

## 🎯 根本原因

### 1. 后端锁定逻辑缺陷

在 `chain_engine.rs` 的 `execute_chain_by_inline` 函数中：

```rust
// ❌ 问题代码
if let Some(intelligent_steps) = check_and_trigger_early_analysis(...).await? {
    execution_tracker::unlock(analysis_id)?;  // 只有进入这个分支才 unlock
    return execute_chain_by_inline(...).await;
}

// 🚨 如果上面没有进入分支，这里会尝试锁定已锁定的 ID
if !execution_tracker::try_lock(analysis_id)? {
    return Err("重复执行请求被阻止...");
}
```

**问题流程**：
1. 函数开始时没有 lock
2. `check_and_trigger_early_analysis` 可能内部执行了某些操作
3. 如果不返回 `Some`，不会 unlock（实际上也没 lock）
4. 继续执行到 `try_lock`，但可能：
   - 递归调用时已经 lock 过
   - 某个异步操作导致的竞态条件

### 2. 递归调用时的重复锁定

```rust
return execute_chain_by_inline(
    app, envelope, analysis_id, &intelligent_steps,  // 使用相同的 analysis_id
    threshold, mode, quality, constraints, validation
).await;
```

递归调用时使用相同的 `analysis_id`，会再次尝试锁定。

## ✅ 解决方案

### 方案 A：统一锁定位置（推荐）

**思路**：在函数入口处统一锁定，出口处统一释放。

```rust
pub async fn execute_chain_by_inline<'a>(
    app: &AppHandle,
    envelope: &ProtocolEnvelope,
    analysis_id: &str,
    ordered_steps: &'a [OrderedStep],
    threshold: f64,
    mode: ExecutionMode,
    quality: AnalysisQuality,
    constraints: Option<Constraints>,
    validation: bool,
) -> Result<ChainExecutionResult, String> {
    Box::pin(async move {
    let start_time = Instant::now();
    let device_id = &envelope.device_id;
    
    // 🔒 【统一锁定】在函数入口处检查并锁定
    if !execution_tracker::try_lock(analysis_id)? {
        return Err(format!("重复执行请求被阻止: analysis_id '{}' 正在执行中", analysis_id));
    }
    
    // 🛡️ 确保函数退出时一定会释放锁
    let _lock_guard = ExecutionLockGuard::new(analysis_id);
    
    // 🆕 【提前智能分析检测】
    if let Some(intelligent_steps) = check_and_trigger_early_analysis(
        app, 
        analysis_id, 
        device_id, 
        ordered_steps
    ).await? {
        // ✅ 释放当前锁（由 guard 自动处理）
        drop(_lock_guard);
        
        // 递归执行时会重新锁定
        return execute_chain_by_inline(
            app, envelope, analysis_id, &intelligent_steps,
            threshold, mode, quality, constraints, validation
        ).await;
    }
    
    // ... 主执行逻辑
    
    // 函数结束时 _lock_guard 自动释放锁
    Ok(result)
    }).await
}
```

### 方案 B：使用 RAII 守卫（更安全）

创建自动释放守卫：

```rust
// src-tauri/src/exec/v3/helpers/execution_tracker.rs

/// RAII 执行锁守卫
/// 
/// 自动管理执行锁的生命周期：
/// - 创建时自动锁定
/// - 析构时自动释放
pub struct ExecutionLockGuard {
    analysis_id: String,
}

impl ExecutionLockGuard {
    /// 创建新的锁守卫（如果锁定失败会panic）
    pub fn new(analysis_id: &str) -> Self {
        force_lock(analysis_id).expect("获取执行锁失败");
        Self {
            analysis_id: analysis_id.to_string(),
        }
    }
    
    /// 尝试创建锁守卫（如果锁定失败返回None）
    pub fn try_new(analysis_id: &str) -> Option<Self> {
        if try_lock(analysis_id).ok()? {
            Some(Self {
                analysis_id: analysis_id.to_string(),
            })
        } else {
            None
        }
    }
    
    /// 手动释放锁（提前释放，不等析构）
    pub fn release(self) {
        // self 会被移动，析构时会释放锁
    }
}

impl Drop for ExecutionLockGuard {
    fn drop(&mut self) {
        if let Err(e) = unlock(&self.analysis_id) {
            tracing::error!("❌ 释放执行锁失败: {}", e);
        }
    }
}

/// 便捷函数：带守卫的锁定
pub fn lock_with_guard(analysis_id: &str) -> Result<ExecutionLockGuard, String> {
    ExecutionLockGuard::try_new(analysis_id)
        .ok_or_else(|| format!("analysis_id '{}' 已被锁定", analysis_id))
}
```

使用示例：

```rust
// 方式1: 自动管理整个函数
let _guard = execution_tracker::lock_with_guard(analysis_id)?;

// 方式2: 提前释放
let guard = execution_tracker::lock_with_guard(analysis_id)?;
// ... 执行逻辑
drop(guard);  // 显式释放
// 继续其他操作（不持有锁）
```

### 方案 C：添加超时自动释放

```rust
use std::time::{Duration, SystemTime};
use std::collections::HashMap;

lazy_static::lazy_static! {
    static ref EXECUTION_TRACKER: Arc<Mutex<HashMap<String, SystemTime>>> 
        = Arc::new(Mutex::new(HashMap::new()));
}

/// 超时时间（5分钟）
const LOCK_TIMEOUT: Duration = Duration::from_secs(300);

pub fn try_lock(analysis_id: &str) -> Result<bool, String> {
    let mut tracker = EXECUTION_TRACKER.lock()
        .map_err(|e| format!("获取执行追踪器锁失败: {}", e))?;
    
    let now = SystemTime::now();
    
    // 检查是否存在锁
    if let Some(locked_at) = tracker.get(analysis_id) {
        // 检查是否超时
        if let Ok(elapsed) = now.duration_since(*locked_at) {
            if elapsed > LOCK_TIMEOUT {
                tracing::warn!(
                    "⚠️ 【执行保护】analysis_id '{}' 锁定已超时（{}秒），自动释放",
                    analysis_id,
                    elapsed.as_secs()
                );
                tracker.remove(analysis_id);
            } else {
                tracing::warn!(
                    "❌ 【重复执行阻止】analysis_id '{}' 已在执行中（已持续 {}秒）",
                    analysis_id,
                    elapsed.as_secs()
                );
                return Ok(false);
            }
        }
    }
    
    // 锁定
    tracker.insert(analysis_id.to_string(), now);
    tracing::info!("🔒 【执行保护】已锁定 analysis_id '{}'", analysis_id);
    Ok(true)
}
```

## 🎯 推荐实施步骤

### 第一步：添加 RAII 守卫（立即见效）

```bash
# 修改 execution_tracker.rs
# 添加 ExecutionLockGuard 结构体
```

### 第二步：修改调用位置

```bash
# 修改 chain_engine.rs 中的 execute_chain_by_inline
# 在函数开始处统一使用守卫
```

### 第三步：添加超时机制（可选，增强鲁棒性）

```bash
# 在 execution_tracker.rs 中添加超时检查
# 防止异常退出导致的锁泄漏
```

### 第四步：添加调试工具

```rust
/// Tauri 命令：查看当前执行状态（调试用）
#[tauri::command]
pub fn debug_execution_tracker() -> Result<String, String> {
    let active = execution_tracker::get_active_executions()?;
    Ok(format!(
        "当前执行中的 analysis_id:\n{}\n总计: {}",
        active.join("\n"),
        active.len()
    ))
}

/// Tauri 命令：清理所有执行锁（紧急用）
#[tauri::command]
pub fn force_clear_execution_locks() -> Result<String, String> {
    let count = execution_tracker::count();
    execution_tracker::clear_all()?;
    Ok(format!("已清理 {} 个执行锁", count))
}
```

前端调用：

```typescript
// 调试面板
import { invoke } from '@tauri-apps/api/core';

async function showExecutionStatus() {
  const status = await invoke<string>('debug_execution_tracker');
  console.log(status);
  message.info(status);
}

async function forceClearLocks() {
  const result = await invoke<string>('force_clear_execution_locks');
  console.log(result);
  message.warning(result);
}
```

## 📊 验证清单

实施后验证：

- [ ] 第一次执行不会报"重复执行"错误
- [ ] 真正的重复点击能够被正确阻止
- [ ] 异常退出后锁能够自动释放（超时机制）
- [ ] 递归调用不会导致死锁
- [ ] 并发执行多个不同 analysis_id 正常工作
- [ ] 调试工具能正确显示执行状态

## 🚀 快速修复（临时方案）

如果需要立即解决，可以在前端添加防抖：

```typescript
import { debounce } from 'lodash-es';

// 创建防抖版本的执行函数
const debouncedExecute = useRef(
  debounce(async (protocol: any) => {
    const result = await SmartSelectionService.executeSmartSelection(deviceId, protocol);
    return result;
  }, 500, { leading: true, trailing: false })  // 只执行第一次
).current;

const executeSmartSelection = async () => {
  if (executing) return;
  setExecuting(true);
  
  try {
    const protocol = createSmartSelectionProtocol();
    const result = await debouncedExecute(protocol);
    message.success('执行成功');
  } catch (error) {
    message.error(`执行失败: ${error}`);
  } finally {
    setExecuting(false);
  }
};
```

或者在后端添加强制清理命令：

```rust
// 在程序启动时清理所有遗留锁
pub fn initialize_execution_tracker() {
    if let Ok(count) = execution_tracker::clear_all() {
        if count > 0 {
            tracing::warn!("🧹 启动时清理了 {} 个遗留的执行锁", count);
        }
    }
}
```

## 📝 总结

**核心原则**：
1. **统一入口** - 所有执行路径在入口处统一锁定
2. **RAII 管理** - 使用守卫自动释放，防止泄漏
3. **超时机制** - 防止异常情况下的锁泄漏
4. **调试工具** - 方便排查问题

**优先级**：
- 🔥 高优先级：添加 RAII 守卫
- ⚡ 中优先级：添加超时机制
- 💡 低优先级：添加调试工具
