# 关系锚点匹配策略完整架构

> **目标**：解决"中层无文本按钮"的精确匹配问题，使用子元素/兄弟元素/父元素文本作为锚点

## 📋 目录

- [核心问题](#核心问题)
- [架构设计](#架构设计)
- [评分系统](#评分系统)
- [执行流程](#执行流程)
- [文件结构](#文件结构)
- [数据传递](#数据传递)

---

## 核心问题

### 问题描述

用户点击的是**中层无文本容器**（如底部导航的"通讯录"按钮）：

```
结构层次：
├── 外层容器 [0,1043][1080,1279] ❌ 太大
│   ├── 中层容器 [45,1059][249,1263] ✅ 用户选择的可点击层
│   │   └── 子元素 Text="通讯录" 🎯 锚点
│   └── 其他兄弟...
```

**传统匹配问题**：
- ❌ 直接文本匹配：中层容器自己没有 text/content-desc
- ❌ Bounds 匹配：真机 XML 中元素顺序/bounds 可能变化
- ❌ 多候选评估器：容易选错外层大容器

**解决方案**：
- ✅ 使用子元素文本 "通讯录" 作为锚点
- ✅ 找到所有包含 "通讯录" 的元素
- ✅ 用完善的评分系统选择最接近用户选择的可点击层

---

## 架构设计

### 1️⃣ 前端：检测并标记策略

**文件**：`src/pages/SmartScriptBuilderPage/hooks/useIntelligentStepCardIntegration.ts`

```typescript
// 🎯 检测中层无文本容器
const isMiddleLayerContainer = !element.text && context.elementText;

// 设置匹配策略标记
const matchingStrategy = isMiddleLayerContainer 
  ? 'anchor_by_child_or_parent_text'  // 🎯 关系锚点策略
  : 'direct_match';                    // 直接匹配

// 提取锚点数据
elementSignature: {
  childrenTexts: ['通讯录'],        // 子元素文本
  siblingTexts: ['通讯录', '联系人'], // 兄弟元素文本
  parentInfo: { /* 父元素信息 */ },
  matchingStrategy: 'anchor_by_child_or_parent_text'
}
```

### 2️⃣ 数据传递：完整上下文

**文件**：`src/pages/SmartScriptBuilderPage/helpers/intelligentDataTransfer.ts`

```typescript
// 构建 original_data（后端恢复数据）
original_data: {
  original_xml: "<58KB XML快照>",
  selected_xpath: "//element_41",
  element_bounds: "[45,1059][249,1263]",
  
  // 🎯 关键：关系数据
  children_texts: ["通讯录"],
  sibling_texts: ["通讯录", "联系人"],
  parent_info: { text: "", contentDesc: "底部导航" },
  
  // 🎯 关键：策略标记
  matching_strategy: "anchor_by_child_or_parent_text"
}
```

### 3️⃣ 后端：策略路由器

**文件**：`src-tauri/src/exec/v3/recovery_manager.rs`

```rust
// 🎯 Step 0: 检查匹配策略标记
if let Some(ref strategy_tag) = recovery_ctx.matching_strategy {
    if strategy_tag.starts_with("anchor_by_") {
        // 🎯 优先使用策略路由器
        match try_strategy_router(recovery_ctx, current_elements, strategy_tag) {
            Ok(result) => return Ok(result), // ✅ 成功直接返回
            Err(e) => {
                // ⚠️ 失败回退到传统流程
                tracing::warn!("策略路由器失败: {:?}, 回退", e);
            }
        }
    }
}

// Step 1-N: 传统恢复流程（后备）
// ...
```

### 4️⃣ 策略执行器

**文件**：`src-tauri/src/services/execution/matching/strategies/anchor_by_relation_strategy.rs`

```rust
// 核心逻辑
impl AnchorByRelationStrategyProcessor {
    async fn process(&self, context, ui_elements) {
        // 1. 提取锚点配置
        let config = extract_anchor_config(params);
        // config.anchor_texts = ["通讯录"]
        // config.user_bounds = "[45,1059][249,1263]"
        
        // 2. 在 XML 中查找包含锚点文本的元素
        let candidates = find_elements_with_anchor_text(xml, &config.anchor_texts);
        // 找到：外层容器、中层容器、子文本元素...
        
        // 3. 🎯 使用评分系统选择最佳候选
        let best = select_best_candidate(candidates, &config);
        
        // 4. 计算点击坐标并返回
        Ok(StrategyResult { xpath, coordinates, ... })
    }
}
```

---

## 评分系统

### 📊 评分权重设计

**文件**：`src-tauri/src/services/execution/matching/strategies/candidate_scorer.rs`

```
总分 = 文本匹配(40分) + Bounds位置(30分) + 可点击性(20分) + 尺寸合理性(10分)
```

#### 1️⃣ 文本匹配得分（40分）- **最高优先级**

```rust
if 元素文本 == 锚点文本 {
    40分  // ✅ 完全匹配 → 高分直接选取
} else if 元素文本.contains(锚点文本) {
    20分  // ⚠️ 包含匹配 → 中等分数
} else {
    0分   // ❌ 无匹配
}
```

**实例**：
- `text="通讯录"` → 40分 ✅
- `text="通讯录 (3)"` → 20分 ⚠️
- `text="联系人"` → 0分 ❌

#### 2️⃣ Bounds 位置得分（30分）

```rust
if 元素bounds == 用户bounds {
    30分  // ✅ 完全匹配
} else {
    let distance = calculate_center_distance(元素bounds, 用户bounds);
    
    if distance <= 容差(20px) {
        30分  // ✅ 容差内
    } else if distance <= 容差*2 {
        20分  // ⚠️ 接近
    } else if distance <= 容差*5 {
        10分  // ⚠️ 较远
    } else {
        5分   // ❌ 很远
    }
}
```

**实例**：
- `bounds="[45,1059][249,1263]"` 完全匹配 → 30分 ✅
- `bounds="[50,1060][250,1264]"` 距离10px → 30分 ✅
- `bounds="[0,1043][1080,1279]"` 距离500px → 5分 ❌

#### 3️⃣ 可点击性得分（20分）

```rust
if clickable == "true" {
    20分  // ✅ 可点击
} else if !require_clickable {
    10分  // ⚠️ 不可点击但可接受
} else {
    0分   // ❌ 不可点击且要求可点击
}
```

#### 4️⃣ 尺寸合理性得分（10分）

```rust
// 避免选择过大的父容器或隐藏的小元素
let (width, height) = calculate_size(元素bounds);
let (user_width, user_height) = calculate_size(用户bounds);

let similarity = calculate_size_similarity(元素, 用户);

if similarity > 0.8 {
    10分  // ✅ 尺寸相似
} else if similarity > 0.5 {
    5分   // ⚠️ 尺寸差异
} else {
    2分   // ❌ 尺寸差异过大
}
```

**实例**：
- 中层容器 `204x204px` vs 用户选择 `200x200px` → 相似度 98% → 10分 ✅
- 外层容器 `1080x236px` vs 用户选择 `200x200px` → 相似度 20% → 2分 ❌

### 🏆 评分实例

假设真机 XML 中有 3 个候选元素：

```
候选1: 外层容器
  text=""
  bounds=[0,1043][1080,1279]  (1080x236px)
  clickable=true
  
  评分：
  - 文本匹配: 0分 (无文本)
  - Bounds位置: 5分 (距离很远)
  - 可点击性: 20分 (可点击)
  - 尺寸合理性: 2分 (过大)
  总分: 27分 ❌

候选2: 中层容器 (用户选择)
  text=""
  bounds=[45,1059][249,1263]  (204x204px)
  clickable=true
  
  评分：
  - 文本匹配: 0分 (无文本，但包含子元素"通讯录")
  - Bounds位置: 30分 (完全匹配)
  - 可点击性: 20分 (可点击)
  - 尺寸合理性: 10分 (尺寸匹配)
  总分: 60分 ✅

候选3: 子文本元素
  text="通讯录"
  bounds=[80,1100][180,1150]  (100x50px)
  clickable=false
  
  评分：
  - 文本匹配: 40分 (完全匹配) ✅
  - Bounds位置: 20分 (接近)
  - 可点击性: 0分 (不可点击)
  - 尺寸合理性: 3分 (过小)
  总分: 63分 🎯
```

**结果**：选择候选3（子文本元素）63分

**但是**：如果检测到候选3不可点击，会自动寻找其可点击的父容器 → 回到候选2 ✅

---

## 执行流程

### 完整流程图

```
┌─────────────────────────────────────────────────────────┐
│ 前端：用户点击中层无文本容器                                │
│ - 检测：!element.text && context.elementText            │
│ - 提取：children_texts = ["通讯录"]                      │
│ - 标记：matching_strategy = "anchor_by_child_text"      │
└───────────────────┬─────────────────────────────────────┘
                    │
                    │ 📦 步骤卡片 (original_data)
                    ▼
┌─────────────────────────────────────────────────────────┐
│ 后端 V3 执行链                                            │
│ 1. 真机 dump XML                                         │
│ 2. 尝试 XPath 直接匹配 → ❌ 失败                         │
└───────────────────┬─────────────────────────────────────┘
                    │
                    │ 🔧 触发恢复机制
                    ▼
┌─────────────────────────────────────────────────────────┐
│ Recovery Manager (recovery_manager.rs)                   │
│ - 检查 matching_strategy 标记                            │
│ - 发现 "anchor_by_child_or_parent_text"                 │
│ - 🎯 路由到策略处理器                                     │
└───────────────────┬─────────────────────────────────────┘
                    │
                    │ 🎯 策略路由
                    ▼
┌─────────────────────────────────────────────────────────┐
│ Anchor By Relation Strategy (anchor_by_relation_strategy)│
│                                                           │
│ Step 1: 提取锚点配置                                      │
│   config.anchor_texts = ["通讯录"]                       │
│   config.user_bounds = "[45,1059][249,1263]"            │
│                                                           │
│ Step 2: 在真机 XML 中查找包含锚点文本的元素                │
│   find_elements_with_anchor_text(xml, ["通讯录"])        │
│   → 找到 3 个候选：外层容器、中层容器、子文本元素            │
│                                                           │
│ Step 3: 🏆 使用评分系统对候选进行评分                      │
│   CandidateScorer::score_and_rank_candidates()           │
│   ┌──────────────────────────────────────────┐          │
│   │ 候选1: 外层容器 → 27分                   │          │
│   │ 候选2: 中层容器 → 60分                   │          │
│   │ 候选3: 子文本元素 → 63分 🎯              │          │
│   └──────────────────────────────────────────┘          │
│                                                           │
│ Step 4: 选择最高分候选                                    │
│   best_candidate = 候选3 (子文本元素)                     │
│   ⚠️ 检测到不可点击 → 寻找可点击父元素 → 候选2           │
│                                                           │
│ Step 5: 计算点击坐标并返回                                │
│   bounds = "[45,1059][249,1263]"                        │
│   coordinates = (147, 1161)                              │
└───────────────────┬─────────────────────────────────────┘
                    │
                    │ ✅ 返回结果
                    ▼
┌─────────────────────────────────────────────────────────┐
│ Step Executor (step_executor.rs)                         │
│ - 执行点击: tap_at_position(147, 1161)                   │
│ - ✅ 成功点击"通讯录"按钮                                 │
└─────────────────────────────────────────────────────────┘
```

---

## 文件结构

### 模块化组织（遵循项目规范）

```
src-tauri/src/
├── services/
│   └── execution/
│       └── matching/
│           └── strategies/
│               ├── mod.rs                           # 策略工厂
│               ├── anchor_by_relation_strategy.rs  # 🎯 关系锚点策略
│               └── candidate_scorer.rs             # 🎯 评分系统
│
├── exec/
│   └── v3/
│       ├── recovery_manager.rs                     # 🎯 集成策略路由器
│       └── element_matching/
│           └── multi_candidate_evaluator.rs        # 传统评估器（后备）
│
└── ...

src/pages/SmartScriptBuilderPage/
├── hooks/
│   └── useIntelligentStepCardIntegration.ts        # 🎯 前端检测与提取
│
└── helpers/
    └── intelligentDataTransfer.ts                  # 🎯 数据打包传递
```

### 关键文件说明

| 文件 | 职责 | 关键函数 |
|------|------|----------|
| `useIntelligentStepCardIntegration.ts` | 检测中层容器，提取锚点数据 | `detectMiddleLayerContainer()` |
| `intelligentDataTransfer.ts` | 打包 original_data | `buildBackendParameters()` |
| `recovery_manager.rs` | 策略路由入口 | `try_strategy_router()` |
| `anchor_by_relation_strategy.rs` | 关系锚点匹配执行 | `find_elements_with_anchor_text()`, `select_best_candidate()` |
| `candidate_scorer.rs` | 候选元素评分 | `score_and_rank_candidates()` |

---

## 数据传递

### 前端 → 后端数据流

```typescript
// 🎯 前端构建的数据包
{
  step_type: "smart_tap",
  parameters: {
    // 基础信息
    element_selector: "//element_41",
    bounds: "[45,1059][249,1263]",
    text: "通讯录",
    
    // 🎯 关键：original_data
    original_data: {
      // 原始 XML 快照（58KB）
      original_xml: "<hierarchy>...</hierarchy>",
      xml_hash: "e0d909c3...",
      
      // 用户选择的精确信息
      selected_xpath: "//element_41",
      element_bounds: "[45,1059][249,1263]",
      element_text: "通讯录",
      
      // 🎯 关键：关系锚点数据
      children_texts: ["通讯录"],
      sibling_texts: ["通讯录", "联系人"],
      parent_info: {
        text: "",
        contentDesc: "底部导航栏",
        resourceId: "com.app:id/bottom_nav"
      },
      
      // 🎯 关键：策略标记
      matching_strategy: "anchor_by_child_or_parent_text",
      
      // 元数据
      key_attributes: {
        "resource-id": "com.app:id/contacts_tab",
        "content-desc": "",
        "text": "",
        "class": "android.widget.FrameLayout"
      },
      
      // 数据完整性标记
      data_integrity: {
        has_original_xml: true,
        has_user_xpath: true,
        has_children_texts: true,
        has_sibling_texts: true,
        has_parent_info: true,
        extraction_timestamp: 1698463232000
      }
    }
  }
}
```

### 后端读取数据

```rust
// recovery_manager.rs - RecoveryContext::from_params()

let recovery_ctx = RecoveryContext {
    // 原始 XML
    original_xml: original_data["original_xml"],  // 58KB
    
    // 用户选择
    selected_xpath: original_data["selected_xpath"],  // "//element_41"
    element_bounds: original_data["element_bounds"],  // "[45,1059][249,1263]"
    
    // 🎯 关系数据
    children_texts: original_data["children_texts"],  // ["通讯录"]
    sibling_texts: original_data["sibling_texts"],    // ["通讯录", "联系人"]
    parent_info: original_data["parent_info"],         // { ... }
    
    // 🎯 策略标记
    matching_strategy: original_data["matching_strategy"],  // "anchor_by_child_..."
    
    // ...
};
```

---

## 测试验证

### 1️⃣ 单元测试（评分系统）

```rust
#[test]
fn test_text_exact_match_gets_high_score() {
    let candidate = hashmap!{
        "text" => "通讯录",
        "bounds" => "[45,1059][249,1263]",
        "clickable" => "true"
    };
    
    let config = ScoringConfig {
        anchor_texts: vec!["通讯录".to_string()],
        user_bounds: Some("[45,1059][249,1263]".to_string()),
        ..Default::default()
    };
    
    let score = CandidateScorer::score_candidate(&candidate, &config);
    
    // 文本完全匹配(40) + Bounds完全匹配(30) + 可点击(20) + 尺寸匹配(10) = 100分
    assert_eq!(score.total_score, 100.0);
}
```

### 2️⃣ 集成测试（端到端）

```typescript
// 测试流程
1. 前端点击底部导航"通讯录"按钮
2. 检查步骤卡片数据：
   ✅ matchingStrategy = "anchor_by_child_or_parent_text"
   ✅ children_texts = ["通讯录"]
   ✅ original_data 完整

3. 后端执行：
   ✅ 策略路由器被触发
   ✅ 找到 3 个候选元素
   ✅ 评分结果正确
   ✅ 选择最佳候选（中层容器）

4. 真机操作：
   ✅ 点击坐标 (147, 1161)
   ✅ 成功打开通讯录页面
```

---

## 与 Step 0-6 智能策略的关系

### 集成位置

```
Step 0-6 智能策略系统
├── Step 0: 规范化输入
├── Step 1: Self-Anchor (resource-id/content-desc 直接定位)
├── Step 2: Child-Driven (子树找锚点) 🎯 关系锚点策略在这里
├── Step 3: Content-Desc 定位
├── Step 4: Region-Scoped (区域限定)
├── Step 5: 邻居相对定位
└── Step 6: XPath 索引兜底
```

### 执行优先级

```
V3 执行链
├── 1️⃣ XPath 直接匹配（最快）
│
├── 2️⃣ 失败恢复机制启动
│   │
│   ├── 🎯 检查 matching_strategy 标记
│   │   │
│   │   ├── "anchor_by_child_or_parent_text" → 策略路由器 ✅ 优先
│   │   ├── "direct_match" → 传统流程
│   │   └── 其他...
│   │
│   └── 🔧 策略路由器失败 → 回退到传统流程
│
└── 3️⃣ 传统恢复流程（Multi-Candidate Evaluator）
```

---

## 总结

### ✅ 完成的功能

1. **前端检测**：自动识别中层无文本容器
2. **数据提取**：提取子/兄弟/父元素文本作为锚点
3. **策略标记**：明确告知后端使用关系锚点策略
4. **策略路由**：后端优先使用策略路由器
5. **评分系统**：完善的4维度评分（文本40 + 位置30 + 可点击20 + 尺寸10）
6. **模块化**：符合项目规范的子文件夹组织

### 🎯 核心优势

1. **文本完全匹配 → 高分直接选取**（40分）
2. **无法精准匹配 → Bounds 辅助评分**（30分）
3. **考虑隐藏元素**：尺寸合理性检测（10分）
4. **避免大容器**：尺寸相似度评分（10分）
5. **完整日志**：每个候选的详细评分解释

### 🚀 下一步优化方向

1. ✅ 支持更多关系类型（子、兄弟、父、祖先）
2. ✅ 支持文本同义词（"通讯录" = "Contacts"）
3. ✅ 支持正则表达式锚点
4. ✅ 动态调整评分权重
5. ✅ 机器学习优化权重配置

---

**文档版本**: v1.0  
**最后更新**: 2025-10-28  
**作者**: AI 编程助手  
**项目**: marketing-automation-desktop
