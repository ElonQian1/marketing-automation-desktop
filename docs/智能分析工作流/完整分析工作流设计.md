# 步骤卡片生成工作流重新设计

## 🎯 需求重新理解

### 核心约束
1. **步骤卡片是脚本共享单元** - 必须完整、自包含
2. **不允许有等待状态** - 生成时就必须分析完成
3. **策略分析要持久化** - 随脚本传播给其他用户
4. **支持基于快照重新分析** - 用户可选择重新分析

### 脚本共享场景
```
用户A创建脚本 → 生成步骤卡片(含完整分析) → 分享给用户B → 用户B直接使用
                                            ↓
                                         用户B可选择重新分析
```

## 🔄 重新设计的工作流

### 方案：阻塞式完整分析

**核心思路：** 点选元素后，必须等待分析完成才能生成步骤卡片

#### 新的交互流程：
```
1. 用户点选元素
   ↓
2. 显示分析对话框 (Modal)
   - 显示分析进度
   - 不可跳过，必须等待完成
   - 提供取消选项 (回到选择状态)
   ↓
3. 分析完成后自动生成步骤卡片
   - 包含完整的策略分析
   - 包含XML快照
   - 包含元数据 (分析时间、版本等)
   ↓
4. 步骤卡片可直接使用和共享
```

#### 步骤卡片数据结构：
```typescript
interface CompletedStepCard {
  id: string;
  
  // 元素信息
  element: ElementDescriptor;
  xmlSnapshot: string; // 完整的XML快照
  
  // 分析结果 (必须完整)
  analysis: {
    smartStrategy: SmartStrategy; // 主要策略
    alternatives: SmartStrategy[]; // 备选策略
    manualFallback: ManualStrategy; // 手动降级策略
    confidence: number;
    analysisMetadata: {
      analyzedAt: number;
      analyzerVersion: string;
      userId: string;
      deviceInfo?: string;
    };
  };
  
  // 当前选中策略
  selectedStrategy: SmartStrategy | ManualStrategy;
  
  // 共享信息
  shareMetadata: {
    createdBy: string;
    createdAt: number;
    sharedCount: number;
    lastUsedAt: number;
  };
}
```

## 🛠️ 具体实现方案

### 1. 分析对话框组件

```tsx
// src/modules/universal-ui/ui/ElementAnalysisModal.tsx
interface ElementAnalysisModalProps {
  element: ElementDescriptor | null;
  visible: boolean;
  onComplete: (stepCard: CompletedStepCard) => void;
  onCancel: () => void;
}

export const ElementAnalysisModal: React.FC<ElementAnalysisModalProps> = ({
  element, visible, onComplete, onCancel
}) => {
  const [stage, setStage] = useState<'analyzing' | 'completed' | 'failed'>('analyzing');
  const [progress, setProgress] = useState(0);
  const [analysisResult, setAnalysisResult] = useState<AnalysisResult | null>(null);
  
  useEffect(() => {
    if (visible && element) {
      performCompleteAnalysis(element);
    }
  }, [visible, element]);
  
  const performCompleteAnalysis = async (element: ElementDescriptor) => {
    try {
      // 阶段1: 获取XML快照
      setProgress(20);
      const xmlSnapshot = await captureXmlSnapshot();
      
      // 阶段2: 智能策略分析
      setProgress(40);
      const smartStrategies = await generateAllSmartStrategies(element, xmlSnapshot);
      
      // 阶段3: 生成手动降级策略
      setProgress(60);
      const manualFallback = generateManualFallback(element);
      
      // 阶段4: 评估和排序
      setProgress(80);
      const rankedStrategies = await evaluateAndRankStrategies(smartStrategies);
      
      // 阶段5: 完成
      setProgress(100);
      const result = {
        smartStrategy: rankedStrategies[0],
        alternatives: rankedStrategies.slice(1),
        manualFallback,
        confidence: rankedStrategies[0].confidence,
        xmlSnapshot,
        analysisMetadata: {
          analyzedAt: Date.now(),
          analyzerVersion: '2.0.0',
          userId: getCurrentUserId()
        }
      };
      
      setAnalysisResult(result);
      setStage('completed');
      
      // 自动生成完整的步骤卡片
      const stepCard = createCompletedStepCard(element, result);
      onComplete(stepCard);
      
    } catch (error) {
      setStage('failed');
      console.error('分析失败:', error);
    }
  };
  
  return (
    <Modal
      title="正在分析元素"
      open={visible}
      onCancel={onCancel}
      footer={null}
      closable={stage !== 'analyzing'}
      maskClosable={false}
    >
      {stage === 'analyzing' && (
        <div style={{ textAlign: 'center', padding: '40px 20px' }}>
          <Spin size="large" />
          <div style={{ marginTop: 16, fontSize: 16 }}>
            正在深度分析元素策略...
          </div>
          <Progress 
            percent={progress} 
            status="active"
            style={{ marginTop: 16 }}
          />
          <div style={{ marginTop: 8, color: '#666' }}>
            {getStageDescription(progress)}
          </div>
          <div style={{ marginTop: 16 }}>
            <Button onClick={onCancel}>取消分析</Button>
          </div>
        </div>
      )}
      
      {stage === 'completed' && (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <CheckCircleOutlined style={{ fontSize: 48, color: '#52c41a' }} />
          <div style={{ marginTop: 16, fontSize: 16 }}>分析完成！</div>
          <div style={{ marginTop: 8 }}>
            已生成 {analysisResult?.alternatives.length + 1} 种策略方案
          </div>
        </div>
      )}
      
      {stage === 'failed' && (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <ExclamationCircleOutlined style={{ fontSize: 48, color: '#ff4d4f' }} />
          <div style={{ marginTop: 16, fontSize: 16 }}>分析失败</div>
          <div style={{ marginTop: 16 }}>
            <Button type="primary" onClick={() => performCompleteAnalysis(element!)}>
              重新分析
            </Button>
            <Button style={{ marginLeft: 8 }} onClick={onCancel}>
              取消
            </Button>
          </div>
        </div>
      )}
    </Modal>
  );
};
```

### 2. 步骤卡片组件升级

```tsx
// src/modules/universal-ui/ui/CompletedStepCard.tsx
interface CompletedStepCardProps {
  stepCard: CompletedStepCard;
  onStrategyChange: (strategy: SmartStrategy | ManualStrategy) => void;
  onReanalyze: () => void; // 重新分析
  onEdit: () => void;
  onDelete: () => void;
}

export const CompletedStepCard: React.FC<CompletedStepCardProps> = ({
  stepCard, onStrategyChange, onReanalyze, onEdit, onDelete
}) => {
  const { analysis, selectedStrategy, shareMetadata } = stepCard;
  
  return (
    <Card
      title={
        <Space>
          <Text strong>{stepCard.element.text || '步骤'}</Text>
          <Tag color="green">已完成分析</Tag>
          {shareMetadata.sharedCount > 0 && (
            <Tag color="blue">已共享 {shareMetadata.sharedCount} 次</Tag>
          )}
        </Space>
      }
      extra={
        <Dropdown menu={{
          items: [
            { key: 'reanalyze', label: '重新分析', icon: <ReloadOutlined /> },
            { key: 'edit', label: '编辑', icon: <EditOutlined /> },
            { key: 'delete', label: '删除', icon: <DeleteOutlined />, danger: true }
          ],
          onClick: ({ key }) => {
            if (key === 'reanalyze') onReanalyze();
            else if (key === 'edit') onEdit();
            else if (key === 'delete') onDelete();
          }
        }}>
          <Button type="text" icon={<MoreOutlined />} />
        </Dropdown>
      }
      className="light-theme-force"
    >
      {/* 策略选择区域 */}
      <div style={{ marginBottom: 16 }}>
        <Text strong>选择策略：</Text>
        <Select
          value={selectedStrategy.kind === 'smart' ? 
            `smart-${selectedStrategy.selector.variant}` : 
            'manual'
          }
          style={{ width: '100%', marginTop: 8 }}
          onChange={(value) => {
            if (value === 'manual') {
              onStrategyChange(analysis.manualFallback);
            } else {
              const variant = value.replace('smart-', '');
              const strategy = [analysis.smartStrategy, ...analysis.alternatives]
                .find(s => s.selector.variant === variant);
              if (strategy) onStrategyChange(strategy);
            }
          }}
        >
          <Select.Option value={`smart-${analysis.smartStrategy.selector.variant}`}>
            <Space>
              <ThunderboltOutlined />
              智能策略: {analysis.smartStrategy.selector.variant}
              <Tag color="gold">推荐</Tag>
            </Space>
          </Select.Option>
          
          {analysis.alternatives.map((alt, idx) => (
            <Select.Option key={idx} value={`smart-${alt.selector.variant}`}>
              <Space>
                <ThunderboltOutlined />
                智能策略: {alt.selector.variant}
              </Space>
            </Select.Option>
          ))}
          
          <Select.Option value="manual">
            <Space>
              <EditOutlined />
              手动策略: {analysis.manualFallback.name}
            </Space>
          </Select.Option>
        </Select>
      </div>
      
      {/* 当前策略详情 */}
      <StrategyDetailsDisplay strategy={selectedStrategy} />
      
      {/* 分析元数据 */}
      <Divider />
      <div style={{ fontSize: 12, color: '#666' }}>
        <div>分析时间: {new Date(analysis.analysisMetadata.analyzedAt).toLocaleString()}</div>
        <div>分析版本: {analysis.analysisMetadata.analyzerVersion}</div>
        <div>置信度: {(analysis.confidence * 100).toFixed(1)}%</div>
      </div>
    </Card>
  );
};
```

### 3. 主要工作流集成

```tsx
// 在页面查找器中的集成
const UniversalPageFinder: React.FC = () => {
  const [selectedElement, setSelectedElement] = useState<ElementDescriptor | null>(null);
  const [analysisModalVisible, setAnalysisModalVisible] = useState(false);
  const [stepCards, setStepCards] = useState<CompletedStepCard[]>([]);
  
  const handleElementSelect = (element: ElementDescriptor) => {
    setSelectedElement(element);
    setAnalysisModalVisible(true);
  };
  
  const handleAnalysisComplete = (stepCard: CompletedStepCard) => {
    setStepCards(prev => [...prev, stepCard]);
    setAnalysisModalVisible(false);
    setSelectedElement(null);
    message.success('步骤卡片生成完成！');
  };
  
  const handleReanalyze = (stepCard: CompletedStepCard) => {
    // 基于已有的XML快照重新分析
    setSelectedElement(stepCard.element);
    setAnalysisModalVisible(true);
  };
  
  return (
    <div>
      {/* 元素选择区域 */}
      <ElementSelectionView onElementSelect={handleElementSelect} />
      
      {/* 步骤卡片列表 */}
      <div style={{ marginTop: 24 }}>
        {stepCards.map(card => (
          <CompletedStepCard
            key={card.id}
            stepCard={card}
            onStrategyChange={(strategy) => {
              // 更新选中策略
              setStepCards(prev => prev.map(c => 
                c.id === card.id ? { ...c, selectedStrategy: strategy } : c
              ));
            }}
            onReanalyze={() => handleReanalyze(card)}
            onEdit={() => {/* 编辑逻辑 */}}
            onDelete={() => {
              setStepCards(prev => prev.filter(c => c.id !== card.id));
            }}
          />
        ))}
      </div>
      
      {/* 分析对话框 */}
      <ElementAnalysisModal
        element={selectedElement}
        visible={analysisModalVisible}
        onComplete={handleAnalysisComplete}
        onCancel={() => {
          setAnalysisModalVisible(false);
          setSelectedElement(null);
        }}
      />
    </div>
  );
};
```

## 🚀 优势分析

### 1. 脚本共享友好
- ✅ 步骤卡片包含完整分析，其他用户直接使用
- ✅ 包含XML快照，支持在不同环境重新分析
- ✅ 版本和元数据完整，便于追踪和调试

### 2. 用户体验清晰
- ✅ 明确的等待过程，用户知道在做什么
- ✅ 可以取消，不会卡在分析状态
- ✅ 完成后立即可用，无需等待

### 3. 策略质量保证
- ✅ 必须分析完成才能生成卡片
- ✅ 包含多种策略选择
- ✅ 支持基于快照重新分析

这个方案彻底解决了你提到的问题：
1. **不会有等待状态** - 要么在分析，要么已完成
2. **脚本共享完整** - 包含所有必要的分析信息
3. **支持重新分析** - 基于XML快照可重新分析

你觉得这个重新设计的方案如何？