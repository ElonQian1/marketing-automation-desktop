# æ­¥éª¤å¡ç‰‡ç”Ÿæˆå·¥ä½œæµé‡æ–°è®¾è®¡

## ğŸ¯ éœ€æ±‚é‡æ–°ç†è§£

### æ ¸å¿ƒçº¦æŸ
1. **æ­¥éª¤å¡ç‰‡æ˜¯è„šæœ¬å…±äº«å•å…ƒ** - å¿…é¡»å®Œæ•´ã€è‡ªåŒ…å«
2. **ä¸å…è®¸æœ‰ç­‰å¾…çŠ¶æ€** - ç”Ÿæˆæ—¶å°±å¿…é¡»åˆ†æå®Œæˆ
3. **ç­–ç•¥åˆ†æè¦æŒä¹…åŒ–** - éšè„šæœ¬ä¼ æ’­ç»™å…¶ä»–ç”¨æˆ·
4. **æ”¯æŒåŸºäºå¿«ç…§é‡æ–°åˆ†æ** - ç”¨æˆ·å¯é€‰æ‹©é‡æ–°åˆ†æ

### è„šæœ¬å…±äº«åœºæ™¯
```
ç”¨æˆ·Aåˆ›å»ºè„šæœ¬ â†’ ç”Ÿæˆæ­¥éª¤å¡ç‰‡(å«å®Œæ•´åˆ†æ) â†’ åˆ†äº«ç»™ç”¨æˆ·B â†’ ç”¨æˆ·Bç›´æ¥ä½¿ç”¨
                                            â†“
                                         ç”¨æˆ·Bå¯é€‰æ‹©é‡æ–°åˆ†æ
```

## ğŸ”„ é‡æ–°è®¾è®¡çš„å·¥ä½œæµ

### æ–¹æ¡ˆï¼šé˜»å¡å¼å®Œæ•´åˆ†æ

**æ ¸å¿ƒæ€è·¯ï¼š** ç‚¹é€‰å…ƒç´ åï¼Œå¿…é¡»ç­‰å¾…åˆ†æå®Œæˆæ‰èƒ½ç”Ÿæˆæ­¥éª¤å¡ç‰‡

#### æ–°çš„äº¤äº’æµç¨‹ï¼š
```
1. ç”¨æˆ·ç‚¹é€‰å…ƒç´ 
   â†“
2. æ˜¾ç¤ºåˆ†æå¯¹è¯æ¡† (Modal)
   - æ˜¾ç¤ºåˆ†æè¿›åº¦
   - ä¸å¯è·³è¿‡ï¼Œå¿…é¡»ç­‰å¾…å®Œæˆ
   - æä¾›å–æ¶ˆé€‰é¡¹ (å›åˆ°é€‰æ‹©çŠ¶æ€)
   â†“
3. åˆ†æå®Œæˆåè‡ªåŠ¨ç”Ÿæˆæ­¥éª¤å¡ç‰‡
   - åŒ…å«å®Œæ•´çš„ç­–ç•¥åˆ†æ
   - åŒ…å«XMLå¿«ç…§
   - åŒ…å«å…ƒæ•°æ® (åˆ†ææ—¶é—´ã€ç‰ˆæœ¬ç­‰)
   â†“
4. æ­¥éª¤å¡ç‰‡å¯ç›´æ¥ä½¿ç”¨å’Œå…±äº«
```

#### æ­¥éª¤å¡ç‰‡æ•°æ®ç»“æ„ï¼š
```typescript
interface CompletedStepCard {
  id: string;
  
  // å…ƒç´ ä¿¡æ¯
  element: ElementDescriptor;
  xmlSnapshot: string; // å®Œæ•´çš„XMLå¿«ç…§
  
  // åˆ†æç»“æœ (å¿…é¡»å®Œæ•´)
  analysis: {
    smartStrategy: SmartStrategy; // ä¸»è¦ç­–ç•¥
    alternatives: SmartStrategy[]; // å¤‡é€‰ç­–ç•¥
    manualFallback: ManualStrategy; // æ‰‹åŠ¨é™çº§ç­–ç•¥
    confidence: number;
    analysisMetadata: {
      analyzedAt: number;
      analyzerVersion: string;
      userId: string;
      deviceInfo?: string;
    };
  };
  
  // å½“å‰é€‰ä¸­ç­–ç•¥
  selectedStrategy: SmartStrategy | ManualStrategy;
  
  // å…±äº«ä¿¡æ¯
  shareMetadata: {
    createdBy: string;
    createdAt: number;
    sharedCount: number;
    lastUsedAt: number;
  };
}
```

## ğŸ› ï¸ å…·ä½“å®ç°æ–¹æ¡ˆ

### 1. åˆ†æå¯¹è¯æ¡†ç»„ä»¶

```tsx
// src/modules/universal-ui/ui/ElementAnalysisModal.tsx
interface ElementAnalysisModalProps {
  element: ElementDescriptor | null;
  visible: boolean;
  onComplete: (stepCard: CompletedStepCard) => void;
  onCancel: () => void;
}

export const ElementAnalysisModal: React.FC<ElementAnalysisModalProps> = ({
  element, visible, onComplete, onCancel
}) => {
  const [stage, setStage] = useState<'analyzing' | 'completed' | 'failed'>('analyzing');
  const [progress, setProgress] = useState(0);
  const [analysisResult, setAnalysisResult] = useState<AnalysisResult | null>(null);
  
  useEffect(() => {
    if (visible && element) {
      performCompleteAnalysis(element);
    }
  }, [visible, element]);
  
  const performCompleteAnalysis = async (element: ElementDescriptor) => {
    try {
      // é˜¶æ®µ1: è·å–XMLå¿«ç…§
      setProgress(20);
      const xmlSnapshot = await captureXmlSnapshot();
      
      // é˜¶æ®µ2: æ™ºèƒ½ç­–ç•¥åˆ†æ
      setProgress(40);
      const smartStrategies = await generateAllSmartStrategies(element, xmlSnapshot);
      
      // é˜¶æ®µ3: ç”Ÿæˆæ‰‹åŠ¨é™çº§ç­–ç•¥
      setProgress(60);
      const manualFallback = generateManualFallback(element);
      
      // é˜¶æ®µ4: è¯„ä¼°å’Œæ’åº
      setProgress(80);
      const rankedStrategies = await evaluateAndRankStrategies(smartStrategies);
      
      // é˜¶æ®µ5: å®Œæˆ
      setProgress(100);
      const result = {
        smartStrategy: rankedStrategies[0],
        alternatives: rankedStrategies.slice(1),
        manualFallback,
        confidence: rankedStrategies[0].confidence,
        xmlSnapshot,
        analysisMetadata: {
          analyzedAt: Date.now(),
          analyzerVersion: '2.0.0',
          userId: getCurrentUserId()
        }
      };
      
      setAnalysisResult(result);
      setStage('completed');
      
      // è‡ªåŠ¨ç”Ÿæˆå®Œæ•´çš„æ­¥éª¤å¡ç‰‡
      const stepCard = createCompletedStepCard(element, result);
      onComplete(stepCard);
      
    } catch (error) {
      setStage('failed');
      console.error('åˆ†æå¤±è´¥:', error);
    }
  };
  
  return (
    <Modal
      title="æ­£åœ¨åˆ†æå…ƒç´ "
      open={visible}
      onCancel={onCancel}
      footer={null}
      closable={stage !== 'analyzing'}
      maskClosable={false}
    >
      {stage === 'analyzing' && (
        <div style={{ textAlign: 'center', padding: '40px 20px' }}>
          <Spin size="large" />
          <div style={{ marginTop: 16, fontSize: 16 }}>
            æ­£åœ¨æ·±åº¦åˆ†æå…ƒç´ ç­–ç•¥...
          </div>
          <Progress 
            percent={progress} 
            status="active"
            style={{ marginTop: 16 }}
          />
          <div style={{ marginTop: 8, color: '#666' }}>
            {getStageDescription(progress)}
          </div>
          <div style={{ marginTop: 16 }}>
            <Button onClick={onCancel}>å–æ¶ˆåˆ†æ</Button>
          </div>
        </div>
      )}
      
      {stage === 'completed' && (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <CheckCircleOutlined style={{ fontSize: 48, color: '#52c41a' }} />
          <div style={{ marginTop: 16, fontSize: 16 }}>åˆ†æå®Œæˆï¼</div>
          <div style={{ marginTop: 8 }}>
            å·²ç”Ÿæˆ {analysisResult?.alternatives.length + 1} ç§ç­–ç•¥æ–¹æ¡ˆ
          </div>
        </div>
      )}
      
      {stage === 'failed' && (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <ExclamationCircleOutlined style={{ fontSize: 48, color: '#ff4d4f' }} />
          <div style={{ marginTop: 16, fontSize: 16 }}>åˆ†æå¤±è´¥</div>
          <div style={{ marginTop: 16 }}>
            <Button type="primary" onClick={() => performCompleteAnalysis(element!)}>
              é‡æ–°åˆ†æ
            </Button>
            <Button style={{ marginLeft: 8 }} onClick={onCancel}>
              å–æ¶ˆ
            </Button>
          </div>
        </div>
      )}
    </Modal>
  );
};
```

### 2. æ­¥éª¤å¡ç‰‡ç»„ä»¶å‡çº§

```tsx
// src/modules/universal-ui/ui/CompletedStepCard.tsx
interface CompletedStepCardProps {
  stepCard: CompletedStepCard;
  onStrategyChange: (strategy: SmartStrategy | ManualStrategy) => void;
  onReanalyze: () => void; // é‡æ–°åˆ†æ
  onEdit: () => void;
  onDelete: () => void;
}

export const CompletedStepCard: React.FC<CompletedStepCardProps> = ({
  stepCard, onStrategyChange, onReanalyze, onEdit, onDelete
}) => {
  const { analysis, selectedStrategy, shareMetadata } = stepCard;
  
  return (
    <Card
      title={
        <Space>
          <Text strong>{stepCard.element.text || 'æ­¥éª¤'}</Text>
          <Tag color="green">å·²å®Œæˆåˆ†æ</Tag>
          {shareMetadata.sharedCount > 0 && (
            <Tag color="blue">å·²å…±äº« {shareMetadata.sharedCount} æ¬¡</Tag>
          )}
        </Space>
      }
      extra={
        <Dropdown menu={{
          items: [
            { key: 'reanalyze', label: 'é‡æ–°åˆ†æ', icon: <ReloadOutlined /> },
            { key: 'edit', label: 'ç¼–è¾‘', icon: <EditOutlined /> },
            { key: 'delete', label: 'åˆ é™¤', icon: <DeleteOutlined />, danger: true }
          ],
          onClick: ({ key }) => {
            if (key === 'reanalyze') onReanalyze();
            else if (key === 'edit') onEdit();
            else if (key === 'delete') onDelete();
          }
        }}>
          <Button type="text" icon={<MoreOutlined />} />
        </Dropdown>
      }
      className="light-theme-force"
    >
      {/* ç­–ç•¥é€‰æ‹©åŒºåŸŸ */}
      <div style={{ marginBottom: 16 }}>
        <Text strong>é€‰æ‹©ç­–ç•¥ï¼š</Text>
        <Select
          value={selectedStrategy.kind === 'smart' ? 
            `smart-${selectedStrategy.selector.variant}` : 
            'manual'
          }
          style={{ width: '100%', marginTop: 8 }}
          onChange={(value) => {
            if (value === 'manual') {
              onStrategyChange(analysis.manualFallback);
            } else {
              const variant = value.replace('smart-', '');
              const strategy = [analysis.smartStrategy, ...analysis.alternatives]
                .find(s => s.selector.variant === variant);
              if (strategy) onStrategyChange(strategy);
            }
          }}
        >
          <Select.Option value={`smart-${analysis.smartStrategy.selector.variant}`}>
            <Space>
              <ThunderboltOutlined />
              æ™ºèƒ½ç­–ç•¥: {analysis.smartStrategy.selector.variant}
              <Tag color="gold">æ¨è</Tag>
            </Space>
          </Select.Option>
          
          {analysis.alternatives.map((alt, idx) => (
            <Select.Option key={idx} value={`smart-${alt.selector.variant}`}>
              <Space>
                <ThunderboltOutlined />
                æ™ºèƒ½ç­–ç•¥: {alt.selector.variant}
              </Space>
            </Select.Option>
          ))}
          
          <Select.Option value="manual">
            <Space>
              <EditOutlined />
              æ‰‹åŠ¨ç­–ç•¥: {analysis.manualFallback.name}
            </Space>
          </Select.Option>
        </Select>
      </div>
      
      {/* å½“å‰ç­–ç•¥è¯¦æƒ… */}
      <StrategyDetailsDisplay strategy={selectedStrategy} />
      
      {/* åˆ†æå…ƒæ•°æ® */}
      <Divider />
      <div style={{ fontSize: 12, color: '#666' }}>
        <div>åˆ†ææ—¶é—´: {new Date(analysis.analysisMetadata.analyzedAt).toLocaleString()}</div>
        <div>åˆ†æç‰ˆæœ¬: {analysis.analysisMetadata.analyzerVersion}</div>
        <div>ç½®ä¿¡åº¦: {(analysis.confidence * 100).toFixed(1)}%</div>
      </div>
    </Card>
  );
};
```

### 3. ä¸»è¦å·¥ä½œæµé›†æˆ

```tsx
// åœ¨é¡µé¢æŸ¥æ‰¾å™¨ä¸­çš„é›†æˆ
const UniversalPageFinder: React.FC = () => {
  const [selectedElement, setSelectedElement] = useState<ElementDescriptor | null>(null);
  const [analysisModalVisible, setAnalysisModalVisible] = useState(false);
  const [stepCards, setStepCards] = useState<CompletedStepCard[]>([]);
  
  const handleElementSelect = (element: ElementDescriptor) => {
    setSelectedElement(element);
    setAnalysisModalVisible(true);
  };
  
  const handleAnalysisComplete = (stepCard: CompletedStepCard) => {
    setStepCards(prev => [...prev, stepCard]);
    setAnalysisModalVisible(false);
    setSelectedElement(null);
    message.success('æ­¥éª¤å¡ç‰‡ç”Ÿæˆå®Œæˆï¼');
  };
  
  const handleReanalyze = (stepCard: CompletedStepCard) => {
    // åŸºäºå·²æœ‰çš„XMLå¿«ç…§é‡æ–°åˆ†æ
    setSelectedElement(stepCard.element);
    setAnalysisModalVisible(true);
  };
  
  return (
    <div>
      {/* å…ƒç´ é€‰æ‹©åŒºåŸŸ */}
      <ElementSelectionView onElementSelect={handleElementSelect} />
      
      {/* æ­¥éª¤å¡ç‰‡åˆ—è¡¨ */}
      <div style={{ marginTop: 24 }}>
        {stepCards.map(card => (
          <CompletedStepCard
            key={card.id}
            stepCard={card}
            onStrategyChange={(strategy) => {
              // æ›´æ–°é€‰ä¸­ç­–ç•¥
              setStepCards(prev => prev.map(c => 
                c.id === card.id ? { ...c, selectedStrategy: strategy } : c
              ));
            }}
            onReanalyze={() => handleReanalyze(card)}
            onEdit={() => {/* ç¼–è¾‘é€»è¾‘ */}}
            onDelete={() => {
              setStepCards(prev => prev.filter(c => c.id !== card.id));
            }}
          />
        ))}
      </div>
      
      {/* åˆ†æå¯¹è¯æ¡† */}
      <ElementAnalysisModal
        element={selectedElement}
        visible={analysisModalVisible}
        onComplete={handleAnalysisComplete}
        onCancel={() => {
          setAnalysisModalVisible(false);
          setSelectedElement(null);
        }}
      />
    </div>
  );
};
```

## ğŸš€ ä¼˜åŠ¿åˆ†æ

### 1. è„šæœ¬å…±äº«å‹å¥½
- âœ… æ­¥éª¤å¡ç‰‡åŒ…å«å®Œæ•´åˆ†æï¼Œå…¶ä»–ç”¨æˆ·ç›´æ¥ä½¿ç”¨
- âœ… åŒ…å«XMLå¿«ç…§ï¼Œæ”¯æŒåœ¨ä¸åŒç¯å¢ƒé‡æ–°åˆ†æ
- âœ… ç‰ˆæœ¬å’Œå…ƒæ•°æ®å®Œæ•´ï¼Œä¾¿äºè¿½è¸ªå’Œè°ƒè¯•

### 2. ç”¨æˆ·ä½“éªŒæ¸…æ™°
- âœ… æ˜ç¡®çš„ç­‰å¾…è¿‡ç¨‹ï¼Œç”¨æˆ·çŸ¥é“åœ¨åšä»€ä¹ˆ
- âœ… å¯ä»¥å–æ¶ˆï¼Œä¸ä¼šå¡åœ¨åˆ†æçŠ¶æ€
- âœ… å®Œæˆåç«‹å³å¯ç”¨ï¼Œæ— éœ€ç­‰å¾…

### 3. ç­–ç•¥è´¨é‡ä¿è¯
- âœ… å¿…é¡»åˆ†æå®Œæˆæ‰èƒ½ç”Ÿæˆå¡ç‰‡
- âœ… åŒ…å«å¤šç§ç­–ç•¥é€‰æ‹©
- âœ… æ”¯æŒåŸºäºå¿«ç…§é‡æ–°åˆ†æ

è¿™ä¸ªæ–¹æ¡ˆå½»åº•è§£å†³äº†ä½ æåˆ°çš„é—®é¢˜ï¼š
1. **ä¸ä¼šæœ‰ç­‰å¾…çŠ¶æ€** - è¦ä¹ˆåœ¨åˆ†æï¼Œè¦ä¹ˆå·²å®Œæˆ
2. **è„šæœ¬å…±äº«å®Œæ•´** - åŒ…å«æ‰€æœ‰å¿…è¦çš„åˆ†æä¿¡æ¯
3. **æ”¯æŒé‡æ–°åˆ†æ** - åŸºäºXMLå¿«ç…§å¯é‡æ–°åˆ†æ

ä½ è§‰å¾—è¿™ä¸ªé‡æ–°è®¾è®¡çš„æ–¹æ¡ˆå¦‚ä½•ï¼Ÿ