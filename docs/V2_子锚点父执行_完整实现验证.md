# 子锚点→父执行 V2 完整实现验证

## 🎯 核心场景测试

### 场景1: 底部导航"收藏"按钮
**结构特点**: 可点击在LinearLayout父节点，文本在TextView子节点

#### 前端发送的StepCard结构
```json
{
  "step_id": "tap_favorite_tab_1761222441420",
  "structured_selector": {
    "elementSelectors": {
      "targetNodeType": "LinearLayout",
      "anchorXpath": ".//TextView[@resource-id='content' and @text='收藏']",
      "parentConstraint": "[@clickable='true']",
      "containerXpath": "//*[@resource-id='bottom_navigation']",
      "i18nTextVariants": ["收藏", "Favorites", "Starred"]
    },
    "action": {
      "type": "tap"
    },
    "safety": {
      "min_confidence": 0.70,
      "require_uniqueness": true,
      "forbid_fullscreen_or_container": true
    }
  }
}
```

#### 后端生成的增强XPath
```xpath
//*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//TextView[@resource-id='content' and (@text='收藏' or @text='Favorites' or @text='Starred')]]
```

#### 预期执行日志
```
🎯 selector_source=Inline
✅ 使用卡片内联selector
🏗️ 生成子锚点→父执行XPath: //*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//TextView[@resource-id='content' and (@text='收藏' or @text='Favorites' or @text='Starred')]]
🔍 最终搜索条件: xpath=Some("//*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//TextView[@resource-id='content' and (@text='收藏' or @text='Favorites' or @text='Starred')]]")
✅ 自测通过: 至少有一个selector字段非None
🔍 双重唯一性: 总候选=1, 高质量(≥0.70)=1, Top1=0.950, Gap=1.000, 唯一性=1 (conf:true gap:true)  
✅ 自测通过: 非容器/整屏节点 class=Some("LinearLayout") bounds=(720,2200,1080,2400)
🎯 执行点击: (900, 2300)
```

---

## 🔬 关键验证点

### 1. 子锚点字段解析验证
```rust
// 检查点1: 新增字段是否正确解析
let target_node_type = element_selectors.get("targetNodeType").and_then(|v| v.as_str()).map(|s| s.to_string());
let anchor_xpath = element_selectors.get("anchorXpath").and_then(|v| v.as_str()).map(|s| s.to_string());
let parent_constraint = element_selectors.get("parentConstraint").and_then(|v| v.as_str()).map(|s| s.to_string());
let container_xpath = element_selectors.get("containerXpath").and_then(|v| v.as_str()).map(|s| s.to_string());

// 验证I18N变体数组解析
let i18n_variants = element_selectors.get("i18nTextVariants")
    .and_then(|v| v.as_array())
    .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect::<Vec<String>>());
```

### 2. XPath生成逻辑验证
```rust
fn build_child_to_parent_xpath(
    container_xpath: &Option<String>,     // "//*[@resource-id='bottom_navigation']"
    target_node_type: &Option<String>,   // "LinearLayout"  
    parent_constraint: &Option<String>,  // "[@clickable='true']"
    anchor_xpath: &Option<String>,       // ".//TextView[@resource-id='content' and @text='收藏']"
    i18n_variants: &Option<Vec<String>>  // ["收藏","Favorites","Starred"]
) -> Option<String>

// 预期输出:
// "//*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//TextView[@resource-id='content' and (@text='收藏' or @text='Favorites' or @text='Starred')]]"
```

### 3. 双阶段容器拦截验证
```rust
// 匹配阶段拦截
let is_container = is_container_node(&candidate.class_name);
let is_fullscreen = is_fullscreen_node(&(candidate.bounds.left, candidate.bounds.top, candidate.bounds.right, candidate.bounds.bottom));

if is_container || is_fullscreen {
    return Err(format!("CONTAINER_BLOCKED: {}节点不允许直接点击", block_type));
}

// Hit-Test阶段拦截
if is_fullscreen_node(&(node_bounds.left, node_bounds.top, node_bounds.right, node_bounds.bottom)) {
    continue; // 跳过整屏节点
}

if is_container_node(&class_name) {
    continue; // 跳过容器节点
}
```

### 4. 双重唯一性判定验证
```rust
// 标准1: 高置信度候选唯一
let is_unique_by_confidence = high_quality_matches == 1;

// 标准2: Top1-Top2置信度间隔足够
let is_unique_by_gap = confidence_gap >= 0.15;

// 任一满足即可执行
let uniqueness = if is_unique_by_confidence || is_unique_by_gap { 1 } else { high_quality_matches.max(2) as i32 };
```

---

## 📋 完整自测检查清单

### ✅ 前端发送格式验证
- [ ] `targetNodeType` 字段正确包含
- [ ] `anchorXpath` 字段包含子节点选择条件
- [ ] `parentConstraint` 字段包含父节点约束
- [ ] `containerXpath` 字段包含区域限定
- [ ] `i18nTextVariants` 数组包含多语言变体

### ✅ 后端解析验证
- [ ] 子锚点字段成功解析并记录日志
- [ ] XPath生成器正确拼接复合选择器
- [ ] I18N文本变体正确转换为 OR 条件

### ✅ 执行时安全检查
- [ ] 双重唯一性判定正确工作
- [ ] 容器节点在匹配阶段被拦截
- [ ] 整屏节点在匹配阶段被拦截  
- [ ] 坐标兜底时hit-test正确拒绝容器

### ✅ 日志输出验证
- [ ] `selector_source=Inline` 正确显示
- [ ] `生成子锚点→父执行XPath` 日志出现
- [ ] `双重唯一性` 统计信息正确
- [ ] `自测通过: 非容器/整屏节点` 验证信息

---

## 🚀 端到端测试用例

### 测试用例1: 成功场景
**输入**: 底部导航收藏按钮的子锚点配置
**预期**: 生成正确XPath，唯一性通过，容器检查通过，成功点击

### 测试用例2: 多语言切换场景  
**输入**: i18nTextVariants包含["收藏","Favorites"]
**预期**: XPath包含OR条件，英文环境下也能正确匹配

### 测试用例3: 容器拦截场景
**输入**: 选择器匹配到ViewGroup容器
**预期**: 返回CONTAINER_BLOCKED错误，拒绝执行

### 测试用例4: 非唯一性场景
**输入**: 选择器匹配到多个高置信度候选
**预期**: 唯一性检查失败，触发回退或报错

### 测试用例5: 坐标兜底场景
**输入**: 所有选择器失败，启用坐标兜底
**预期**: Hit-Test找到最小可交互节点，拒绝容器

---

## 💡 实现亮点总结

1. **架构优雅**: 在现有V2框架内无缝集成子锚点→父执行逻辑
2. **向后兼容**: 不影响现有的text/xpath/resource-id选择器
3. **安全第一**: 双阶段容器拦截 + 双重唯一性保证
4. **多语言友好**: I18N变体自动转换为OR条件
5. **可观测性强**: 完整的日志输出便于调试和验证
6. **渐进增强**: 可以逐步从简单选择器迁移到复合选择器

---

## 🔧 快速集成指南

### 步骤1: 前端构建子锚点配置
```typescript  
const structuredSelector = {
  elementSelectors: {
    targetNodeType: "LinearLayout",
    anchorXpath: ".//TextView[@resource-id='content' and @text='收藏']",
    parentConstraint: "[@clickable='true']", 
    containerXpath: "//*[@resource-id='bottom_navigation']",
    i18nTextVariants: ["收藏", "Favorites", "Starred"]
  }
};
```

### 步骤2: 发送到V2引擎
```typescript
const request = {
  device_id: "device_123",
  mode: "StructuredSelector",
  strategy: "IntelligentSelector", 
  step: {
    step_id: "tap_favorite_tab",
    structured_selector: structuredSelector
  }
};
```

### 步骤3: 验证执行日志
查找关键日志标识：
- `🏗️ 生成子锚点→父执行XPath`
- `🔍 双重唯一性`
- `✅ 自测通过: 非容器/整屏节点`

---

这套实现完美解决了"父无字段、子有字段"的安卓UI自动化核心难题，同时保持了高度的安全性和可观测性。