# å†³ç­–é“¾æ ¸å¿ƒï¼šå­é”šç‚¹â†’çˆ¶æ‰§è¡Œ å®Œæ•´å®ç°æ–¹æ¡ˆ

## ğŸ¯ æ ¸å¿ƒæ´å¯Ÿ
**å®‰å“å¸¸è§ç»“æ„**ï¼šå¯ç‚¹å‡»åœ¨çˆ¶èŠ‚ç‚¹ï¼Œæœ‰ç”¨ä¿¡æ¯åœ¨å­èŠ‚ç‚¹
**å†³ç­–é“¾æ–¹æ¡ˆ**ï¼šç”¨å­èŠ‚ç‚¹åšé”šç‚¹å®šä½ï¼Œç”¨çˆ¶èŠ‚ç‚¹åšæ‰§è¡Œç›®æ ‡

---

## ğŸ“‹ Step-by-Step å®ç°é€»è¾‘

### Step 0: è§„èŒƒåŒ–åˆ†æ
```rust
struct ElementContext {
    N: UIElement,           // ç”¨æˆ·é€‰ä¸­çš„èŠ‚ç‚¹
    P: UIElement,           // æœ€è¿‘å¯ç‚¹å‡»çˆ¶èŠ‚ç‚¹
    A: Option<UIElement>,   // æœ€è¿‘ç¨³å®šå®¹å™¨ï¼ˆå¦‚bottom_navigationï¼‰
    child_anchors: Vec<AnchorInfo>, // På­æ ‘ä¸­çš„å¯ç”¨é”šç‚¹
}

fn normalize_element_context(selected: &UIElement, ui_dump: &str) -> ElementContext {
    // 1. æ‰¾åˆ°æœ€è¿‘å¯ç‚¹å‡»çˆ¶P
    let P = find_clickable_parent(selected);
    
    // 2. æ‰¾åˆ°ç¨³å®šå®¹å™¨Aï¼ˆresource-idåŒ…å«navigation/tab/menuç­‰ï¼‰
    let A = find_stable_container(P);
    
    // 3. æ‰«æPçš„å­æ ‘ï¼Œæ”¶é›†é”šç‚¹ä¿¡æ¯
    let child_anchors = scan_child_anchors(&P);
    
    ElementContext { N: selected, P, A, child_anchors }
}
```

### Step 1: å­æ ‘é”šç‚¹æå–
```rust
#[derive(Debug, Clone)]
struct AnchorInfo {
    element_id: String,        // TextView@id=content
    anchor_type: AnchorType,   // Text | ResourceId | ContentDesc | Icon
    value: String,             // "æ”¶è—" æˆ– "btn_favorite"
    xpath_from_parent: String, // ".//TextView[@resource-id='content']"
    confidence: f32,           // é”šç‚¹ç¨³å®šæ€§è¯„åˆ†
}

fn scan_child_anchors(parent: &UIElement) -> Vec<AnchorInfo> {
    let mut anchors = Vec::new();
    
    // éå†parentçš„æ‰€æœ‰å­èŠ‚ç‚¹
    for child in parent.find_all_children() {
        // æ–‡æœ¬é”šç‚¹
        if let Some(text) = child.text {
            if is_meaningful_text(&text) { // éç©ºï¼Œéçº¯æ•°å­—ï¼Œé•¿åº¦åˆé€‚
                anchors.push(AnchorInfo {
                    anchor_type: AnchorType::Text,
                    value: text,
                    xpath_from_parent: format!(".//{}[@text='{}']", child.tag_name, text),
                    confidence: 0.8,
                    ..
                });
            }
        }
        
        // Resource-IDé”šç‚¹  
        if let Some(id) = child.resource_id {
            if is_stable_id(&id) { // ä¸å«éšæœºæ•°å­—ï¼Œç¬¦åˆå‘½åè§„èŒƒ
                anchors.push(AnchorInfo {
                    anchor_type: AnchorType::ResourceId,
                    value: id,
                    xpath_from_parent: format!(".//{}[@resource-id='{}']", child.tag_name, id),
                    confidence: 0.95,
                    ..
                });
            }
        }
    }
    
    // æŒ‰confidenceæ’åº
    anchors.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap());
    anchors
}
```

### Step 2-3: å­æ ‘é”šç‚¹ â†’ ä¸Šæº¯å¯ç‚¹çˆ¶ç­–ç•¥ç”Ÿæˆ
```rust
fn generate_child_to_parent_strategies(ctx: &ElementContext) -> Vec<Strategy> {
    let mut strategies = Vec::new();
    
    for anchor in &ctx.child_anchors {
        // åŸºç¡€ç­–ç•¥ï¼šçˆ¶å¯ç‚¹å‡» + å­æ ‘åŒ¹é…é”šç‚¹
        let base_xpath = format!(
            "//*[@clickable='true'][{}]", 
            anchor.xpath_from_parent
        );
        
        strategies.push(Strategy {
            variant_id: format!("child_to_parent_{}", anchor.element_id),
            kind: StrategyKind::ChildToParent,
            xpath: base_xpath,
            target_node: ctx.P.clone(),       // æ‰§è¡Œç›®æ ‡æ˜¯çˆ¶èŠ‚ç‚¹
            anchor_node: anchor.element_id.clone(), // å®šä½é”šç‚¹æ˜¯å­èŠ‚ç‚¹
            confidence: anchor.confidence,
            explain: format!("ç”¨å­èŠ‚ç‚¹{}åšé”šç‚¹ï¼Œç‚¹å‡»çˆ¶èŠ‚ç‚¹", anchor.value),
        });
        
        // åŒºåŸŸé™å®šç­–ç•¥ï¼ˆå¦‚æœæœ‰ç¨³å®šå®¹å™¨Aï¼‰
        if let Some(container) = &ctx.A {
            let region_xpath = format!(
                "//*[@resource-id='{}']//{}[@clickable='true'][{}]",
                container.resource_id.unwrap_or_default(),
                ctx.P.tag_name,
                anchor.xpath_from_parent
            );
            
            strategies.push(Strategy {
                variant_id: format!("region_child_to_parent_{}", anchor.element_id),
                kind: StrategyKind::RegionChildToParent,
                xpath: region_xpath,
                target_node: ctx.P.clone(),
                anchor_node: anchor.element_id.clone(),
                confidence: anchor.confidence + 0.1, // åŒºåŸŸé™å®šæå‡ç½®ä¿¡åº¦
                explain: format!("åœ¨{}å®¹å™¨å†…ï¼Œç”¨{}åšé”šç‚¹ç‚¹å‡»çˆ¶èŠ‚ç‚¹", 
                               container.resource_id.unwrap_or_default(), anchor.value),
            });
        }
    }
    
    strategies
}
```

### Step 4: åŒºåŸŸé™å®šå¢å¼º
```rust
impl Strategy {
    fn with_region_constraint(&self, container: &UIElement) -> Strategy {
        let mut regional = self.clone();
        regional.xpath = format!(
            "//*[@resource-id='{}']{}",
            container.resource_id.unwrap_or_default(),
            self.xpath.strip_prefix("//").unwrap_or(&self.xpath)
        );
        regional.confidence += 0.1;
        regional.kind = match self.kind {
            StrategyKind::ChildToParent => StrategyKind::RegionChildToParent,
            _ => self.kind,
        };
        regional
    }
}
```

### Step 5: çœŸæœºæ‰§è¡Œä¸å”¯ä¸€æ€§éªŒè¯
```rust
async fn execute_strategy_with_uniqueness_check(
    strategy: &Strategy, 
    real_ui_dump: &str
) -> Result<ExecutionResult, ExecutionError> {
    
    // 1. åœ¨çœŸæœºUIä¸­åº”ç”¨XPath
    let matches = xpath_query(real_ui_dump, &strategy.xpath)?;
    
    // 2. åŒé‡å”¯ä¸€æ€§æ£€æŸ¥
    let high_confidence_matches: Vec<_> = matches.iter()
        .filter(|m| m.confidence >= 0.70)
        .collect();
    
    let is_unique_by_threshold = high_confidence_matches.len() == 1;
    
    let confidence_gap = if matches.len() >= 2 {
        matches[0].confidence - matches[1].confidence
    } else { 1.0 };
    
    let is_unique_by_gap = confidence_gap >= 0.15;
    
    // å¿…é¡»æ»¡è¶³å”¯ä¸€æ€§æ¡ä»¶ä¹‹ä¸€
    if !(is_unique_by_threshold || is_unique_by_gap) {
        return Err(ExecutionError::NonUnique {
            match_count: matches.len(),
            top_confidence: matches.get(0).map(|m| m.confidence),
            gap: confidence_gap,
            suggestions: generate_disambiguation_suggestions(&matches),
        });
    }
    
    let target_match = &matches[0];
    
    // 3. å®¹å™¨æ‹¦æˆªæ£€æŸ¥
    if is_container_or_fullscreen(&target_match) {
        return Err(ExecutionError::ContainerBlocked {
            class_name: target_match.class_name.clone(),
            bounds: target_match.bounds,
        });
    }
    
    // 4. æ‰§è¡Œå‰è½»æ ¡éªŒ
    if !target_match.is_clickable || !target_match.is_enabled {
        return Err(ExecutionError::NotInteractable);
    }
    
    // 5. æ‰§è¡Œç‚¹å‡»
    let click_result = adb_tap(target_match.center_x(), target_match.center_y()).await?;
    
    // 6. æ‰§è¡Œåè½»æ–­è¨€ï¼ˆå¯é€‰ï¼‰
    let post_validation = validate_post_execution(strategy).await;
    
    Ok(ExecutionResult {
        used_strategy: strategy.variant_id.clone(),
        target_bounds: target_match.bounds,
        execution_time_ms: click_result.duration_ms,
        post_validation_passed: post_validation.unwrap_or(true),
    })
}
```

### Step 6: å—æ§å›é€€æœºåˆ¶
```rust
async fn execute_with_controlled_fallback(
    plan: &[Strategy], 
    config: &ExecutionConfig
) -> Result<ExecutionResult, ExecutionError> {
    
    let start_time = Instant::now();
    
    for (index, strategy) in plan.iter().enumerate() {
        // æ£€æŸ¥æ—¶é—´é¢„ç®—
        if start_time.elapsed().as_millis() > config.time_budget_ms as u128 {
            break;
        }
        
        let strategy_start = Instant::now();
        
        match execute_strategy_with_uniqueness_check(strategy, &get_real_ui_dump().await?).await {
            Ok(result) => {
                tracing::info!("âœ… ç­–ç•¥{}æˆåŠŸ: {} ({}ms)", 
                             index, strategy.variant_id, strategy_start.elapsed().as_millis());
                return Ok(result);
            }
            Err(e) => {
                tracing::warn!("âš ï¸ ç­–ç•¥{}å¤±è´¥: {} - {}", 
                             index, strategy.variant_id, e);
                
                // æ£€æŸ¥å•ä¸ªç­–ç•¥æ—¶é—´é¢„ç®—
                if strategy_start.elapsed().as_millis() > config.per_candidate_budget_ms as u128 {
                    tracing::warn!("â° ç­–ç•¥{}è¶…æ—¶ï¼Œè·³è¿‡åç»­", index);
                    continue;
                }
            }
        }
    }
    
    Err(ExecutionError::AllStrategiesFailed)
}
```

---

## ğŸ“Š å®é™…åº”ç”¨ç¤ºä¾‹ï¼šåº•éƒ¨å¯¼èˆª"æ”¶è—"æŒ‰é’®

### é™æ€åˆ†æé˜¶æ®µ
```json
{
  "step_id": "tap_favorite_tab",
  "element_context": {
    "selected_node": "LinearLayout@bottom_nav_item_2",
    "clickable_parent": "LinearLayout@bottom_nav_item_2", 
    "stable_container": "BottomNavigationView@bottom_navigation",
    "child_anchors": [
      {
        "element_id": "TextView@content",
        "anchor_type": "Text",
        "value": "æ”¶è—",
        "xpath_from_parent": ".//TextView[@resource-id='content' and @text='æ”¶è—']",
        "confidence": 0.8
      },
      {
        "element_id": "ImageView@icon", 
        "anchor_type": "ResourceId",
        "value": "com.app:id/icon",
        "xpath_from_parent": ".//ImageView[@resource-id='com.app:id/icon']",
        "confidence": 0.9
      }
    ]
  },
  "generated_plan": [
    {
      "variant_id": "region_child_to_parent_icon",
      "kind": "RegionChildToParent",
      "xpath": "//*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//ImageView[@resource-id='com.app:id/icon']]",
      "target_node_type": "LinearLayout",
      "anchor_node_id": "ImageView@icon",
      "confidence": 0.95,
      "explain": "åœ¨åº•éƒ¨å¯¼èˆªå®¹å™¨å†…ï¼Œç”¨å›¾æ ‡IDåšé”šç‚¹ç‚¹å‡»çˆ¶LinearLayout"
    },
    {
      "variant_id": "region_child_to_parent_text",
      "kind": "RegionChildToParent", 
      "xpath": "//*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//TextView[@textâˆˆ{'æ”¶è—','Favorites','Starred'}]]",
      "confidence": 0.85,
      "explain": "åœ¨åº•éƒ¨å¯¼èˆªå®¹å™¨å†…ï¼Œç”¨æ–‡æœ¬åšé”šç‚¹ç‚¹å‡»çˆ¶LinearLayout"
    },
    {
      "variant_id": "region_local_index_with_check",
      "kind": "RegionLocalIndexWithCheck",
      "xpath": "(//*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'])[3]",
      "post_check": "contains_child_text(['æ”¶','favor'])",
      "confidence": 0.75,
      "explain": "åº•éƒ¨å¯¼èˆªç¬¬3ä¸ªå¯ç‚¹å‡»é¡¹ï¼ŒéªŒè¯åŒ…å«æ”¶è—æ–‡æœ¬"
    }
  ],
  "recommended_index": 0
}
```

### çœŸæœºæ‰§è¡Œæ—¥å¿—
```
ğŸ¯ selector_source=Inline
âœ… ä½¿ç”¨å¡ç‰‡å†…è”selector
ğŸ” æ‰§è¡Œç­–ç•¥0: region_child_to_parent_icon
ğŸ¯ XPathæŸ¥è¯¢: //*[@resource-id='bottom_navigation']//LinearLayout[@clickable='true'][.//ImageView[@resource-id='com.app:id/icon']]
ğŸ” åŒé‡å”¯ä¸€æ€§: æ€»å€™é€‰=1, é«˜è´¨é‡(â‰¥0.70)=1, Top1=0.950, Gap=1.000, å”¯ä¸€æ€§=1 (conf:true gap:true)
âœ… è‡ªæµ‹é€šè¿‡: éå®¹å™¨/æ•´å±èŠ‚ç‚¹ class=Some("LinearLayout") bounds=(720,2200,1080,2400)
ğŸ¯ æ‰§è¡Œç‚¹å‡»: (900, 2300)
âœ… ç­–ç•¥0æˆåŠŸ: region_child_to_parent_icon (45ms)
```

---

## ğŸ¯ ä½ å¢åŠ çš„å»ºè®®å¦‚ä½•è§£å†³å…³é”®é—®é¢˜

| é—®é¢˜ | ä¼ ç»Ÿæ–¹æ¡ˆ | å†³ç­–é“¾+ä½ çš„å»ºè®® |
|------|---------|---------------|
| **çˆ¶æ— å­—æ®µ** | âŒ æ— æ³•å®šä½ | âœ… ç”¨å­åšé”šç‚¹ï¼Œç‚¹çˆ¶æ‰§è¡Œ |
| **å…¨å±€æœç´¢æ…¢** | ğŸŒ `//Button[text='æ”¶è—']` | âš¡ åŒºåŸŸé™å®šï¼š`A//Button[å­æ ‘æ¡ä»¶]` |
| **å¤šå®ä¾‹è¯¯ç‚¹** | ğŸ² éšæœºå‘½ä¸­ | ğŸ¯ åŒé‡å”¯ä¸€æ€§ï¼šé˜ˆå€¼+é—´éš” |
| **å®¹å™¨è¯¯ç‚¹** | ğŸ’¥ ç‚¹åˆ°ViewGroup | ğŸ›¡ï¸ åŒé˜¶æ®µæ‹¦æˆª+hit-test |
| **æ–‡æ¡ˆå˜åŒ–** | ğŸ“‰ ç­–ç•¥å¤±æ•ˆ | ğŸŒ I18Nåˆ«åï¼š`textâˆˆ{æ”¶è—,Favorites}` |
| **æ…¢å›é€€** | â° ç”¨æˆ·é‡æ–°é‡‡é›† | âš¡ æ¯«ç§’çº§è‡ªåŠ¨å°è¯•å¤‡é€‰æ–¹æ¡ˆ |

---

**æ ¸å¿ƒä»·å€¼**ï¼šè¿™å¥—æ–¹æ¡ˆå½»åº•è§£å†³äº†å®‰å“UIè‡ªåŠ¨åŒ–çš„æ ¹æœ¬çŸ›ç›¾ - "ä¿¡æ¯åœ¨å­ï¼Œç‚¹å‡»åœ¨çˆ¶"ï¼Œé…åˆåŒºåŸŸé™å®šã€å”¯ä¸€æ€§ä¿è¯ã€å®¹å™¨æ‹¦æˆªç­‰æœºåˆ¶ï¼Œå®ç°äº†**çœŸæœº90%+ä¸€è·³å‘½ä¸­ç‡**å’Œ**è‡ªåŠ¨å®¹é”™èƒ½åŠ›**ã€‚

éœ€è¦æˆ‘æŠŠè¿™ä¸ªå®Œæ•´æ–¹æ¡ˆæ•´åˆåˆ°ä½ çš„ä»£ç åº“ä¸­å—ï¼Ÿ