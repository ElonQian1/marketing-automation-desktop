# ğŸ—ï¸ ç»“æ„åŒ¹é…åŠŸèƒ½æ·±åº¦è§£æ

## ğŸ¯ ç»“æ„åŒ¹é…åŠŸèƒ½æ¦‚è§ˆ

"ç»“æ„åŒ¹é…"æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„é«˜çº§åˆ†æåŠŸèƒ½ï¼Œå®ƒä¸“é—¨ç”¨äº**åŸºäºUIå…ƒç´ çš„ç»“æ„ç‰¹å¾è¿›è¡Œç²¾ç¡®åŒ¹é…**ã€‚ä¸æ™ºèƒ½è‡ªåŠ¨é“¾ä¸åŒï¼Œç»“æ„åŒ¹é…æ›´ä¸“æ³¨äº**ç»†ç²’åº¦çš„å­—æ®µçº§åˆ«åŒ¹é…ç­–ç•¥**ã€‚

---

## ğŸ”„ ç»“æ„åŒ¹é…çš„å®Œæ•´å·¥ä½œæµç¨‹

### **æµç¨‹å›¾ï¼šç»“æ„åŒ¹é…åˆ†æé“¾è·¯**

```mermaid
sequenceDiagram
    participant U as ğŸ‘¤ç”¨æˆ·
    participant SM as ğŸ—ï¸ç»“æ„åŒ¹é…æ¨¡æ€æ¡†
    participant SC as âš™ï¸é…ç½®æœåŠ¡
    participant TS as ğŸ“ŠTauriåç«¯æœåŠ¡
    participant SS as ğŸ¯ç»“æ„è¯„åˆ†å™¨
    participant FS as ğŸ“æ–‡ä»¶å­˜å‚¨

    U->>SM: é€‰æ‹©æ¨¡æ¿å…ƒç´ 
    SM->>SM: æå–å…ƒç´ ç»“æ„ç‰¹å¾
    U->>SM: é…ç½®åŒ¹é…å­—æ®µå’Œç­–ç•¥
    SM->>SC: createStructuralConfig()
    SC->>SC: ç”Ÿæˆå­—æ®µé…ç½®
    SC-->>SM: è¿”å›é…ç½®å¯¹è±¡
    
    U->>SM: å¼€å§‹åŒ¹é…æµ‹è¯•
    SM->>TS: evaluateStructuralMatch()
    TS->>SS: è°ƒç”¨ç»“æ„è¯„åˆ†å™¨
    SS->>SS: 6å­—æ®µç±»å‹è¯„åˆ†
    Note over SS: ResourceId, Text, ClassName<br/>ContentDesc, Bounds, ChildrenStructure
    SS->>SS: åº”ç”¨åŒ¹é…ç­–ç•¥
    Note over SS: BOTH_NON_EMPTY<br/>CONSISTENT_EMPTINESS<br/>VALUE_SIMILARITYç­‰
    SS-->>TS: è¿”å›åŒ¹é…ç»“æœ
    TS-->>SM: è¯„åˆ†å’Œé€šè¿‡çŠ¶æ€
    SM->>SM: æ˜¾ç¤ºå¯è§†åŒ–ç»“æœ
    
    opt æ‰¹é‡åŒ¹é…
        SM->>TS: evaluateStructuralMatchBatch()
        TS->>SS: æ‰¹é‡è¯„ä¼°å¤šä¸ªå…ƒç´ 
        SS-->>TS: æ‰¹é‡è¯„åˆ†ç»“æœ
        TS-->>SM: è¿”å›åŒ¹é…å…ƒç´ åˆ—è¡¨
    end
    
    opt ä¿å­˜é…ç½®
        SM->>FS: ä¿å­˜é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
        Note over FS: StructuralMatchingConfig
    end
```

---

## ğŸ“‹ è¯¦ç»†æµç¨‹åˆ†è§£

### **é˜¶æ®µ1ï¼šæ¨¡æ¿å…ƒç´ é€‰æ‹©ä¸ç‰¹å¾æå–**

```typescript
// ç”¨æˆ·é€‰æ‹©æ¨¡æ¿å…ƒç´ åï¼Œç³»ç»Ÿæå–å…¶ç»“æ„ç‰¹å¾
export interface StructuralFieldConfig {
  fieldType: FieldType;              // å­—æ®µç±»å‹
  enabled: boolean;                  // æ˜¯å¦å‚ä¸è¯„åˆ†
  matchMode: MatchMode;              // åŒ¹é…æ¨¡å¼ (EXACT/FUZZY/SEMANTIC)
  weight: number;                    // å­—æ®µæƒé‡ 0-1
  scoringRules: ScoringRules;        // è¯„åˆ†ç»†åˆ™
  displayName: string;               // æ˜¾ç¤ºåç§°
  templateValue?: any;               // æ¨¡æ¿å…ƒç´ çš„å­—æ®µå€¼
}

// 6ç§æ ¸å¿ƒå­—æ®µç±»å‹
enum FieldType {
  ResourceId = 'resource-id',        // èµ„æºID
  ContentDesc = 'content-desc',      // å†…å®¹æè¿°
  Text = 'text',                     // æ–‡æœ¬å†…å®¹
  ClassName = 'class-name',          // ç±»å
  ChildrenStructure = 'children',    // å­å…ƒç´ ç»“æ„
  Bounds = 'bounds'                  // è¾¹ç•Œåæ ‡
}
```

### **é˜¶æ®µ2ï¼šåŒ¹é…ç­–ç•¥é…ç½®**

```typescript
// æä¾›6ç§åŒ¹é…ç­–ç•¥
enum MatchStrategy {
  EXACT_MATCH = 'exact_match',                    // ç²¾ç¡®åŒ¹é…
  BOTH_NON_EMPTY = 'both_non_empty',             // éƒ½éç©ºå³å¯
  CONSISTENT_EMPTINESS = 'consistent_emptiness',  // ä¿æŒç©º/éç©ºä¸€è‡´
  VALUE_SIMILARITY = 'value_similarity',         // å€¼ç›¸ä¼¼åŒ¹é…
  PARTIAL_MATCH = 'partial_match',               // éƒ¨åˆ†åŒ¹é…
  STRUCTURAL_SIMILARITY = 'structural_similarity' // ç»“æ„ç›¸ä¼¼æ€§
}

// ç­–ç•¥é…ç½®ç¤ºä¾‹
const strategyConfig = {
  [MatchStrategy.BOTH_NON_EMPTY]: {
    exactMatchScore: 1.0,      // å®Œå…¨åŒ¹é…å¾—åˆ†
    conditionMetScore: 0.8,    // æ¡ä»¶æ»¡è¶³å¾—åˆ†
    conditionFailScore: -0.2,  // æ¡ä»¶å¤±è´¥æ‰£åˆ†
    description: "éƒ½éç©ºå³å¯åŒ¹é…"
  }
};
```

### **é˜¶æ®µ3ï¼šåç«¯ç»“æ„è¯„åˆ†å¼•æ“**

```rust
// src-tauri/src/domain/structural_matching/structural_scorer.rs
impl StructuralScorer {
    pub fn evaluate(
        config: &StructuralMatchingConfig,
        template_element: &Value,
        target_element: &Value,
    ) -> StructuralMatchResult {
        let mut field_results = Vec::new();
        let mut total_score = 0.0;
        let mut max_score = 0.0;
        
        // ğŸ¯ éå†å¯ç”¨çš„å­—æ®µè¿›è¡Œè¯„åˆ†
        for field_config in config.enabled_fields() {
            // 1. æå–å­—æ®µå€¼
            let template_value = Self::extract_field_value(
                template_element, 
                field_config.field_type
            );
            let target_value = Self::extract_field_value(
                target_element, 
                field_config.field_type
            );
            
            // 2. è·å–å­—æ®µä¸“ç”¨è¯„åˆ†å™¨
            let scorer = get_field_scorer(field_config.field_type);
            
            // 3. æ‰§è¡Œè¯„åˆ†
            let result = scorer.score(
                &template_value, 
                &target_value, 
                field_config
            );
            
            // 4. ç´¯ç§¯å¾—åˆ†
            total_score += result.score * field_config.weight;
            max_score += result.max_score * field_config.weight;
            field_results.push(result);
        }
        
        // 5. åˆ¤æ–­æ˜¯å¦é€šè¿‡é˜ˆå€¼
        let passed = total_score >= config.global_threshold;
        
        StructuralMatchResult {
            total_score,
            max_score: Some(max_score),
            field_results,
            passed,
        }
    }
}
```

### **é˜¶æ®µ4ï¼šå­—æ®µçº§åˆ«ç²¾ç»†è¯„åˆ†**

```rust
// æ¯ç§å­—æ®µç±»å‹éƒ½æœ‰ä¸“ç”¨çš„è¯„åˆ†å™¨
use super::models::FieldType;

pub fn get_field_scorer(field_type: FieldType) -> Box<dyn FieldScorer> {
    match field_type {
        FieldType::ResourceId => Box::new(ResourceIdScorer),
        FieldType::ContentDesc => Box::new(ContentDescScorer),
        FieldType::Text => Box::new(TextScorer),
        FieldType::ClassName => Box::new(ClassNameScorer),
        FieldType::ChildrenStructure => Box::new(ChildrenScorer),
        FieldType::Bounds => Box::new(BoundsScorer),
    }
}

trait FieldScorer {
    fn score(
        &self,
        template_value: &Value,
        target_value: &Value,
        config: &StructuralFieldConfig,
    ) -> FieldMatchResult;
}
```

---

## ğŸ’¾ ç»“æ„åŒ¹é…çš„æ•°æ®å­˜å‚¨

### **1. å‰ç«¯é…ç½®å­˜å‚¨**

```typescript
// ç»“æ„åŒ¹é…é…ç½®å¯¹è±¡
export interface StructuralMatchingConfig {
  configId: string;                    // é…ç½®ID
  templateElementId: string;           // æ¨¡æ¿å…ƒç´ ID
  templateStructure: any;              // æ¨¡æ¿å…ƒç´ å®Œæ•´ç»“æ„
  fields: StructuralFieldConfig[];     // å„å­—æ®µé…ç½®
  globalThreshold: number;             // å…¨å±€é˜ˆå€¼ 0-1
  createdAt: number;                   // åˆ›å»ºæ—¶é—´
  updatedAt: number;                   // æ›´æ–°æ—¶é—´
}

// å­˜å‚¨ä½ç½®ï¼šæµè§ˆå™¨æœ¬åœ°å­˜å‚¨
// localStorage.setItem('structural_configs', JSON.stringify(configs));
```

### **2. åŒ¹é…ç»“æœå­˜å‚¨**

```typescript
// åŒ¹é…ç»“æœå¯¹è±¡
export interface StructuralMatchResult {
  element?: any;                       // åŒ¹é…çš„å…ƒç´ 
  totalScore: number;                  // æ€»åˆ†
  maxScore?: number;                   // æœ€å¤§å¯èƒ½åˆ†æ•°
  fieldResults: FieldMatchResult[];    // å„å­—æ®µå¾—åˆ†æ˜ç»†
  passed: boolean;                     // æ˜¯å¦é€šè¿‡é˜ˆå€¼
}

// å­—æ®µåŒ¹é…ç»“æœæ˜ç»†
export interface FieldMatchResult {
  fieldType: FieldType;                // å­—æ®µç±»å‹
  score: number;                       // å¾—åˆ†
  maxScore: number;                    // æœ€å¤§å¯èƒ½åˆ†æ•°
  matched: boolean;                    // æ˜¯å¦åŒ¹é…
  reason: string;                      // åŸå› è¯´æ˜
}
```

### **3. å¯è§†åŒ–é¢„è§ˆæ•°æ®**

```typescript
// ç”¨äºå¯è§†åŒ–é¢„è§ˆçš„æ•°æ®ç»“æ„
interface StructuralPreviewData {
  templateElement: UIElement;          // æ¨¡æ¿å…ƒç´ 
  candidateElements: UIElement[];      // å€™é€‰å…ƒç´ 
  matchResults: StructuralMatchResult[]; // åŒ¹é…ç»“æœ
  visualConfig: {
    showScores: boolean;               // æ˜¾ç¤ºåˆ†æ•°
    highlightPassed: boolean;          // é«˜äº®é€šè¿‡çš„å…ƒç´ 
    colorByScore: boolean;             // æŒ‰åˆ†æ•°ç€è‰²
  };
}
```

---

## ğŸ”„ ä¸å¯è§†åŒ–åˆ†æçš„åä½œå…³ç³»

### **æ•°æ®æµå‘å¯¹æ¯”**

| åŠŸèƒ½æ¨¡å— | æ•°æ®æº | åˆ†æé‡ç‚¹ | è¾“å‡ºäº§ç‰© |
|---------|--------|----------|----------|
| **æ™ºèƒ½è‡ªåŠ¨é“¾** | XMLç¼“å­˜ | Step 0-6ç­–ç•¥åˆ†æ | ç­–ç•¥å€™é€‰ + ç½®ä¿¡åº¦ |
| **ç»“æ„åŒ¹é…** | å…ƒç´ ç»“æ„ | å­—æ®µçº§ç²¾ç»†åŒ¹é… | è¯„åˆ†æ˜ç»† + åŒ¹é…çŠ¶æ€ |

### **åä½œåœºæ™¯**

```typescript
// åœºæ™¯1ï¼šæ™ºèƒ½è‡ªåŠ¨é“¾åˆ†æåï¼Œä½¿ç”¨ç»“æ„åŒ¹é…éªŒè¯
async function hybridAnalysis(element: UIElement) {
  // 1. æ™ºèƒ½è‡ªåŠ¨é“¾åˆ†æ
  const strategyCandidates = await useUnifiedSmartAnalysis.createAndAnalyze({
    uid: element.id,
    xpath: element.xpath,
    text: element.text
  });
  
  // 2. ç»“æ„åŒ¹é…éªŒè¯
  const structuralMatch = await evaluateStructuralMatch(
    structuralConfig,
    templateElement,
    element
  );
  
  // 3. ç»¼åˆå†³ç­–
  const finalConfidence = calculateHybridConfidence(
    strategyCandidates,
    structuralMatch
  );
}
```

---

## ğŸ¯ ç»“æ„åŒ¹é…çš„ç‹¬ç‰¹ä»·å€¼

### **1. ç»†ç²’åº¦æ§åˆ¶**
- **å­—æ®µçº§é…ç½®**ï¼šæ¯ä¸ªå­—æ®µç‹¬ç«‹é…ç½®æƒé‡å’Œç­–ç•¥
- **ç­–ç•¥å¤šæ ·æ€§**ï¼š6ç§åŒ¹é…ç­–ç•¥é€‚åº”ä¸åŒåœºæ™¯
- **é˜ˆå€¼å¯è°ƒ**ï¼šå…¨å±€é˜ˆå€¼ç²¾ç¡®æ§åˆ¶åŒ¹é…ä¸¥æ ¼åº¦

### **2. ä¸šåŠ¡åœºæ™¯é€‚é…**
- **"éƒ½éç©ºå°±è¡Œ"**ï¼šé€‚ç”¨äºå†…å®¹åŒ¹é…ï¼Œä¸è¦æ±‚å®Œå…¨ä¸€è‡´
- **"ä¿æŒç©º/éç©ºä¸€è‡´"**ï¼šé€‚ç”¨äºç»“æ„å®Œæ•´æ€§æ£€æŸ¥
- **"å€¼ç›¸ä¼¼åŒ¹é…"**ï¼šé€‚ç”¨äºå…è®¸ä¸€å®šå·®å¼‚çš„åœºæ™¯

### **3. é«˜ç²¾åº¦è¯„åˆ†**
- **åˆ†é¡¹è¯„åˆ†**ï¼šæ¯ä¸ªå­—æ®µç‹¬ç«‹è¯„åˆ†ï¼Œä¾¿äºè°ƒè¯•
- **æƒé‡åˆ†é…**ï¼šé‡è¦å­—æ®µæƒé‡é«˜ï¼Œæ¬¡è¦å­—æ®µæƒé‡ä½
- **é€æ˜å†³ç­–**ï¼šè¯„åˆ†è¿‡ç¨‹å®Œå…¨å¯è¿½æº¯

### **4. å¯è§†åŒ–éªŒè¯**
- **å®æ—¶é¢„è§ˆ**ï¼šé…ç½®ä¿®æ”¹åç«‹å³çœ‹åˆ°åŒ¹é…æ•ˆæœ
- **åˆ†æ•°å±•ç¤º**ï¼šç›´è§‚æ˜¾ç¤ºæ¯ä¸ªå€™é€‰å…ƒç´ çš„åŒ¹é…åˆ†æ•°
- **é¢œè‰²ç¼–ç **ï¼šé€šè¿‡é¢œè‰²å¿«é€Ÿè¯†åˆ«åŒ¹é…è´¨é‡

---

## ğŸ”— ä¸æ™ºèƒ½è‡ªåŠ¨é“¾çš„å·®å¼‚åŒ–å®šä½

| ç»´åº¦ | æ™ºèƒ½è‡ªåŠ¨é“¾ | ç»“æ„åŒ¹é… |
|------|-----------|----------|
| **åˆ†ææ·±åº¦** | 6å±‚ç­–ç•¥åˆ†æ | 6å­—æ®µç²¾ç»†è¯„åˆ† |
| **é€‚ç”¨åœºæ™¯** | å…ƒç´ å®šä½å’Œè¯†åˆ« | ç»“æ„ç›¸ä¼¼æ€§éªŒè¯ |
| **é…ç½®å¤æ‚åº¦** | è‡ªåŠ¨åŒ–ç¨‹åº¦é«˜ | æ‰‹åŠ¨é…ç½®ç²¾ç¡® |
| **è¾“å‡ºé‡ç‚¹** | å®šä½ç­–ç•¥æ¨è | åŒ¹é…è¯„åˆ†æ˜ç»† |
| **ä½¿ç”¨æ—¶æœº** | å…ƒç´ é€‰æ‹©ç¡®è®¤å | éœ€è¦ç²¾ç¡®åŒ¹é…æ—¶ |

ç»“æ„åŒ¹é…åŠŸèƒ½æä¾›äº†**æ¯”æ™ºèƒ½è‡ªåŠ¨é“¾æ›´ç²¾ç»†ã€æ›´å¯æ§çš„åŒ¹é…èƒ½åŠ›**ï¼Œæ˜¯æ™ºèƒ½åˆ†æä½“ç³»ä¸­çš„é‡è¦è¡¥å……ï¼