# ğŸ”§ ç»“æ„åŒ¹é…ï¼šå‰åç«¯åˆ†å·¥è¯¦è§£

## ğŸ¯ æ ¸å¿ƒåˆ†å·¥åŸåˆ™

ç»“æ„åŒ¹é…åŠŸèƒ½é‡‡ç”¨**å‰ç«¯é…ç½® + åç«¯è®¡ç®—**çš„æ··åˆæ¶æ„ï¼š

- **å‰ç«¯è´Ÿè´£**ï¼šé…ç½®ç•Œé¢ã€é¢„è§ˆè®¡ç®—ã€æ•°æ®å‡†å¤‡
- **åç«¯è´Ÿè´£**ï¼šç²¾ç¡®è¯„åˆ†ã€ç­–ç•¥æ‰§è¡Œã€å¤æ‚è®¡ç®—

---

## ğŸ“‹ è¯¦ç»†å‰åç«¯èŒè´£åˆ†å·¥

### **å‰ç«¯ (TypeScript) èŒè´£**

#### **1. é…ç½®ç®¡ç†ä¸ç•Œé¢äº¤äº’**

```typescript
// src/modules/structural-matching/hooks/use-structural-preview.ts
export function useStructuralPreview({
  config,
  selectedElement,
}: UseStructuralPreviewProps) {
  
  // ğŸ¨ å‰ç«¯ï¼šç®€åŒ–é¢„è§ˆè®¡ç®—
  const fieldResults = useMemo((): FieldMatchResult[] => {
    return config.fields.map(field => {
      // âš¡ å‰ç«¯å¿«é€Ÿä¼°ç®—ï¼Œç”¨äºå®æ—¶é¢„è§ˆ
      switch (field.fieldType) {
        case FieldType.RESOURCE_ID:
          if (selectedElement['resource-id']) {
            score = field.scoringRules.bothNonEmpty * field.weight;
            reason = 'æœ‰resource-idï¼Œé¢„è®¡å¾—åˆ†';
          }
          break;
        // ... å…¶ä»–å­—æ®µç±»å‹çš„ç®€åŒ–è®¡ç®—
      }
    });
  }, [config.fields, selectedElement]);
}
```

**å‰ç«¯ç‰¹æ€§**ï¼š
- ğŸ¨ **å®æ—¶é¢„è§ˆ**ï¼šç”¨æˆ·è°ƒæ•´é…ç½®æ—¶ç«‹å³æ˜¾ç¤ºé¢„ä¼°æ•ˆæœ
- âš¡ **å¿«é€Ÿä¼°ç®—**ï¼šç®€åŒ–çš„è¯„åˆ†é€»è¾‘ï¼Œå“åº”é€Ÿåº¦å¿«
- ğŸ›ï¸ **é…ç½®ç•Œé¢**ï¼šå­—æ®µæƒé‡ã€ç­–ç•¥é€‰æ‹©ã€é˜ˆå€¼è°ƒèŠ‚
- ğŸ“Š **å¯è§†åŒ–**ï¼šåˆ†æ•°å±•ç¤ºã€é¢œè‰²ç¼–ç ã€åŒ¹é…çŠ¶æ€

#### **2. æ•°æ®å‡†å¤‡ä¸æœåŠ¡è°ƒç”¨**

```typescript
// src/modules/structural-matching/services/structural-matching-service.ts
export async function evaluateStructuralMatch(
  config: StructuralMatchingConfig,
  templateElement: any,
  targetElement: any,
): Promise<StructuralMatchResult> {
  
  // ğŸ”— å‰ç«¯ï¼šå‡†å¤‡æ•°æ®å¹¶è°ƒç”¨åç«¯
  const result = await invoke<StructuralMatchResult>('evaluate_structural_match', {
    config,           // å‰ç«¯é…ç½®çš„å­—æ®µç­–ç•¥
    templateElement,  // æ¨¡æ¿å…ƒç´ æ•°æ®
    targetElement,    // ç›®æ ‡å…ƒç´ æ•°æ®
  });
  
  return result;
}
```

**å‰ç«¯æ•°æ®å‡†å¤‡**ï¼š
- ğŸ“ **é…ç½®å¯¹è±¡**ï¼šç”¨æˆ·åœ¨ç•Œé¢ä¸­é…ç½®çš„å­—æ®µç­–ç•¥
- ğŸ¯ **å…ƒç´ æ•°æ®**ï¼šä»å¯è§†åŒ–ç•Œé¢é€‰æ‹©çš„å…ƒç´ ç»“æ„
- ğŸ”„ **æ‰¹é‡å¤„ç†**ï¼šå‡†å¤‡å¤šä¸ªå€™é€‰å…ƒç´ çš„æ•°æ®

---

### **åç«¯ (Rust) èŒè´£**

#### **1. ç²¾ç¡®è¯„åˆ†å¼•æ“**

```rust
// src-tauri/src/domain/structural_matching/structural_scorer.rs
impl StructuralScorer {
    pub fn evaluate(
        config: &StructuralMatchingConfig,
        template_element: &Value,
        target_element: &Value,
    ) -> StructuralMatchResult {
        
        // ğŸ¯ åç«¯ï¼šç²¾ç¡®è¯„åˆ†è®¡ç®—
        for field_config in config.enabled_fields() {
            // 1. æå–å­—æ®µå€¼
            let template_value = Self::extract_field_value(template_element, field_config.field_type);
            let target_value = Self::extract_field_value(target_element, field_config.field_type);
            
            // 2. è·å–ä¸“ç”¨è¯„åˆ†å™¨
            let scorer = get_field_scorer(field_config.field_type);
            
            // 3. æ‰§è¡Œç²¾ç¡®è¯„åˆ†
            let result = scorer.score(&template_value, &target_value, field_config);
            
            // 4. åº”ç”¨æƒé‡å’Œç­–ç•¥
            total_score += result.score * field_config.weight;
        }
    }
}
```

#### **2. å­—æ®µä¸“ç”¨è¯„åˆ†å™¨**

```rust
// src-tauri/src/domain/structural_matching/field_scorer.rs
impl UniversalFieldScorer {
    fn calculate_score_by_strategy(
        &self,
        template_str: &str,
        target_str: &str,
        strategy: MatchStrategy,
        scoring_rules: &ScoringRules,
        field_type: FieldType,
    ) -> (f64, bool, String) {
        
        // ğŸ§  åç«¯ï¼šå¤æ‚ç­–ç•¥ç®—æ³•
        match strategy {
            MatchStrategy::ExactMatch => self.exact_match_strategy(template_str, target_str, scoring_rules),
            MatchStrategy::BothNonEmpty => self.both_non_empty_strategy(template_str, target_str, scoring_rules),
            MatchStrategy::ConsistentEmptiness => self.consistent_emptiness_strategy(template_str, target_str, scoring_rules),
            MatchStrategy::ValueSimilarity => self.value_similarity_strategy(template_str, target_str, scoring_rules),
            MatchStrategy::StructureMatch => self.structure_match_strategy(template_str, target_str, scoring_rules),
        }
    }
}
```

**åç«¯ç®—æ³•ç‰¹æ€§**ï¼š
- ğŸ¯ **ç²¾ç¡®è®¡ç®—**ï¼šå¤æ‚çš„åŒ¹é…ç­–ç•¥ç®—æ³•
- ğŸ”¬ **ç»†ç²’åº¦åˆ†æ**ï¼šæ¯ä¸ªå­—æ®µç±»å‹çš„ä¸“ç”¨å¤„ç†é€»è¾‘
- âš–ï¸ **æƒé‡åº”ç”¨**ï¼šç²¾ç¡®çš„æƒé‡è®¡ç®—å’Œå¾—åˆ†ç´¯ç§¯
- ğŸ—ï¸ **ç»“æ„åˆ†æ**ï¼šå­å…ƒç´ ç»“æ„çš„æ·±åº¦æ¯”è¾ƒ

#### **3. Tauri å‘½ä»¤æ¥å£**

```rust
// src-tauri/src/commands/structural_matching.rs
#[command]
pub async fn evaluate_structural_match(
    config: StructuralMatchingConfig,
    template_element: Value,
    target_element: Value,
) -> Result<StructuralMatchResult, String> {
    
    // ğŸš€ åç«¯ï¼šå‘½ä»¤å…¥å£
    let result = StructuralScorer::evaluate(&config, &template_element, &target_element);
    
    println!("âœ… [StructuralMatching] è¯„ä¼°å®Œæˆï¼Œå¾—åˆ†: {:.2} / {:.2}, é€šè¿‡: {}",
        result.total_score, result.max_score.unwrap_or(0.0), result.passed);
    
    Ok(result)
}
```

---

## ğŸ”„ å‰åç«¯åä½œæµç¨‹

### **æ•°æ®æµå‘å›¾**

```mermaid
sequenceDiagram
    participant UI as ğŸ¨å‰ç«¯ç•Œé¢
    participant PC as âš™ï¸å‰ç«¯é¢„è§ˆè®¡ç®—
    participant TS as ğŸ”—TauriæœåŠ¡
    participant RS as ğŸ¦€Rustè¯„åˆ†å™¨
    participant FS as ğŸ“å­—æ®µè¯„åˆ†å™¨

    UI->>UI: ç”¨æˆ·é…ç½®å­—æ®µç­–ç•¥
    UI->>PC: è§¦å‘å®æ—¶é¢„è§ˆ
    PC->>PC: ç®€åŒ–è¯„åˆ†ä¼°ç®—
    PC-->>UI: æ˜¾ç¤ºé¢„ä¼°ç»“æœ
    
    UI->>UI: ç”¨æˆ·ç¡®è®¤é…ç½®
    UI->>TS: evaluateStructuralMatch()
    TS->>RS: StructuralScorer::evaluate()
    
    loop æ¯ä¸ªå¯ç”¨å­—æ®µ
        RS->>FS: get_field_scorer()
        FS->>FS: æ‰§è¡Œç²¾ç¡®ç­–ç•¥ç®—æ³•
        FS-->>RS: è¿”å›å­—æ®µå¾—åˆ†
    end
    
    RS->>RS: ç´¯ç§¯æ€»åˆ†+åº”ç”¨é˜ˆå€¼
    RS-->>TS: è¿”å›å®Œæ•´ç»“æœ
    TS-->>UI: ç²¾ç¡®è¯„åˆ†ç»“æœ
    UI->>UI: æ›´æ–°æ˜¾ç¤º+å¯è§†åŒ–
```

### **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**

1. **å‰ç«¯é¢„è§ˆ**ï¼šå¿«é€Ÿå“åº”ï¼Œç”¨äºé…ç½®è°ƒè¯•
2. **åç«¯ç²¾ç¡®è®¡ç®—**ï¼šå¤æ‚ç®—æ³•ï¼Œç”¨äºæœ€ç»ˆç»“æœ
3. **æ‰¹é‡å¤„ç†**ï¼šåç«¯æ”¯æŒæ‰¹é‡è¯„ä¼°ï¼Œå‡å°‘IPCè°ƒç”¨
4. **ç¼“å­˜æœºåˆ¶**ï¼šå‰ç«¯ç¼“å­˜é…ç½®ï¼Œé¿å…é‡å¤è®¡ç®—

---

## ğŸ¯ å…³é”®è®¾è®¡ä¼˜åŠ¿

### **1. èŒè´£åˆ†ç¦»æ¸…æ™°**

| å±‚é¢ | å‰ç«¯ TypeScript | åç«¯ Rust |
|------|---------------|-----------|
| **é€Ÿåº¦** | å¿«é€Ÿé¢„è§ˆ | ç²¾ç¡®è®¡ç®— |
| **å¤æ‚åº¦** | ç®€åŒ–é€»è¾‘ | å®Œæ•´ç®—æ³• |
| **ç”¨é€”** | é…ç½®è°ƒè¯• | æœ€ç»ˆè¯„åˆ† |
| **æ•°æ®** | ç•Œé¢çŠ¶æ€ | æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ |

### **2. ç”¨æˆ·ä½“éªŒä¼˜åŒ–**

```typescript
// å‰ç«¯ï¼šå³æ—¶åé¦ˆ
const displayInfo = useMemo(() => {
  return {
    percentage: percentage.toFixed(1),           // å®æ—¶ç™¾åˆ†æ¯”
    scoreText: `${totalScore} / ${maxScore}`,    // å®æ—¶åˆ†æ•°
    statusText: passed ? 'é¢„è®¡é€šè¿‡' : 'é¢„è®¡ä¸é€šè¿‡', // å®æ—¶çŠ¶æ€
    statusColor: passed ? '#52c41a' : '#ff4d4f'   // å®æ—¶é¢œè‰²
  };
}, [totalResult]);

// åç«¯ï¼šç²¾ç¡®ç»“æœ
let result = StructuralMatchResult {
  total_score: 87.5,          // ç²¾ç¡®åˆ†æ•°
  max_score: Some(100.0),     // æœ€å¤§åˆ†æ•°  
  passed: true,               // ç¡®åˆ‡çŠ¶æ€
  field_results: [            // è¯¦ç»†åˆ†æ
    { field_type: Text, score: 0.8, reason: "å€¼å®Œå…¨åŒ¹é…" },
    { field_type: ResourceId, score: 0.6, reason: "éƒ½éç©ºé€šè¿‡" }
  ]
};
```

### **3. ç®—æ³•å¤æ‚åº¦åˆ†å±‚**

```rust
// åç«¯ï¼šå¤æ‚ç­–ç•¥å®ç°
fn both_non_empty_strategy(&self, template: &str, target: &str, rules: &ScoringRules) -> (f64, bool, String) {
    match (template.is_empty(), target.is_empty()) {
        (false, false) => (rules.both_non_empty, true, "éƒ½éç©ºé€šè¿‡".to_string()),
        (true, true) => (rules.both_empty * 0.5, false, "éƒ½ä¸ºç©ºï¼Œä¸ç¬¦åˆéç©ºè¦æ±‚".to_string()),
        _ => (rules.mismatch_penalty, false, "åªæœ‰ä¸€ä¸ªéç©º".to_string()),
    }
}
```

```typescript
// å‰ç«¯ï¼šç®€åŒ–é¢„è§ˆé€»è¾‘
if (selectedElement['resource-id']) {
  score = field.scoringRules.bothNonEmpty * field.weight;
  reason = 'æœ‰resource-idï¼Œé¢„è®¡å¾—åˆ†';
  matched = true;
} else {
  score = field.scoringRules.bothEmpty * field.weight;
  reason = 'æ— resource-idï¼Œç©ºåŒ¹é…å¾—åˆ†';
  matched = true;
}
```

---

## ğŸ“Š æ€§èƒ½å¯¹æ¯”

| æŒ‡æ ‡ | å‰ç«¯é¢„è§ˆ | åç«¯ç²¾ç¡®è®¡ç®— |
|------|----------|------------|
| **å“åº”é€Ÿåº¦** | <50ms | 100-300ms |
| **è®¡ç®—ç²¾åº¦** | é¢„ä¼°å€¼ | ç²¾ç¡®å€¼ |
| **ç­–ç•¥æ”¯æŒ** | ç®€åŒ–ç‰ˆ | å®Œæ•´ç‰ˆ |
| **æ‰¹é‡å¤„ç†** | ä¸æ”¯æŒ | æ”¯æŒ |
| **å¤æ‚ç»“æ„** | åŸºç¡€åˆ†æ | æ·±åº¦åˆ†æ |

---

## ğŸ‰ æ€»ç»“

ç»“æ„åŒ¹é…åŠŸèƒ½é‡‡ç”¨äº†**æ™ºèƒ½çš„å‰åç«¯æ··åˆæ¶æ„**ï¼š

âœ… **å‰ç«¯ä¸“æ³¨ä½“éªŒ**ï¼šå¿«é€Ÿé¢„è§ˆã€å®æ—¶åé¦ˆã€é…ç½®ç•Œé¢  
âœ… **åç«¯ä¸“æ³¨ç²¾åº¦**ï¼šå¤æ‚ç®—æ³•ã€ç²¾ç¡®è®¡ç®—ã€ç­–ç•¥æ‰§è¡Œ  
âœ… **æ€§èƒ½æœ€ä¼˜åŒ–**ï¼šé¢„è§ˆç”¨å‰ç«¯ï¼Œç»“æœç”¨åç«¯  
âœ… **èŒè´£æ¸…æ™°**ï¼šç•Œé¢é€»è¾‘å’Œä¸šåŠ¡é€»è¾‘å®Œå…¨åˆ†ç¦»  

è¿™ç§è®¾è®¡æ—¢ä¿è¯äº†**ç”¨æˆ·ä½“éªŒçš„æµç•…æ€§**ï¼Œåˆç¡®ä¿äº†**è®¡ç®—ç»“æœçš„å‡†ç¡®æ€§**ï¼