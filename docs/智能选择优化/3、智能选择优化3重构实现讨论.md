基于我的最新 git 上传的架构， 应该如何修改成 满足新的需求？ 是重构还是只需要原来基础上改一下？

结论先说：**不需要推倒重来**。在你现有架构上做一组“**兼容式小步重构**”（协议统一 + 模块拆分 + 快路径实现 + 受控回退），就能满足新需求，并兼容你现有的步骤卡片/V2 执行链。

下面给一份“改什么、改到哪、怎么接”的工程化清单（不赘述实现细节代码，但指到具体层位和对象）。

---

# A. 统一协议（一步到位，保留兼容）

### 1) StepCard 扩展（前端产生、后端消费）

在“三要素”不变的前提下，加这些字段（旧卡片仍能跑；缺省就走旧路径）：

```jsonc
{
  "xml_snapshot": "...",
  "absolute_xpath": "...",
  "strategy": {
    "selected": { "kind": "RegionTextToParent", "...": "..." },
    "plan": [
      // 有序候选链：强→弱
      { "id": "v1", "kind": "SelfId", "...": "..." },
      { "id": "v2", "kind": "RegionTextToParent", "...": "..." },
      { "id": "v3", "kind": "RegionLocalIndexWithCheck", "...": "..." }
    ],
    "recommended_index": 1
  },
  "selection": {
    "mode": "match-original|first|last|random|all",
    "order": "by-visual-yx",             // 稳定排序：y→x
    "interval_ms": 250,                  // 仅在 all 模式
    "stop_on_fail": false
  },
  "limits": {
    "allow_backend_fallback": true,
    "time_budget_ms": 1200,
    "per_candidate_budget_ms": 180,
    "strict_mode": false
  },
  "matching_context": {
    "container_xpath": "...",            // 限域
    "clickable_parent_xpath": "...",     // 统一落点
    "i18n_alias": ["关注","+关注","Follow"],
    "light_assertions": {
      "must_contain_text": ["关注","+关注","Follow"],
      "must_be_clickable": true
    },
    "fingerprint": {
      "class_chain": ["LinearLayout","TextView"],
      "resource_id_suffix": "content",
      "text_hash": "…",
      "bounds_signature": {"x":0.82,"y":0.12,"area":0.03}
    }
  }
}
```

> 这样，**旧卡片**只带 `absolute_xpath` 时仍可跑（后端兜底兼容）；**新卡片**则完整携带策略链与选择模式。

### 2) 后端请求结构（Tauri 命令）

`run_step_v2` 的 `RunStepRequestV2` 增加：

* `strategy.selected`、`strategy.plan[]`
* `selection.*`
* `limits.*`
* `matching_context.*`

> 兼容策略：若 `strategy` 缺省，沿用你现在的“selector id → store 查策略”与“absolute_xpath 兜底”。

---

# B. 前端改动（React）——“离线评估 + 可视化”

### 1) 模块划分

* `LocalAnalyzer`（新增）：对**缓存 XML**做智能评估，产出 **plan + recommended_index**、`matching_context`（容器、可点父、i18n、fingerprint、assertions）。
* `StepCard Orchestrator`（增强）：点击“确定”→ 直接生成扩展后的 StepCard；卡片 UI 可切换 `strategy.selected` & `selection.mode`。
* `StepExecutionGateway.ts`（协议对齐）：将扩展后的 StepCard 透传给 Tauri `run_step_v2`。

  * 兼容逻辑：若无 `strategy` 字段，填充“仅 absolute_xpath”的旧格式。

### 2) 具体文件（与你仓库命名对齐）

* `src/types/smartScript.ts`：定义 `StrategyVariant`, `StrategyPlan`, `SelectionConfig`, `MatchingContext`, `Limits`。
* `src/stores/ui-element-selection-store.ts`：在用户点选后，缓存**可点父**、**容器 XPath**、**子锚点**，供 `LocalAnalyzer` 使用。
* `src/components/StepCard/*`：增加“算法推荐 Step N”徽标、风险标签（如“全局索引/文本弱”）。

> 结果：前端生成的卡片“开箱即跑”，并且默认开启**match-original**（多实例“关注”默认命中**同一实例**）。

---

# C. 后端改动（Rust/Tauri）——“快路径 + 受控回退”

### 1) run_step_v2.rs 拆分

* `device_dump`：真机 dump & parse（保持你现有实现，增加**可选缓存一帧**用在 all 模式）
* `live_analyzer`（新增）：

  * **限域**：优先在 `container_xpath` 内搜索
  * **候选生成**：按 `strategy.selected` 的 `kind` 生成命中集合
  * **唯一性与评分**：保留你已实现的“三态评分 + 置信度&间隔双重唯一性”，补齐 **容器节点拦截**
* `selector_executor`：实现各 `kind`（SelfId / RegionTextToParent / RegionLocalIndexWithCheck / NeighborRelative / GlobalIndexWithStrongChecks）
* `selection_resolver`：实现 `match-original|first|last|random|all`

  * **match-original**：用 `fingerprint` 在同类集合中找“同一实例”
  * **all**：一次 dump 预计算所有目标的**点击坐标列表**，**按 interval 逐一 tap**（不重复 dump）
* `fallback_manager`：若 `allow_backend_fallback`，在时间预算内按 `plan` 顺序快速尝试 2~4 个候选
* `action_performer`：你已有的 `safe_input_injector` 接口复用；加**点击前轻校验**（clickable, visible, 子树包含关键文本）

### 2) 保护与诊断

* **容器节点防呆**：命中 `ViewGroup/RecyclerView/...` 等“整屏/容器”直接拒绝执行
* **日志**：打印 `used_variant`、`match_count`、`confidence`、`gap`、`selection.mode`、`all_count`、`interval_ms`、`tap_times[]`
* **错误语义**：`NO_SELECTOR`（前端没给策略）/`NO_MATCH`/`MULTI_MATCH`/`CONTAINER_BLOCKED`/`ASSERT_FAIL`/`TIME_BUDGET_EXCEEDED`

> 结果：以**区域 + 等值**为主的**快路径**几乎总是“一跳命中”；少数漂移场景由**小预算回退**兜住。

---

# D. “多个关注按钮”的落地点

### 静态分析固化（前端）

* `matching_context.container_xpath`：页面级容器（如列表或底部栏）
* `clickable_parent_xpath`：统一落点节点
* `i18n_alias`：`["关注","+关注","Follow"]`
* `fingerprint`：用于 `match-original`
* `selection.mode`：默认 `match-original`；可切到 `first/last/random/all`
* `RegionTextToParent` 与 `RegionLocalIndexWithCheck` 两条候选**至少保一条**

### 真机执行（后端）

* 在容器内构建“同类关注按钮集合”
* **match-original** → 找与 `fingerprint` 最相近的那一个
* **first/last/random** → 按 y→x 稳定排序后取 1 个
* **all** → 一次 dump 算出全部坐标，按 `interval_ms` 逐一 tap（不重复 dump）

---

# E. 迁移顺序（安全小步）

1. **先改协议**（types/网关/request struct），确保**旧卡片**依然通过（兼容兜底）。
2. 前端落 `LocalAnalyzer`，卡片开始带上 `strategy.plan`、`matching_context`、`selection`。
3. 后端把 `run_step_v2` 改为：**优先执行 `strategy.selected` →（可选）回退 plan**。
4. 打通 “all 模式一次 dump 批量点击”。
5. 加护栏（容器拦截、轻校验）与日志。
6. 增补用例：

   * 多个“关注”按钮（5 种选择模式）
   * 容器缺失/文本变更/语言切换
   * 绝对 XPath 兜底（仅在你显式开启时）

---

# F. 你现有代码触点（按之前对话中的文件）

* **前端**

  * `src/types/smartScript.ts`：补协议类型
  * `src/stores/ui-element-selection-store.ts`：存容器/父/锚点信息
  * `src/infrastructure/gateways/StepExecutionGateway.ts`：请求体扩展（保兼容）
  * `StepCard` 相关组件：加“推荐策略/模式切换/风险标签”

* **后端（Tauri）**

  * `src-tauri/src/commands/run_step_v2.rs`：重构为 orchestrator + analyzer + executor + fallback
  * `src-tauri/src/commands/intelligent_analysis.rs`：若仍承担 selector 产出，返回完整 `StrategyPlan` 与 `MatchingContext`
  * 复用：`infra::adb::safe_input_injector`、`adb_utils`、`adb_device_tracker`（无需大改）

---

## 要点回顾

* 这是**兼容式小步重构**：**统一协议** + **最小必要模块拆分** + **快路径优先** + **受控回退**。
* 静态分析把**容器/可点父/锚点/指纹/别名/断言/选择模式**都固化到 StepCard；真机只需“拿来就跑”。
* “多个关注按钮”是第一类目标场景，`match-original`（默认）+ 4 种模式切换全部覆盖。

需要的话，我可以把 **StrategyVariant/Plan/MatchingContext** 的 JSON 规范写成一页 `docs/STRATEGY_PROTOCOL.md`，以及给 `run_step_v2.rs` 和 `StepExecutionGateway.ts` 写一版**最小骨架**（保持你仓库命名风格）。
