我的执行逻辑是，  我在静态分析 xml 文件的时候，点选这个关注按钮， 然后 智能自动链 能重新找到我这个关注按钮。而不会被其他误导。

然后我可以增加一些功能， 
就是让智能自动链 
1、匹配原来的关注按钮，
2、返回 选择同类的第一个\最后一个，
3、返回随机一个
4、返回一个候选集合/点选全部

真机执行的时候， 根据这些额外参数，进行不同策略的执行。
当仅返回一个的时候，真机直接点选。
当返回是所有同类 关注按钮的时候，
真机逐一点击，不重新dump，而是逐一进行点击
前端最好能设置这种集合的点击间隙时间。

你觉得这样够全面了吗？这个架构应该是怎么更好？

超清晰版来啦——把你要的“关注按钮多实例”的四种玩法，整理成一套**可落地的架构**，包括前端静态分析要固化什么、后端真机怎么跑、以及需要的“安全护栏”。（不贴代码，直接给开发能用的规格）

---

# 你要的 4 种玩法（选择策略）

1. **match-original**：只匹配你当时点选的“那个”关注按钮
2. **first / last**：在同类候选里取第一个 / 最后一个
3. **random**：在同类候选里随机取一个（可设随机种子）
4. **all**：返回同类候选的集合，真机逐一点击（带间隔）

---

# StepCard 需要新增/固化的关键字段（前端产出）

在“静态分析 → 点确定 → 生成步骤卡片”时，除了你已有的三要素，再**固化下列元数据**，保证真机能100%复现你的决策链。

### A. 锚定与归一（定位“同类”与“可点父”）

* `anchor.container_xpath`：稳定容器（如列表/底部栏/卡片祖先）
* `anchor.target_xpath`：你当时点的那个叶子（常是 TextView/Icon）
* `anchor.clickable_parent_xpath`：该叶子的**最近 `clickable=true` 父**（真正要点的节点）
* `anchor.fingerprint`：轻指纹（class、id 后缀、文本哈希、相对索引、bounds 比例等）
* `selection.query`：**同类查询表达式**（如何把“多个关注按钮”这一类捞出来）

  * 例：`".//TextView[text ∈ {'关注','+关注','Follow'}] -> up(clickable parent)"`

### B. 选择策略（四种玩法）

* `selection.mode`: `"match-original" | "first" | "last" | "random" | "all"`
* `selection.order`: `"stable_yx"`（按 y→x 稳定排序；也可 `"dom"`）
* `selection.shuffle_seed`（仅 random）
* `selection.max_count`（用于 all，限制最多点击多少个）
* `selection.filters.state`：过滤掉**已关注/关注中**等状态（避免误点）

  * 例：`exclude_text ∈ {'已关注','关注中','Following'}`

### C. 批量执行控制（真机端行为）

* `execution.batch.strategy`: `"precompute_coords"` 或 `"requery_each"`

  * **建议默认**：`"precompute_coords"`（只 dump 一次，先把所有要点的坐标算好，随后逐一点击）
* `execution.batch.interval_ms`: 每次点击的**间隔时间**（前端可配置）
* `execution.batch.jitter_ms`: 可选抖动，防机器人
* `execution.postcheck`: 点击后**状态校验**（文本变“已关注”/出现 Toast 等）
* `execution.stop_on_fail`: `true/false`（某次失败是否立刻停止）
* `execution.timeout_ms`: 总时间预算

> 这些字段让“静态分析做出的决策链”被**完整固化**到卡片里，后端只需按协议跑即可。

---

# 前端静态分析应当怎么做（离线阶段）

1. **可点父归一**
   你点到的可能是文本/图标；**上溯**到最近 `clickable=true` 的父，作为最终点击对象，并记录 `anchor.clickable_parent_xpath`。
2. **同类集合构建**
   在 `anchor.container_xpath` 里，用 `selection.query` 把**所有同类“关注”候选**找出来（含多语言同义词），并**过滤“已关注/关注中”**。
3. **稳定排序**
   对同类候选按 `y→x` 稳定排序（保证 first/last 的确定性；不同分辨率也一致）。
4. **预评估唯一性**

   * `match-original`：用 `anchor.fingerprint` 在集合里**复核**那一个；
   * `first/last/random/all`：预览集合大小，显示风控提示（>N 时提示谨慎）。
5. **固化三层证据**

   * `anchor.*`（精确原件）
   * `selection.query`（生成同类集合的方法）
   * `selection.order/filters`（你期望的获取/排序/过滤规则）

---

# 后端真机执行怎么跑（动态阶段）

## 统一两阶段：**收集** → **执行**

### 1) 收集（仅 dump 一次）

* **Dump** 真机 XML。
* **同类集合**：在 `anchor.container_xpath` 内执行 `selection.query`，得出候选列表。
* **过滤**：去掉已关注/不可见/不可点的项。
* **排序**：按 `selection.order` 稳定排序。
* **定位原件**（仅 match-original）：用 `anchor.fingerprint` 在集合中找到“同一实例”（距离+属性一致性），找不到就 fail（或退化到最近邻）。
* **子集选择**：

  * `match-original` → 只保留该项
  * `first/last` → 取第1/最后1个
  * `random` → 用 `selection.shuffle_seed` 抽1个
  * `all` → 截断到 `selection.max_count`
* **坐标预计算**：对选中的目标**一次性**算出中心点坐标，缓存。

> 这一步完成后，有一组**最终要点**的坐标列表，且**不再需要 re-dump**（你的要求）。

### 2) 执行（批量点击）

* 遍历坐标列表：

  * 可选：`scrollIntoView`（若不在可见区域；如“all”要跨多屏则需分页设计，见“扩展”）
  * `adb tap(x,y)`
  * **后置校验**（`execution.postcheck`）：文本变“已关注”、出现 Toast 等
  * 间隔 `execution.batch.interval_ms + jitter`
  * `stop_on_fail=true` 时遇错立即停
* 返回：命中数量、跳过数量（已是“已关注”）、失败原因、总耗时、截图（可选）

---

# 这样设计的优点 & 你提案中的关键改进

**你提的四种模式完全可行**，但要加上这几条“护栏”，效果会更稳：

1. **容器限域 + 可点父归一**
   避免“同名按钮”跨区误点；确保真正点在可点父上。
2. **状态过滤**
   点击前先排除“已关注/关注中”，避免反复切换或撤销。
3. **稳定排序**
   保证 first/last 在不同设备/分辨率下一致。
4. **一次 dump，批量预计算坐标**
   满足你“all 模式不重 dump”；若 UI 会在点击后“局部刷新”，也能靠**预先坐标**不被干扰。
5. **后置校验**
   点击后快速确认状态变化；失败则记录并按策略决定是否继续。
6. **批量节流**
   前端可设间隔（含抖动），减少被风控/人机识别。

---

# 可能的坑 & 如何处理

* **点击后列表重排/视图回收**：
  “all”模式下，第一次点击后顺序或布局改变，**但我们已预先取坐标**，不受影响；若页面强制刷新导致坐标失效，可允许 `execution.batch.strategy: "requery_each"`（代价是每次都轻量 re-query，不是完整 re-dump）。
* **分页/虚拟列表**：
  “all”跨多屏需要**分页策略**：每屏“收集→执行”，滚动一屏再“收集→执行”。这时必须**小幅 re-dump 或区域 re-query**，否则拿不到下一屏元素。
* **防误点**：
  若某项“关注”变“已关注”，后置校验 OK；若没有变化 → 计为失败，遵从 `stop_on_fail`。
* **随机选择**：
  必须配 `shuffle_seed`，以便复现；并确保在**过滤后**再随机。

---

# 最小落地规格（字段清单，一览）

**StepCard.parameters**（新增）：

```json
{
  "anchor": {
    "container_xpath": "...",
    "target_xpath": "...",
    "clickable_parent_xpath": "...",
    "fingerprint": { "class":"...", "rid_suffix":"...", "text_hash":"...", "rel_index":2, "bounds_ratio":[...] }
  },
  "selection": {
    "mode": "match-original | first | last | random | all",
    "query": "descendant text aliases + up(clickable parent)",
    "order": "stable_yx",
    "shuffle_seed": 12345,
    "max_count": 20,
    "filters": { "exclude_text": ["已关注","关注中","Following"] }
  },
  "execution": {
    "batch": { "strategy": "precompute_coords", "interval_ms": 300, "jitter_ms": 80 },
    "postcheck": { "expect_text_any_of": ["已关注","关注中","Following","互相关注"] },
    "stop_on_fail": false,
    "timeout_ms": 120000
  }
}
```

---

# 结论

* 你的思路“**单个/首尾/随机/全部**”很全面了。
* 真正让它**稳定可复现**的关键，是前端静态分析阶段**多固化三样东西**：
  **容器限域**、**可点父归一**、**同类集合的构造方法**；
  再配合后端**一次 dump 预采坐标 + 批量间隔点击 + 后置校验**。
* 若要覆盖“跨多屏全量关注”，加一层**分页批处理**即可（每屏微量 re-query 或轻量 re-dump）。

想要我把这份字段定义做成你项目的 **StepCard TypeScript 接口**和 **Rust 端解析/执行清单**吗？你可以直接贴到代码库做对齐。
