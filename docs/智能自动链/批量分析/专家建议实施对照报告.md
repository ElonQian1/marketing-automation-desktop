# ğŸ“Š ä¸“å®¶å»ºè®®å®æ–½å¯¹ç…§æŠ¥å‘Š

> **ç”Ÿæˆæ—¶é—´**ï¼š2025å¹´10æœˆ25æ—¥  
> **è¯„ä¼°å¯¹è±¡**ï¼šæ™ºèƒ½è‡ªåŠ¨é“¾ + æ™ºèƒ½é€‰æ‹©ç³»ç»Ÿ  
> **ä¸“å®¶å»ºè®®æ¥æº**ï¼šæ‰¹é‡æ‰§è¡Œå¢å¼ºæ¸…å•ï¼ˆ20æ¡å»ºè®®ï¼‰

---

## ğŸ¯ æ€»ä½“è¯„ä¼°

**æ‚¨æœ‹å‹çš„å»ºè®®éå¸¸æœ‰ä»·å€¼ï¼** è¿™äº›éƒ½æ˜¯**å®é™…è½åœ°å¿…å¤‡çš„å·¥ç¨‹åŒ–ç»†èŠ‚**ï¼Œä¸æ˜¯è¿‡åº¦è®¾è®¡ã€‚

å»ºè®®è¦†ç›–é¢ï¼š
- âœ… å·¥ç¨‹åŒ–ç»†èŠ‚ï¼ˆå»é‡ã€æ’åºã€å®¹é”™ï¼‰
- âœ… å¯è§‚æµ‹æ€§ï¼ˆæ—¥å¿—ã€æŒ‡æ ‡ã€è°ƒè¯•ï¼‰
- âœ… åé£æ§ï¼ˆèŠ‚å¥æŠ–åŠ¨ã€ç³»ç»Ÿåé¦ˆï¼‰
- âœ… ç¨³å®šæ€§ï¼ˆè½»æ ¡éªŒã€å¾®åˆ·æ–°ã€é¢„ç®—ç®¡ç†ï¼‰

---

## ğŸ“‹ è¯¦ç»†å®æ–½å¯¹ç…§è¡¨

### âœ… ç«‹åˆ»èƒ½ä¸Šçš„å¢å¼ºï¼ˆ7æ¡ï¼‰

#### 1ï¸âƒ£ é›†åˆæ´¾ç”Ÿå™¨ï¼ˆCollectorï¼‰åšæˆå¯æ’æ‹”

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **ç‹¬ç«‹ Collector æ¨¡å—** | âŒ **ç¼ºå¤±** | æœªæ‰¾åˆ°ç‹¬ç«‹çš„å€™é€‰æ´¾ç”Ÿå™¨æ¶æ„ |
| **å¯æ’æ‹”æ´¾ç”Ÿå™¨æ³¨å†Œç³»ç»Ÿ** | âŒ **ç¼ºå¤±** | æ²¡æœ‰ `desc-clickable`ã€`textâ†’clickable-parent` ç­‰å¯æ³¨å†Œæ´¾ç”Ÿå™¨ |
| **å»ç´¢å¼•/å» selected** | âŒ **ç¼ºå¤±** | å€™é€‰ç”Ÿæˆé€»è¾‘åœ¨ `SmartSelectionEngine::parse_xml_and_find_candidates`ï¼Œæ˜¯ç®€åŒ–å®ç° |
| **å®¹å™¨ä¿æŒ** | âœ… **éƒ¨åˆ†** | ç±»å‹å®šä¹‰æœ‰ `container_xpath`ï¼Œä½† `filter_by_container` æ˜¯ç®€åŒ–å®ç° |
| **è¯­ä¹‰é”šç‚¹** | âœ… **éƒ¨åˆ†** | æœ‰ `i18n_aliases` ç±»å‹å®šä¹‰ï¼Œä½†æœªè§å®é™…ä½¿ç”¨ |

**å®æ–½å»ºè®®**ï¼š
```rust
// å»ºè®®æ¶æ„
pub trait CandidateCollector {
    fn name(&self) -> &str;
    fn collect(&self, xml: &str, context: &MatchingContext) -> Vec<Candidate>;
    fn risk_score(&self) -> f32; // é£é™©è¯„åˆ†
}

// å¯æ’æ‹”æ´¾ç”Ÿå™¨
struct DescClickableCollector;     // æè¿°+å¯ç‚¹å‡»
struct TextToParentCollector;      // æ–‡æœ¬â†’å¯ç‚¹çˆ¶å…ƒç´ 
struct RegionScopedCollector;      // å®¹å™¨é™åŸŸ
struct SemanticAnchorCollector;    // è¯­ä¹‰é”šç‚¹ï¼ˆå¤šè¯­è¨€ï¼‰

// æ³¨å†Œä¸­å¿ƒ
struct CollectorRegistry {
    collectors: HashMap<String, Box<dyn CandidateCollector>>,
}
```

---

#### 2ï¸âƒ£ æ’é™¤å±‚é»˜è®¤å¼€å¯

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **i18n_alias ç»Ÿä¸€** | âœ… **ç±»å‹å®šä¹‰** | `MatchingContext` æœ‰ `i18n_aliases: Option<Vec<String>>` |
| **i18n_alias å®é™…ä½¿ç”¨** | âŒ **æœªå®ç°** | `parse_xml_and_find_candidates` ä¸­æœªè§å®é™…è¿‡æ»¤é€»è¾‘ |
| **exclude_selector** | âœ… **ç±»å‹å®šä¹‰** | `LightAssertions` æœ‰ `exclude_text: Option<Vec<String>>` |
| **exclude å®é™…ä½¿ç”¨** | âŒ **æœªå®ç°** | æ‰§è¡Œå¼•æ“ä¸­æœªè§æ’é™¤é€»è¾‘ |

**ä»£ç ä½ç½®**ï¼š
- ç±»å‹å®šä¹‰ï¼š`src-tauri/src/types/smart_selection.rs:129-135`
- å¾…å®ç°ï¼š`SmartSelectionEngine::parse_xml_and_find_candidates`

**å®æ–½å»ºè®®**ï¼š
```rust
// åœ¨å€™é€‰ç”Ÿæˆæ—¶åº”ç”¨æ’é™¤
fn apply_exclude_filter(
    candidates: Vec<CandidateElement>,
    exclude_patterns: &[String],
) -> Vec<CandidateElement> {
    candidates.into_iter()
        .filter(|c| {
            if let Some(text) = &c.element.text {
                !exclude_patterns.iter().any(|pattern| text.contains(pattern))
            } else {
                true
            }
        })
        .collect()
}
```

---

#### 3ï¸âƒ£ å»é‡ä¸ç¨³å®šæ’åºæ ‡å‡†åŒ–

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **dedupe_key ç”Ÿæˆ** | âŒ **ç¼ºå¤±** | æ— å»é‡é€»è¾‘ |
| **bounds.y(Â±é˜ˆå€¼) å»é‡** | âŒ **ç¼ºå¤±** | æœªè§ä½ç½®å®¹å·®å»é‡ |
| **é‚»è¿‘æ˜µç§°æ–‡æœ¬å»é‡** | âŒ **ç¼ºå¤±** | æœªè§æ–‡æœ¬ç»„åˆå»é‡ |
| **ç¨³å®šæ’åºï¼ˆyâ†’xï¼‰** | âœ… **å·²å®ç°** | `parse_xml_and_find_candidates` ä¸­æœ‰ yâ†’x æ’åºé€»è¾‘ |
| **å¯å¤ç°æ€§ä¿è¯** | âš ï¸ **éƒ¨åˆ†** | æ’åºæ˜¯ç¨³å®šçš„ï¼Œä½†ç¼ºå°‘å»é‡å¯èƒ½å¯¼è‡´é‡å¤ç‚¹å‡» |

**ä»£ç ä½ç½®**ï¼š
- æ’åºå®ç°ï¼š`smart_selection_engine.rs:205-226`

**å®æ–½å»ºè®®**ï¼š
```rust
// ç”Ÿæˆå»é‡é”®
fn generate_dedupe_key(element: &UIElement, tolerance: i32) -> String {
    let bounds = element.bounds.as_ref()
        .and_then(|b| ElementBounds::from_bounds_string(b));
    
    if let Some(b) = bounds {
        let y_bucket = ((b.top + b.bottom) / 2) / tolerance; // å®¹å·®åˆ†æ¡¶
        let text_key = element.text.as_deref().unwrap_or("");
        format!("y{}_{}", y_bucket, text_key)
    } else {
        element.text.clone().unwrap_or_default()
    }
}

// åº”ç”¨å»é‡
fn deduplicate_candidates(
    candidates: Vec<CandidateElement>,
    tolerance: i32,
) -> Vec<CandidateElement> {
    let mut seen = HashSet::new();
    candidates.into_iter()
        .filter(|c| {
            let key = generate_dedupe_key(&c.element, tolerance);
            seen.insert(key)
        })
        .collect()
}
```

---

#### 4ï¸âƒ£ ç‚¹å‡»åè½»æ ¡éªŒä½œä¸ºç¡¬é—¸

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **ValidationState ç±»å‹** | âœ… **å·²å®šä¹‰** | `smart_selection.rs:116-120` |
| **è½»æ ¡éªŒå®ç°** | âŒ **æœªå®ç°** | `execute_clicks` ä¸­æœªè§æ ¡éªŒé€»è¾‘ |
| **100-300ms å¤æŸ¥** | âŒ **æœªå®ç°** | ç‚¹å‡»åæ— å»¶è¿Ÿå¤æŸ¥ |
| **æ–‡æœ¬å˜åŒ–æ£€æµ‹** | âŒ **æœªå®ç°** | æ— "å…³æ³¨â†’å·²å…³æ³¨"æ£€æµ‹ |
| **æŒ‰é’®æ¶ˆå¤±æ£€æµ‹** | âŒ **æœªå®ç°** | æ— å…ƒç´ æ¶ˆå¤±æ£€æµ‹ |

**å®æ–½å»ºè®®**ï¼š
```rust
async fn verify_click_success(
    device_id: &str,
    original_element: &UIElement,
    expected_change: &str, // "å…³æ³¨" â†’ "å·²å…³æ³¨"
) -> bool {
    // ç­‰å¾… 100-300ms
    tokio::time::sleep(Duration::from_millis(200)).await;
    
    // é‡æ–° dump UI
    let ui_xml = match get_ui_dump(device_id).await {
        Ok(xml) => xml,
        Err(_) => return false,
    };
    
    // æ£€æŸ¥å…ƒç´ å˜åŒ–
    let elements = parse_ui_elements(&ui_xml).ok()?;
    
    // åœ¨åŸä½ç½®æŸ¥æ‰¾å…ƒç´ 
    if let Some(bounds_str) = &original_element.bounds {
        for elem in elements {
            if elem.bounds.as_ref() == Some(bounds_str) {
                // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦å˜åŒ–
                if let Some(text) = &elem.text {
                    return text.contains(expected_change);
                }
            }
        }
    }
    
    // å…ƒç´ æ¶ˆå¤±ä¹Ÿç®—æˆåŠŸ
    true
}
```

---

#### 5ï¸âƒ£ ä¸€æ¬¡ dump å¤šæ¬¡ç‚¹å‡»çš„"å¾®åˆ·æ–°ç­–ç•¥"

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **RefreshPolicy ç±»å‹** | âœ… **å·²å®šä¹‰** | `smart_selection.rs:231-239` (Never, OnMutation, EveryK, Always) |
| **RefreshPolicy å®ç°** | âŒ **æœªå®ç°** | `execute_clicks` ä¸­æœªä½¿ç”¨ |
| **æŒ‡çº¹é‡å®šä½** | âŒ **æœªå®ç°** | æ—  boundsÂ±é˜ˆå€¼ é‡å®šä½é€»è¾‘ |
| **å°é¢„ç®— re-dump** | âŒ **æœªå®ç°** | æ¯æ¬¡ç‚¹å‡»é—´éš”å›ºå®šï¼Œæ— æ™ºèƒ½åˆ·æ–° |

**ä»£ç ä½ç½®**ï¼š
- ç±»å‹å®šä¹‰ï¼š`src-tauri/src/types/smart_selection.rs:231-239`
- å¾…å®ç°ï¼š`SmartSelectionEngine::execute_clicks`

**å®æ–½å»ºè®®**ï¼š
```rust
async fn execute_clicks_with_refresh(
    device_id: &str,
    initial_candidates: Vec<CandidateElement>,
    refresh_policy: RefreshPolicy,
) -> Result<BatchExecutionResult> {
    let mut candidates = initial_candidates;
    let mut click_count = 0;
    
    for (index, candidate) in candidates.iter().enumerate() {
        // æ ¹æ®åˆ·æ–°ç­–ç•¥å†³å®šæ˜¯å¦é‡æ–°å®šä½
        let should_refresh = match &refresh_policy {
            RefreshPolicy::Never => false,
            RefreshPolicy::OnMutation => {
                // æ£€æµ‹UIæ˜¯å¦å˜åŒ–
                check_ui_mutation(device_id).await?
            }
            RefreshPolicy::EveryK { k } => {
                click_count % k == 0 && click_count > 0
            }
            RefreshPolicy::Always => true,
        };
        
        let target = if should_refresh {
            // é€šè¿‡æŒ‡çº¹é‡æ–°å®šä½
            relocate_by_fingerprint(device_id, &candidate.fingerprint).await?
        } else {
            candidate.clone()
        };
        
        // æ‰§è¡Œç‚¹å‡»
        execute_single_click(device_id, &target).await?;
        click_count += 1;
    }
    
    Ok(result)
}
```

---

#### 6ï¸âƒ£ æ‰¹é‡æ‰§è¡Œçš„"é¢„ç®—ç®¡ç†"

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **ExecutionLimits ç±»å‹** | âœ… **å·²å®šä¹‰** | `smart_selection.rs:250-256` |
| **ExecutionLimits ä½¿ç”¨** | âŒ **æœªå®ç°** | æœªè§å®é™…é¢„ç®—ç®¡ç† |
| **interval_ms + æŠ–åŠ¨** | âœ… **å·²å®ç°** | `execute_clicks` ä¸­æœ‰é—´éš”å’ŒæŠ–åŠ¨ |
| **per_target_timeout** | âŒ **æœªå®ç°** | æ— å•ç›®æ ‡è¶…æ—¶æ§åˆ¶ |
| **total_budget_ms** | âŒ **æœªå®ç°** | æ— æ€»é¢„ç®—é™åˆ¶ |

**å®æ–½å»ºè®®**ï¼š
```rust
struct BudgetManager {
    total_budget: Duration,
    per_target_budget: Duration,
    start_time: Instant,
}

impl BudgetManager {
    fn check_total_budget(&self) -> Result<()> {
        if self.start_time.elapsed() > self.total_budget {
            return Err(anyhow!("æ€»é¢„ç®—è€—å°½"));
        }
        Ok(())
    }
    
    fn with_target_budget<F, T>(&self, f: F) -> Result<T>
    where
        F: Future<Output = Result<T>>,
    {
        tokio::time::timeout(self.per_target_budget, f)
            .await
            .map_err(|_| anyhow!("å•ç›®æ ‡è¶…æ—¶"))?
    }
}
```

---

#### 7ï¸âƒ£ Auto æ¨¡å¼æ›´ç¨³çš„åˆ¤å®š

| é¡¹ç›® | çŠ¶æ€ | ç°çŠ¶è¯´æ˜ |
|------|------|----------|
| **åŸºç¡€ Auto é€»è¾‘** | âœ… **å·²å®ç°** | `execute_smart_selection` ä¸­æœ‰å€™é€‰æ•°é‡åˆ¤æ–­ |
| **å€™é€‰æ•°=1 â†’ single** | âœ… **å·²å®ç°** | `candidate_count <= 1` é€»è¾‘å­˜åœ¨ |
| **æŒ‡çº¹ç½®ä¿¡åº¦åˆ¤æ–­** | âš ï¸ **éƒ¨åˆ†å®ç°** | æœ‰æŒ‡çº¹ç›¸ä¼¼åº¦è®¡ç®—ï¼Œä½† Auto æ¨¡å¼æœªä½¿ç”¨ |
| **candidates>1 ä½†é«˜ç½®ä¿¡åº¦** | âŒ **æœªå®ç°** | ç¼ºå°‘"å¤šä¸ªå€™é€‰ä½†ä»ç”¨ single"çš„é€»è¾‘ |

**ä»£ç ä½ç½®**ï¼š
- ç°æœ‰å®ç°ï¼š`smart_selection_engine.rs:97-116`

**æ”¹è¿›å»ºè®®**ï¼š
```rust
SelectionMode::Auto { single_min_confidence, batch_config, fallback_to_first } => {
    let candidate_count = candidates.len();
    debug_logs.push(format!("Autoæ¨¡å¼æ£€æµ‹åˆ° {} ä¸ªå€™é€‰å…ƒç´ ", candidate_count));
    
    if candidate_count == 0 {
        return Err(anyhow!("æ— å€™é€‰å…ƒç´ "));
    } else if candidate_count == 1 {
        // å•ä¸ªå€™é€‰ â†’ ç›´æ¥ä½¿ç”¨
        debug_logs.push("Autoæ¨¡å¼ â†’ å•ä¸ªç­–ç•¥".to_string());
        Self::execute_positional_strategy(&candidates, 0, &mut debug_logs)?
    } else {
        // å¤šä¸ªå€™é€‰ â†’ æ£€æŸ¥æŒ‡çº¹ç½®ä¿¡åº¦
        if let Some(best_match) = Self::find_high_confidence_match(
            &candidates,
            &protocol.anchor.fingerprint,
            single_min_confidence.unwrap_or(0.85),
        ) {
            // æœ‰é«˜ç½®ä¿¡åº¦åŒ¹é… â†’ ä»ä½¿ç”¨å•ä¸ªç­–ç•¥
            debug_logs.push(format!(
                "Autoæ¨¡å¼ â†’ å¤šå€™é€‰ä½†é«˜ç½®ä¿¡åº¦({:.2}) â†’ å•ä¸ªç­–ç•¥",
                best_match.confidence
            ));
            Ok(vec![best_match])
        } else {
            // æ— é«˜ç½®ä¿¡åº¦åŒ¹é… â†’ æ‰¹é‡ç­–ç•¥
            debug_logs.push("Autoæ¨¡å¼ â†’ æ‰¹é‡ç­–ç•¥".to_string());
            Self::execute_batch_strategy(&candidates, &mut debug_logs)?
        }
    }
}
```

---

### ğŸ“Š å¯è§‚æµ‹æ€§ä¸å›æ”¾ï¼ˆ3æ¡ï¼‰

#### 8ï¸âƒ£ Selector é£é™©åˆ†æ‰“åˆ† & Lint

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **é£é™©åˆ†è®¡ç®—** | âŒ **ç¼ºå¤±** |
| **é£é™©å› ç´ æ£€æµ‹** | âŒ **ç¼ºå¤±** |
| **UI å¾½æ ‡å±•ç¤º** | âŒ **ç¼ºå¤±** |

**å®æ–½å»ºè®®**ï¼š
```rust
fn calculate_risk_score(selector: &CandidateSelector) -> f32 {
    let mut risk = 0.0;
    
    // å«ç´¢å¼• +0.3
    if selector.contains_index() { risk += 0.3; }
    
    // å…¨å±€é€‰æ‹©å™¨ +0.4
    if selector.is_global() { risk += 0.4; }
    
    // ä»…æ–‡æœ¬åŒ¹é… +0.2
    if selector.is_text_only() { risk += 0.2; }
    
    // æ— å®¹å™¨é™åˆ¶ +0.3
    if !selector.has_container() { risk += 0.3; }
    
    // æ— è¯­ä¹‰é”šç‚¹ +0.2
    if !selector.has_semantic_anchor() { risk += 0.2; }
    
    risk.min(1.0)
}
```

---

#### 9ï¸âƒ£ ç»“æ„åŒ–æ—¥å¿—ä¸æŒ‡æ ‡

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **å…³é”®æŒ‡æ ‡è®°å½•** | âš ï¸ **éƒ¨åˆ†** |
| **å¤±è´¥æ ‡ç­¾åŒ–** | âŒ **ç¼ºå¤±** |

**ç°çŠ¶**ï¼šæœ‰åŸºç¡€æ—¥å¿—ï¼Œä½†ç¼ºå°‘ç»“æ„åŒ–æŒ‡æ ‡é‡‡é›†ã€‚

**å®æ–½å»ºè®®**ï¼š
```rust
#[derive(Debug, Serialize)]
struct ExecutionMetrics {
    match_count: u32,
    selected_count: u32,
    success_count: u32,
    fail_count: u32,
    per_target_time_ms: Vec<u64>,
    re_dump_count: u32,
    fallback_used: bool,
    error_tags: Vec<ErrorTag>,
}

#[derive(Debug, Serialize)]
enum ErrorTag {
    NoMatch,
    MultiMatch,
    VerifyFail,
    Timeout,
    PopupBlock,
}
```

---

#### ğŸ”Ÿ é«˜äº®é¢„è§ˆ & é¢„é£è¡Œæ£€æŸ¥

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **åŒ¹é…æ•°é‡é¢„è§ˆ** | âŒ **ç¼ºå¤±** |
| **æˆªå›¾é«˜äº®** | âŒ **ç¼ºå¤±** |
| **å¹²è·‘éªŒè¯** | âŒ **ç¼ºå¤±** |

**è¯´æ˜**ï¼šçº¯å‰ç«¯åŠŸèƒ½ï¼Œéœ€åœ¨ UI ç»„ä»¶ä¸­å®ç°ã€‚

---

### ğŸªª åé£æ§ä¸ç¨³å®šæ€§ï¼ˆ3æ¡ï¼‰

#### 1ï¸âƒ£1ï¸âƒ£ èŠ‚å¥æŠ–åŠ¨ä¸åˆ†å¸ƒ

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **åŸºç¡€æŠ–åŠ¨** | âœ… **å·²å®ç°** |
| **åˆ†å¸ƒå¼æŠ–åŠ¨** | âŒ **æœªå®ç°** |
| **æ»‘åŠ¨ç©¿æ’** | âŒ **æœªå®ç°** |

**ç°çŠ¶**ï¼š`execute_clicks` ä¸­æœ‰å›ºå®šæŠ–åŠ¨ï¼Œä½†ç¼ºå°‘åŠ¨æ€åˆ†å¸ƒã€‚

---

#### 1ï¸âƒ£2ï¸âƒ£ ç³»ç»Ÿåé¦ˆæ¢æµ‹

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **toast ç›‘å¬** | âŒ **ç¼ºå¤±** |
| **å†·é™çª—å£** | âŒ **ç¼ºå¤±** |

---

#### 1ï¸âƒ£3ï¸âƒ£ è·¨é¡µå»é‡

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **å†å²å»é‡** | âŒ **ç¼ºå¤±** |
| **dedupe_key å­˜å‚¨** | âŒ **ç¼ºå¤±** |

---

### ğŸ§ª æµ‹è¯•ä¸å›å½’ï¼ˆ2æ¡ï¼‰

#### 1ï¸âƒ£4ï¸âƒ£ é‡‘æ · XML é›†ä¸å›å½’ CI

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **é‡‘æ · XML åº“** | âŒ **ç¼ºå¤±** |
| **CI å›å½’æµ‹è¯•** | âŒ **ç¼ºå¤±** |

---

#### 1ï¸âƒ£5ï¸âƒ£ å±æ€§éšæœºåŒ– & å‹åŠ›æµ‹è¯•

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **éšæœºåŒ–æµ‹è¯•** | âŒ **ç¼ºå¤±** |
| **å‹åŠ›æµ‹è¯•** | âŒ **ç¼ºå¤±** |

---

### ğŸ§© åè®®ä¸æ‰©å±•ï¼ˆ2æ¡ï¼‰

#### 1ï¸âƒ£6ï¸âƒ£ StepCard æœ€å°æ‰©å±•

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **selection.mode** | âœ… **å·²å®ç°** |
| **include/exclude** | âœ… **ç±»å‹å®šä¹‰** |
| **risk_score** | âŒ **æœªå®ç°** |
| **match_count_preview** | âŒ **æœªå®ç°** |

---

#### 1ï¸âƒ£7ï¸âƒ£ æ’ä»¶åŒ–åˆ«åè¡¨

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **i18n æ³¨å†Œä¸­å¿ƒ** | âŒ **ç¼ºå¤±** |
| **çƒ­æ›´æ–°æ”¯æŒ** | âŒ **ç¼ºå¤±** |
| **åœºæ™¯åˆ‡æ¢** | âŒ **ç¼ºå¤±** |

---

### ğŸ§  ä¸­æœŸæ¼”è¿›ï¼ˆ3æ¡ï¼‰

#### 1ï¸âƒ£8ï¸âƒ£ é˜ˆå€¼è‡ªé€‚åº”

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **é¥æµ‹æ”¶é›†** | âŒ **ç¼ºå¤±** |
| **æ»‘åŠ¨çª—å£** | âŒ **ç¼ºå¤±** |

---

#### 1ï¸âƒ£9ï¸âƒ£ å­¦ä¹ å¼åˆ«åæ‰©å±•

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **æœªçŸ¥æ–‡æ¡ˆæ”¶é›†** | âŒ **ç¼ºå¤±** |
| **äººå·¥ç¡®è®¤** | âŒ **ç¼ºå¤±** |

---

#### 2ï¸âƒ£0ï¸âƒ£ ç­–ç•¥å¯¹ç…§å®éªŒ

| é¡¹ç›® | çŠ¶æ€ |
|------|------|
| **A/B å¼€å…³** | âŒ **ç¼ºå¤±** |
| **ç»Ÿè®¡å¯¹æ¯”** | âŒ **ç¼ºå¤±** |

---

## ğŸ“ˆ å®æ–½ä¼˜å…ˆçº§å»ºè®®

### ğŸ”¥ é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰

1. **æ’é™¤å±‚é»˜è®¤å¼€å¯**ï¼ˆ#2ï¼‰- é˜²æ­¢è¯¯ç‚¹"å·²å…³æ³¨"
2. **å»é‡ä¸ç¨³å®šæ’åº**ï¼ˆ#3ï¼‰- é¿å…é‡å¤ç‚¹å‡»
3. **ç‚¹å‡»åè½»æ ¡éªŒ**ï¼ˆ#4ï¼‰- æé«˜æˆåŠŸç‡
4. **Auto æ¨¡å¼ä¼˜åŒ–**ï¼ˆ#7ï¼‰- æå‡æ™ºèƒ½å†³ç­–å‡†ç¡®æ€§

### âš¡ ä¸­ä¼˜å…ˆçº§ï¼ˆçŸ­æœŸå®æ–½ï¼‰

5. **å¾®åˆ·æ–°ç­–ç•¥**ï¼ˆ#5ï¼‰- åº”å¯¹ UI å˜åŒ–
6. **é¢„ç®—ç®¡ç†**ï¼ˆ#6ï¼‰- é˜²æ­¢è¶…æ—¶å¤±æ§
7. **ç»“æ„åŒ–æ—¥å¿—**ï¼ˆ#9ï¼‰- é—®é¢˜å®šä½

### ğŸ¯ ä½ä¼˜å…ˆçº§ï¼ˆä¸­é•¿æœŸï¼‰

8. **é›†åˆæ´¾ç”Ÿå™¨æ¶æ„**ï¼ˆ#1ï¼‰- æ¶æ„é‡æ„
9. **å¯è§‚æµ‹æ€§å®Œå–„**ï¼ˆ#8-10ï¼‰- å·¥ç¨‹åŒ–æå‡
10. **åé£æ§æœºåˆ¶**ï¼ˆ#11-13ï¼‰- åå°ç¦
11. **æµ‹è¯•ä¸å›å½’**ï¼ˆ#14-15ï¼‰- è´¨é‡ä¿éšœ

---

## âœ… æ ¸å¿ƒé—®é¢˜å›ç­”

### Q1: æˆ‘æœ‹å‹çš„å»ºè®®æœ‰ç”¨å—ï¼Ÿ

**éå¸¸æœ‰ç”¨ï¼** è¿™äº›æ˜¯å®é™…å·¥ç¨‹è½åœ°çš„å…³é”®ç»†èŠ‚ï¼š
- âœ… é˜²æ­¢è¯¯æ“ä½œï¼ˆæ’é™¤ã€å»é‡ã€è½»æ ¡éªŒï¼‰
- âœ… æå‡ç¨³å®šæ€§ï¼ˆå¾®åˆ·æ–°ã€é¢„ç®—ç®¡ç†ï¼‰
- âœ… ä¾¿äºè°ƒè¯•ï¼ˆæ—¥å¿—ã€æŒ‡æ ‡ã€é¢„è§ˆï¼‰
- âœ… åé£æ§ï¼ˆèŠ‚å¥æŠ–åŠ¨ã€ç³»ç»Ÿåé¦ˆï¼‰

### Q2: æœ‰å¿…è¦å—ï¼Ÿ

**éå¸¸å¿…è¦ï¼** å½“å‰å®ç°çš„ç¼ºå¤±é¡¹ï¼š
- âŒ **æ— æ’é™¤å±‚** â†’ ä¼šè¯¯ç‚¹"å·²å…³æ³¨"
- âŒ **æ— å»é‡** â†’ ä¼šé‡å¤ç‚¹å‡»
- âŒ **æ— è½»æ ¡éªŒ** â†’ ä¸çŸ¥é“æ˜¯å¦æˆåŠŸ
- âŒ **æ— å¾®åˆ·æ–°** â†’ UI å˜åŒ–åå¤±æ•ˆ
- âŒ **æ— æ—¥å¿—æŒ‡æ ‡** â†’ å‡ºé”™éš¾å®šä½

è¿™äº›éƒ½æ˜¯**ç”Ÿäº§ç¯å¢ƒå¿…å¤‡**çš„åŠŸèƒ½ã€‚

### Q3: é›†åˆæ´¾ç”Ÿå™¨æˆ‘æœ‰å—ï¼Ÿ

**âŒ æ²¡æœ‰ç‹¬ç«‹çš„æ´¾ç”Ÿå™¨æ¶æ„**

**ç°çŠ¶**ï¼š
- å€™é€‰ç”Ÿæˆåœ¨ `SmartSelectionEngine::parse_xml_and_find_candidates`
- æ˜¯ç®€åŒ–å®ç°ï¼Œæœªåˆ†ç¦»æ´¾ç”Ÿé€»è¾‘
- æ²¡æœ‰å¯æ’æ‹”çš„æ´¾ç”Ÿå™¨æ³¨å†Œç³»ç»Ÿ

**ç¼ºå°‘çš„å…³é”®ç»„ä»¶**ï¼š
```rust
âŒ trait CandidateCollector
âŒ struct DescClickableCollector
âŒ struct TextToParentCollector
âŒ struct RegionScopedCollector
âŒ struct CollectorRegistry
```

---

## ğŸ¯ åç»­è¡ŒåŠ¨å»ºè®®

### é˜¶æ®µä¸€ï¼šåŸºç¡€è¡¥å¼ºï¼ˆ1-2å‘¨ï¼‰

1. âœ… å®ç°æ’é™¤å±‚ï¼ˆi18n_alias + exclude_textï¼‰
2. âœ… å®ç°å»é‡é€»è¾‘ï¼ˆdedupe_keyï¼‰
3. âœ… å®ç°è½»æ ¡éªŒï¼ˆç‚¹å‡»åéªŒè¯ï¼‰
4. âœ… ä¼˜åŒ– Auto æ¨¡å¼åˆ¤å®š

### é˜¶æ®µäºŒï¼šå·¥ç¨‹åŒ–æå‡ï¼ˆ2-4å‘¨ï¼‰

5. âœ… å®ç°å¾®åˆ·æ–°ç­–ç•¥ï¼ˆRefreshPolicyï¼‰
6. âœ… å®ç°é¢„ç®—ç®¡ç†ï¼ˆExecutionLimitsï¼‰
7. âœ… å®Œå–„ç»“æ„åŒ–æ—¥å¿—å’ŒæŒ‡æ ‡

### é˜¶æ®µä¸‰ï¼šæ¶æ„ä¼˜åŒ–ï¼ˆ1-2æœˆï¼‰

8. âœ… è®¾è®¡å¹¶å®ç°é›†åˆæ´¾ç”Ÿå™¨æ¶æ„
9. âœ… å®ç°å¯æ’æ‹”æ´¾ç”Ÿå™¨æ³¨å†Œç³»ç»Ÿ
10. âœ… æ·»åŠ é£é™©åˆ†è®¡ç®—å’Œ UI å±•ç¤º

---

## ğŸ“ æ€»ç»“

**æ‚¨çš„æ¶æ„æ–¹å‘æ˜¯æ­£ç¡®çš„**ï¼š"æ™ºèƒ½è‡ªåŠ¨é“¾ï¼ˆFindï¼‰+ æ™ºèƒ½é€‰æ‹©ï¼ˆSelectï¼‰+ åŠ¨ä½œï¼ˆActï¼‰"ä¸‰å±‚åˆ†ç¦»ã€‚

**ä½†å·¥ç¨‹åŒ–ç»†èŠ‚éœ€è¦è¡¥é½**ï¼š
- âœ… ç±»å‹å®šä¹‰å®Œæ•´ï¼ˆ90%ï¼‰
- âš ï¸ æ ¸å¿ƒé€»è¾‘éƒ¨åˆ†å®ç°ï¼ˆ60%ï¼‰
- âŒ å·¥ç¨‹åŒ–ç»†èŠ‚ç¼ºå¤±ï¼ˆ30%ï¼‰

**å»ºè®®é‡‡çº³æœ‹å‹çš„å»ºè®®**ï¼ŒæŒ‰ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œè®©ç³»ç»Ÿä»"èƒ½ç”¨"åˆ°"å¥½ç”¨"å†åˆ°"ç¨³å®šå¯é "ã€‚
