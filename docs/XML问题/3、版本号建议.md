算法版本号
来源标记
这个要怎么做？

好！把这两件事做成“**版本可控** + **来源可追踪**”就稳了。下面给你**可直接落地**的最小改造（按你要求：每段代码第一行保留文件名+路径）。

---

### 一、算法版本号（metrics_version + algo_fingerprint）

核心思路：

* 用 **SemVer 字符串**标记主版本（破坏性变化就+1），
* 再用 **fingerprint**（哈希）把可配置项/权重/开关编码进去，保证“同一算法、不同权重”也能区分缓存。

```rust
// src-tauri/src/domain/structure_runtime_match/algo.rs
pub const METRICS_ALGO_VERSION: &str = "sm-v2.1.0"; // 破坏性变更时升级主版本

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct AlgoConfig {
    pub enable_container_gate: bool,
    pub enable_layout_gate: bool,
    pub weight_id: f32,
    pub weight_desc: f32,
    pub weight_text: f32,
    pub penalty_global_index: f32,
    pub min_conf: f32,
    pub top_gap: f32,
}

pub fn compute_algo_fingerprint(cfg: &AlgoConfig) -> u64 {
    use xxhash_rust::xxh3::xxh3_64;
    let s = format!(
        "{}|c{}|l{}|wi{:.3}|wd{:.3}|wt{:.3}|pg{:.3}|mc{:.3}|tg{:.3}",
        METRICS_ALGO_VERSION,
        cfg.enable_container_gate as u8,
        cfg.enable_layout_gate as u8,
        cfg.weight_id, cfg.weight_desc, cfg.weight_text,
        cfg.penalty_global_index, cfg.min_conf, cfg.top_gap
    );
    xxh3_64(s.as_bytes())
}
```

把版本与指纹写入 `SubtreeMetrics`，并在缓存校验时对齐。

```rust
// src-tauri/src/domain/analysis_cache/types.rs
#[derive(Clone, serde::Serialize, serde::Deserialize)]
pub struct SubtreeMetrics {
    pub algo_version: String,
    pub algo_fingerprint: u64,
    pub built_at_unix: i64,
    // … 你原有的骨架/字段/容器限域/模板签名等
}
```

生成时填充：

```rust
// src-tauri/src/domain/analysis_cache/api.rs
use crate::domain::structure_runtime_match::algo::{METRICS_ALGO_VERSION, compute_algo_fingerprint, AlgoConfig};

pub fn compute_subtree_metrics(dom: &DomIndex, abs_xpath: &str, cfg: &AlgoConfig) -> SubtreeMetrics {
    let mut m = really_compute(dom, abs_xpath, cfg); // 你原有的计算
    m.algo_version = METRICS_ALGO_VERSION.to_string();
    m.algo_fingerprint = compute_algo_fingerprint(cfg);
    m.built_at_unix = chrono::Utc::now().timestamp();
    m
}
```

**缓存命中规则**：**算法版本/指纹不一致 → 视为失效并重算**（保证升级后不会用到旧参数）。

```rust
// src-tauri/src/domain/analysis_cache/api.rs
pub fn get_or_compute_subtree(id: &SnapshotId, abs_xpath: &str, cfg: &AlgoConfig) -> SubtreeMetrics {
    let key = (id.clone(), abs_xpath.to_string(), compute_algo_fingerprint(cfg));
    if let Some(v) = SUBTREE_CACHE.get(&key) {
        if v.algo_version == METRICS_ALGO_VERSION {
            return v.clone();
        }
    }
    let dom = get_dom(id).expect("snapshot not registered");
    let m = compute_subtree_metrics(&dom, abs_xpath, cfg);
    SUBTREE_CACHE.insert(key, m.clone());
    m
}
```

> 注意：把 **algo_fingerprint 加进缓存 Key**（推荐做法）；也可以不进 Key 而在取值后比对再决定重算，但把它进 Key 更直观。

---

### 二、来源标记（完整的可追溯链路）

你已有 `RebuildSource`（Cache/Snapshot/LiveDump）。建议再补充**“定位途径”**和**“等价 XPath”**，方便排错。

```rust
// src-tauri/src/domain/analysis_cache/rebuild.rs
#[derive(Clone, serde::Serialize)]
pub enum RebuildSource { Cache, Snapshot, LiveDump }

#[derive(Clone, serde::Serialize)]
pub enum ResolveMode { ByXPath, ByStructureMatch }

#[derive(Clone, serde::Serialize)]
pub struct EnsureMetricsResp {
    pub source: RebuildSource,        // 参数来源
    pub resolve_mode: ResolveMode,    // XPath 直接命中 or 结构匹配
    pub input_abs_xpath: String,      // 原始卡片里的 XPath
    pub resolved_abs_xpath: String,   // 实际使用的 XPath（结构匹配会变）
    pub snapshot_id: String,          // 使用的快照ID
    pub metrics: SubtreeMetricsDto,   // 含 algo_version / algo_fingerprint
    pub message: String,
}
```

在重建流程里填充这两个字段：

```rust
// src-tauri/src/domain/analysis_cache/rebuild.rs
let (resolved_xpath, located_via_structure) =
    crate::engine::locator::resolve_xpath_or_structure(&sid, &step.abs_xpath)?;
let mode = if located_via_structure { ResolveMode::ByStructureMatch } else { ResolveMode::ByXPath };

Ok(EnsureMetricsResp {
    source: RebuildSource::LiveDump,
    resolve_mode: mode,
    input_abs_xpath: step.abs_xpath.clone(),
    resolved_abs_xpath: resolved_xpath.clone(),
    snapshot_id: sid,
    metrics: get_or_compute_subtree(&sid, &resolved_xpath, cfg).into(),
    message: if located_via_structure { "rebuilt from live dump via structure match".into() } else { "rebuilt from live dump via xpath".into() },
})
```

**日志里持久化来源**（便于排查线下问题）：

```rust
// src-tauri/src/instrumentation/logging.rs
pub fn log_metrics_provenance(resp: &EnsureMetricsResp) {
    tracing::info!(target: "metrics",
        source = ?resp.source,
        mode = ?resp.resolve_mode,
        input_xpath = %resp.input_abs_xpath,
        resolved_xpath = %resp.resolved_abs_xpath,
        snapshot_id = %resp.snapshot_id,
        algo_version = %resp.metrics.algo_version,
        algo_fp = resp.metrics.algo_fingerprint,
        "ensure_subtree_metrics provenance"
    );
}
```

在命令里调用一下：

```rust
// src-tauri/src/commands/analysis.rs
let resp = ensure_subtree_metrics(&step).map_err(|e| e.to_string())?;
crate::instrumentation::logging::log_metrics_provenance(&resp);
Ok(resp)
```

---

### 三、步骤卡片持久化这两类信息（前端）

**保存最近一次成功执行/展示时的版本与来源**，方便复制、分享和复盘：

```ts
// src/shared/types/StepCard.ts
export interface StepCard {
  absXPath: string;
  xmlSnapshot?: string;
  snapshotId?: string;

  // 执行/展示时自动回填
  lastMetrics?: {
    algoVersion: string;
    algoFingerprint: number;
    rebuiltFrom: 'Cache' | 'Snapshot' | 'LiveDump';
    resolveMode: 'ByXPath' | 'ByStructureMatch';
    resolvedAbsXPath: string;
    snapshotId: string;
    builtAtUnix: number;
  };
}
```

调用 `ensureSubtreeMetrics` 后**统一回写**：

```ts
// src/modules/steps/executeStep.ts
const resp = await ensureSubtreeMetrics(stepPayload);
updateStepCard(stepId, {
  snapshotId: resp.snapshot_id,
  lastMetrics: {
    algoVersion: resp.metrics.algo_version,
    algoFingerprint: resp.metrics.algo_fingerprint,
    rebuiltFrom: resp.source,
    resolveMode: resp.resolve_mode,
    resolvedAbsXPath: resp.resolved_abs_xpath,
    snapshotId: resp.snapshot_id,
    builtAtUnix: resp.metrics.built_at_unix,
  }
});
```

UI 上也可提示：

* “来自缓存 / 来自快照重建 / 来自真机 dump（XPath / 结构匹配）”
* “算法 sm-v2.1.0（fingerprint: 0x…）”

---

### 四、升级与失效策略（怎么“动手”）

1. **你改动了骨架/权重/闸门**：

   * 若是**破坏性**（结果语义变了）：直接把 `METRICS_ALGO_VERSION` 升到 `sm-vX.Y.Z` 的 **X** 或 **Y**。
   * 仅调整权重/阈值/开关：保持版本不变，但 **AlgoConfig** 变化会导致 **algo_fingerprint** 变化，从而天然区分缓存。

2. **缓存失效**：

   * 命中但 `algo_version != METRICS_ALGO_VERSION` → 丢弃并重算；
   * Key 里含 `algo_fingerprint` → 配置变化时自动走新 Key，不会误用旧缓存；
   * 你可保留 LRU 或定期清理策略，避免缓存膨胀。

3. **灰度/回滚**：

   * 前端可以选择“执行时强制使用某个 AlgoConfig（例如 Robust/Safe/Speed 三档）”，自然生成不同的 `algo_fingerprint`，互不干扰；
   * 出问题时切回旧档位即恢复旧行为（但版本不降）。

---

### 五、最小验收清单

* 修改一处权重（如 `weight_text`），**不改版本**：fingerprint 变化 → 旧缓存不被复用；
* 修改算法（如新增“容器限域强校验”逻辑），**升版本**：即使指纹相同也触发重算；
* 拔掉缓存文件/内存清空：执行前**自动用快照重建**；删快照且允许回退：**自动真机 dump** 重建；
* 日志中有一条 JSON（或结构化）记录含：source、mode、input/resolved XPath、algo_version、fingerprint、snapshot_id。

---

以上就是“**算法版本号**”和“**来源标记**”的完整做法：**一行常量 + 一份指纹 + 两个字段**贯穿缓存、执行与日志。
你把这些片段贴进现有模块就能跑；要我我可以把 `really_compute` / `resolve_xpath_or_structure` 的签名替你对齐好。
