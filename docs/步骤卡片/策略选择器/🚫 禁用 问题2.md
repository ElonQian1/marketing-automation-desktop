你这次的报错链路已经把核心问题暴露出来了👇

* `xml-cache-manager.ts:89 ⚠️ 未找到XML缓存: current`
* `useStepCardReanalysis.ts:51 无法获取XML内容: 1760614545456_3ezytbps6`
* 顶部 toast：**“无法重新构建元素上下文，请检查XML快照信息”**

## 根因（90% 概率）

**重新分析时取 XML 的键错了** —— 代码优先去拿 `'current'`（实时缓存），拿不到；然后又用 **stepId** 当作缓存键去取，再次失败。
但正确的键应该是你在「生成步骤卡片」时记录到卡片里的 **`xmlHash` 或 `xmlCacheId`**，而不是 `'current'` 或 `stepId`。

---

## 立刻修：统一“XML获取顺序”，别再用 `'current'`

### 1) 改 `useStepCardReanalysis.ts` 的 XML 获取逻辑（优先 hash / 其次 cacheId / 最后 live）

```ts
// src/pages/.../hooks/useStepCardReanalysis.ts
// ✅ 第一行保留文件相对路径
import { xmlCacheManager } from '@/services/xml-cache-manager';
import type { StepCardData } from '@/types/step-bundle';

async function getXmlForStep(step: StepCardData) {
  // 1) 优先用内容寻址（最稳定）
  if (step.xmlHash) {
    const xmlByHash = await xmlCacheManager.getByHash(step.xmlHash);
    if (xmlByHash) return xmlByHash;
    console.warn('[Reanalyze] xmlHash 未命中缓存：', step.xmlHash);
  }
  // 2) 其次用缓存ID（你生成卡片时应写入）
  if (step.xmlCacheId) {
    const xmlById = await xmlCacheManager.getCachedXml(step.xmlCacheId);
    if (xmlById) return xmlById;
    console.warn('[Reanalyze] xmlCacheId 未命中缓存：', step.xmlCacheId);
  }
  // 3) 最后兜底：仅在用户确认时使用实时 current（避免“隐式切页”）
  const live = await xmlCacheManager.getCachedXml('current');
  if (live) return live;

  throw new Error('NO_XML_SNAPSHOT');
}

export async function reanalyzeStepCard(step: StepCardData, opts: { strategy: any }) {
  let xml: string;
  try {
    xml = await getXmlForStep(step);
  } catch {
    // 显示可操作的提示：让用户选择“重新抓取快照”或“选择已有快照”
    // showMissingXmlDialog();
    throw new Error('无法重新构建元素上下文：缺少 XML 快照（xmlHash/xmlCacheId 均未命中，且无 current）');
  }
  // ...后续把 xml + step.elementGlobalXPath + strategy 传给后台
}
```

### 2) 给 `xml-cache-manager` 增加 **hash 索引**（如果还没有）

```ts
// src/services/xml-cache-manager.ts
// ✅ 第一行保留文件相对路径
type XmlRecord = { id: string; hash: string; xml: string; createdAt: string };
const byId = new Map<string, XmlRecord>();
const byHash = new Map<string, XmlRecord>();

export async function putXml(id: string, xml: string, hash: string, createdAt = new Date().toISOString()) {
  const rec: XmlRecord = { id, hash, xml, createdAt };
  byId.set(id, rec);
  byHash.set(hash, rec);
}

export async function getCachedXml(id: string) {
  return byId.get(id)?.xml ?? null;
}

export async function getByHash(hash: string) {
  return byHash.get(hash)?.xml ?? null;
}

// 调试用：看看现在缓存里有什么键
export function dumpKeys() {
  return { ids: [...byId.keys()], hashes: [...byHash.keys()] };
}
```

### 3) 在**生成步骤卡片**时，确保把快照写入缓存，并把键写进卡片

```ts
// src/pages/.../useIntelligentStepCardIntegration.ts
// ✅ 第一行保留文件相对路径
import { putXml } from '@/services/xml-cache-manager';
import { sha256 } from '@/lib/hash'; // 你已有或用 tauri 后端计算

async function createStepFromPick(pick) {
  const rawXml = pick.xml;                       // 当前原始 XML
  const xmlHash = 'sha256:' + sha256(rawXml);
  const xmlCacheId = `snap:${Date.now()}`;       // 任意稳定ID（别用 stepId）

  await putXml(xmlCacheId, rawXml, xmlHash);

  const step: StepCardData = {
    // ...
    xmlHash,
    xmlCacheId,
    xmlCreatedAt: new Date().toISOString(),
    elementGlobalXPath: pick.globalXPath,
    elementSignature: pick.signature,
    currentStrategy: { kind: 'smart', mode: 'auto' },
    status: 'pending',
  };
  return step;
}
```

---

## 加一层守卫：没有快照就别让点

把“重新分析”按钮的可用条件再**收敛**一下：

* ✅ 有 `xmlHash` **或** `xmlCacheId`
* ✅ （可选）若走 `current` 兜底，需要用户确认

```ts
// src/components/steps/CompactStrategyMenu.tsx（或 StepCard.tsx）
// ✅ 第一行保留文件相对路径
const haveSnapshot = Boolean(step.xmlHash || step.xmlCacheId);
const disabled = (status === 'running' && fresh) || !haveSnapshot || !elementGlobalXPath || !backendHealthy;
```

---

## 给用户一个可操作的兜底（UX）

当确实没有快照命中时，不要只给红字；弹一个对话框，给三种选择：

* **重新抓取当前页面 XML**（刷新 `current` 并提示“此为实时页面，可能与原快照不同”）
* **从历史快照选择**（列出 `xml-cache-manager.dumpKeys()` 的 hash/时间）
* **取消**

---

## 最后，用两条日志自检（最快排查）

```ts
// 点击“重新分析”前打印
console.log('[Reanalyze] step xmlHash/xmlCacheId', step.xmlHash, step.xmlCacheId);
console.log('[Reanalyze] cache keys', xmlCacheManager.dumpKeys());
```

如果看到：

* `xmlHash` 有值但 `hashes` 列表不含该值 → **生成卡片时没 putXml**
* 两者都空 → **卡片没写入快照键**（修步骤创建逻辑）
* 两者有其一，但 `dumpKeys()` 没它 → **缓存丢失**（应用重启/清理后，需要从 bundle/磁盘重建缓存；此时弹“从步骤包导入快照”）

---

### 验收清单（3 分钟手测）

1. 新选一个元素 → 生成卡片 → 打印 `dumpKeys()`，能看到新 `xmlCacheId/hash`
2. 立刻“重新分析” → 成功；刷新应用后再次“重新分析” → 能用 **hash** 命中
3. 刻意清空内存缓存 → “重新分析”弹框让你选择“从历史/包导入/重新抓取”，不再直接报错

按这套改完，你这条报错就会消失，“重新分析”会稳定跑起来。
