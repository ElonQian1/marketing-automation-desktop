# 容器识别与可点父修复说明

## 修复日期
2025-11-19

## 问题诊断

### 问题1：容器识别错误 ❌
**症状**：
- 瀑布流卡片被识别为 `ViewPager` 容器（分页容器）
- 评分异常低：CardSubtree 25%、LeafContext 22%

**根本原因**：
- `is_scroll_container()` 把所有滚动类控件平等对待
- ViewPager 是**分页容器**，不是**卡片重复容器**
- 候选集混入大量噪声，导致唯一性差距变小

### 问题2：可点父查找不够健壮 ❌
**症状**：
- 日志显示"未找到可点父，回退到卡片根"
- 四节点退化：`clicked=31, card_root=31, clickable_parent=31`

**根本原因**：
- 只查找"直接子节点 + FrameLayout + clickable + IOU>0.8"
- 逻辑过于严格，容易找不到有效可点父
- 缺少边界差异校验和兜底降权机制

---

## 核心修复

### 修复1：容器优先级白名单机制 ✅

**新增函数**：`get_container_priority()`

```rust
/// 判断是否是滚动容器（带优先级）
/// 返回 (是否容器, 优先级分数: 0-100)
pub fn get_container_priority(&self, element: &UIElement) -> (bool, u8) {
    if let Some(class) = &element.class {
        let class_lower = class.to_lowercase();
        // 🎯 优先级白名单（卡片列表容器）
        if class_lower.contains("recyclerview") {
            return (true, 100); // 最高优先级
        }
        if class_lower.contains("gridview") {
            return (true, 90);
        }
        if class_lower.contains("listview") {
            return (true, 85);
        }
        if class_lower.contains("scrollview") && !class_lower.contains("nested") {
            return (true, 70); // 普通滚动容器
        }
        if class_lower.contains("nestedscrollview") {
            return (true, 65);
        }
        // ⚠️ ViewPager 是分页容器，不是卡片重复容器，降低优先级
        if class_lower.contains("viewpager") {
            return (true, 30); // 低优先级，仅兜底
        }
    }
    (false, 0)
}
```

**优先级规则**：
- RecyclerView (100) > GridView (90) > ListView (85) > ScrollView (70)
- ViewPager 降级到 30（仅作兜底）

**查找策略改进**：
1. **就近原则 + 高优先级优先**：
   - 找到 RecyclerView/GridView/ListView (≥85) 立即采用
   - 避免越过真正的列表容器命中外层分页容器

2. **候选收集 + 最优选择**：
   - 如果没有高优先级容器，收集所有候选
   - 按优先级降序、深度升序排序
   - 选择最优容器（优先级高 + 距离近）

---

### 修复2：可点父三步法 ✅

**新增逻辑**：

```rust
/// 找到卡片的可点父（三步法）
/// 1. 祖先可点：从卡片根向下查找第一个 clickable=true 的子孙
/// 2. 边界差异：要求可点父的 bounds 与卡片根有合理差异
/// 3. 兜底降权：如果找不到，返回 None（调用方会回退到卡片根但降权）
fn find_clickable_parent(&self, card_root_index: usize) -> Option<NormalizedNode> {
    // ... 详见代码实现
}
```

**关键改进**：

1. **边界差异校验**：
   ```rust
   let bounds_diff = {
       let left_diff = (n_left - r_left).abs();
       let top_diff = (n_top - r_top).abs();
       let right_diff = (n_right - r_right).abs();
       let bottom_diff = (n_bottom - r_bottom).abs();
       (left_diff + top_diff + right_diff + bottom_diff) as f32
   };
   
   // 如果bounds完全相同或差异小于10像素，跳过
   if bounds_diff < 10.0 {
       continue;
   }
   ```

2. **IOU阈值放宽**：
   - 从 `IOU > 0.8` 降低到 `IOU > 0.5`
   - 选择IOU最高的候选（最贴合卡片根）

3. **兜底策略**：
   - 找不到返回 `None`（不再panic）
   - 调用方会回退到卡片根
   - 评分时降低"点击映射"权重，但不致使总分崩溃

---

## 预期改进

### 静态页面测试（瀑布流样例）

**修复前**：
```
Container: ViewPager (深度3, priority=?)
CardSubtree: 25%
LeafContext: 22%
四节点: clicked=31, container=9, card_root=31, clickable_parent=31
```

**修复后（预期）**：
```
Container: RecyclerView (深度?, priority=100)
CardSubtree: ≥75%
LeafContext: ≥75%
四节点: clicked≠card_root≠clickable_parent (三节点分离)
```

### 核心指标改善

| 指标 | 修复前 | 修复后（目标） |
|------|-------|--------------|
| 容器类型 | ViewPager (分页) | RecyclerView (列表) |
| 容器优先级 | 无差别 | 100 (最高) |
| 可点父识别 | 失败（回退） | 成功（边界差异校验） |
| CardSubtree评分 | 25% | ≥75% |
| LeafContext评分 | 22% | ≥75% |
| 唯一性闸门 | 不通过 | 通过 (min_conf≥0.70, top_gap≥0.15) |

---

## 自测清单（给AI代理）

### 断言1：容器识别
- [ ] `container.class` 包含 "RecyclerView" 或 "GridView" 或 "ListView"
- [ ] `container.class` **不是** "ViewPager"
- [ ] 容器优先级 ≥ 85

### 断言2：卡片根识别
- [ ] 在容器内找到 ≥2 个高相似兄弟（骨架签名相似度 > 0.7）
- [ ] 卡片根具有 content-desc 或包含媒体区/底栏结构

### 断言3：可点父识别
- [ ] `clickable_parent` 存在且 `clickable_parent ≠ card_root`
- [ ] 或者：回退到 `card_root` 但评分时记录降权标记
- [ ] 边界差异 ≥ 10像素

### 断言4：评分阈值
- [ ] CardSubtree ≥ 0.75
- [ ] LeafContext ≥ 0.75
- [ ] top_gap ≥ 0.15
- [ ] 唯一性闸门通过

---

## 测试步骤

1. **编译新版本**：
   ```bash
   npm run tauri build --debug
   ```

2. **打开测试页面**：
   - 使用瀑布流静态样例（XML快照）

3. **查看后端日志**：
   ```
   ✅ 发现容器候选: priority=100, class=RecyclerView
   ✅ 找到高优先级容器 (深度X, priority=100)
   ✅ 找到可点父: index=Y, iou=0.XX, class=...
   ```

4. **查看前端评分**：
   - Step1 (卡片子树评分): ≥75%
   - Step2 (叶子上下文评分): ≥75%

5. **验证四节点**：
   ```
   clicked ≠ card_root ≠ clickable_parent (理想情况)
   或
   clicked ≠ card_root = clickable_parent (可接受，会降权但不崩溃)
   ```

---

## 代码位置

**文件**：`src-tauri/src/domain/structure_runtime_match/click_normalizer.rs`

**修改内容**：
1. Lines 192-220: `get_container_priority()` 新增函数
2. Lines 130-210: `find_nearest_container()` 重构逻辑
3. Lines 335-395: `find_clickable_parent()` 三步法重写

---

## 参考文档

- **卡片子树原理**：骨架签名 + 唯一性闸门 + 列内优先
- **叶子上下文原理**：稳定文本 + 父链签名 + 相对几何 + 兄弟模板
- **容器白名单**：RecyclerView > GridView > ListView > ScrollView > ViewPager
- **可点父三步法**：祖先可点 → 边界差异 → 兜底降权

---

## 常见问题

### Q1: 为什么 ViewPager 不能作为主容器？
A: ViewPager 是**分页容器**（左右滑动切换页面），内部是少量页面而非重复卡片列表。真正的卡片容器通常是页面内的 RecyclerView/GridView。

### Q2: 可点父找不到会怎样？
A: 系统会回退到卡片根作为可点父，但在评分时会降低"点击映射"特征权重，确保总分不会因此崩溃到 <50%。

### Q3: 静态页面为什么也会评分低？
A: 如果容器选错（ViewPager）或可点父缺失，即使是静态页面也会因为候选噪声和特征缺失导致评分低。修复后应达到 ≥75%。

### Q4: 如何确认修复生效？
A: 查看后端日志：
- `发现容器候选: priority=100, class=RecyclerView`
- `找到可点父: index=X, iou=0.XX`
- 前端显示评分 ≥75%
