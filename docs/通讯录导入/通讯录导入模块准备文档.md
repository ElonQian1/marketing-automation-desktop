下面给你一份**「开发前准备文档 + 架构与落地方案」**，专门针对：

* 多个 `.txt` 号码文件 → 规范化、全局去重
* **跨设备不重复分配**（同一号码**只进一个手机**）
* 按设备批次导出 **VCF/CSV** → 用 **ADB** 自动导入
* 可追踪「**哪个手机导入了哪些号码**」、可查询、可回溯
* 支持「**行业分类**」「自动分配策略**（均衡/容量/地区/行业）**」

> 结论先说：是的，要在**转换为 VCF/CSV 前**，先把号码**登记入库**并完成**去重与分配**。导出仅仅是“数据库里已确定分配关系”的结果快照。

---

# 一、目标与约束

1. **全局唯一分配**：每个“规范化后的号码”最多被分配到**一个设备**（或你可配置为最多K个）。
2. **导入前落盘登记**：所有号码先入库，完成清洗/去重/分配，随后再为每台设备导出 VCF/CSV。
3. **可追溯**：能回答「**某台手机导入了哪些号码**」「**某个号码在哪台手机**」「**哪些尚未导入**」。
4. **可重试**：导入失败可重试/回收/重新分配。
5. **行业分类**：支持基于规则的行业标签（可后续接 ML，但先从规则/字典开始）。
6. **本地离线**：Tauri + SQLite（单文件、事务可靠；百万级数据可稳定运行）。

---

# 二、总体架构（Tauri 桌面端）

**三层：前端 UI / 后端指令（Rust）/ 存储层（SQLite）**

* 前端（Tauri Webview）

  * 文件导入、预览与清洗报告
  * 分配策略配置与模拟（Dry-run）
  * 设备管理（ADB 设备列表、容量、标签）
  * 批次导出与导入执行/可视化进度
  * 查询检索（按设备、按号码、按行业、按批次）

* 后端（Rust，`#[tauri::command]`）

  * 号码规范化与校验
  * 去重与分配（含策略插件）
  * 导出 VCF/CSV（按设备分片）
  * ADB 控制（枚举设备、push 文件、触发导入、结果校验、日志）
  * 审计与错误处理

* 存储（SQLite）

  * WAL、唯一索引、审计日志
  * 表：`contacts`、`devices`、`assignments`、`imports`、`import_items`、`industry_rules`、`source_files`、`jobs`、`audit_logs`

---

# 三、数据模型（SQLite DDL，核心表）

> 关键点：
>
> * **`contacts.normalized` 全局唯一**（E.164 规范化）
> * **跨设备不重复**：`assignments(normalized)` 也加唯一，保证一个号码至多分配到一个设备（或使用 UNIQUE(normalized, device_id) + 触发器控制上限K）

```sql
-- db/schema.sql
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;
PRAGMA temp_store = MEMORY;

-- 号码主表：全局池
CREATE TABLE IF NOT EXISTS contacts (
  id            INTEGER PRIMARY KEY,
  normalized    TEXT NOT NULL UNIQUE,              -- E.164，如 +886912345678
  display_name  TEXT,                              -- 可选：导出时的姓名
  raw_example   TEXT,                              -- 第一次出现的原始文本
  source_tag    TEXT,                              -- 数据来源标记（文件名/渠道）
  industry_tag  TEXT,                              -- 行业分类（规则引擎产出）
  quality_score REAL,                              -- 质量评分（可选）
  created_at    TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at    TEXT NOT NULL DEFAULT (datetime('now'))
);

-- 源文件记录（便于追溯）
CREATE TABLE IF NOT EXISTS source_files (
  id          INTEGER PRIMARY KEY,
  filename    TEXT NOT NULL,
  total_lines INTEGER NOT NULL DEFAULT 0,
  accepted    INTEGER NOT NULL DEFAULT 0,          -- 经清洗后纳入 contacts 的数量（去重后）
  rejected    INTEGER NOT NULL DEFAULT 0,          -- 无效/脏数据/重复本次
  created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

-- 设备表（ADB 设备）
CREATE TABLE IF NOT EXISTS devices (
  id            INTEGER PRIMARY KEY,
  adb_serial    TEXT NOT NULL UNIQUE,             -- 例如 emulator-5554 / 123456F...
  label         TEXT,                             -- 显示名称
  capacity_hint INTEGER,                          -- 容量建议（上限）
  tags          TEXT,                             -- JSON/CSV，设备标签（行业/地区等）
  created_at    TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at    TEXT NOT NULL DEFAULT (datetime('now'))
);

-- 分配表：把联系人分配到哪个设备
CREATE TABLE IF NOT EXISTS assignments (
  id           INTEGER PRIMARY KEY,
  contact_id   INTEGER NOT NULL,
  device_id    INTEGER NOT NULL,
  normalized   TEXT NOT NULL UNIQUE,              -- 强制“一个号码全局只分配一次”约束
  status       TEXT NOT NULL DEFAULT 'planned',   -- planned/exported/pushed/importing/success/failed
  last_error   TEXT,
  created_at   TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at   TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(contact_id) REFERENCES contacts(id),
  FOREIGN KEY(device_id)  REFERENCES devices(id)
);

-- 导入批次：一次面向多设备的导出/导入任务
CREATE TABLE IF NOT EXISTS imports (
  id          INTEGER PRIMARY KEY,
  name        TEXT,                               -- 批次名称，如 2025-09-26_批次A
  strategy    TEXT,                               -- 使用的分配策略 JSON
  created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

-- 批次-设备 明细：导出了哪些文件，统计多少条
CREATE TABLE IF NOT EXISTS import_items (
  id           INTEGER PRIMARY KEY,
  import_id    INTEGER NOT NULL,
  device_id    INTEGER NOT NULL,
  file_path    TEXT,                              -- 本地导出的 vcf/csv 路径
  exported     INTEGER NOT NULL DEFAULT 0,
  pushed       INTEGER NOT NULL DEFAULT 0,
  imported_ok  INTEGER NOT NULL DEFAULT 0,
  failed       INTEGER NOT NULL DEFAULT 0,
  created_at   TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(import_id) REFERENCES imports(id),
  FOREIGN KEY(device_id) REFERENCES devices(id)
);

-- 行业分类规则（可热更新）
CREATE TABLE IF NOT EXISTS industry_rules (
  id          INTEGER PRIMARY KEY,
  rule_name   TEXT NOT NULL,
  rule_type   TEXT NOT NULL,         -- prefix/regex/contains/area_code/custom
  rule_value  TEXT NOT NULL,         -- 例如 ^(\\+8869) 开头
  output_tag  TEXT NOT NULL,         -- 例如 "电商/外呼"
  priority    INTEGER NOT NULL DEFAULT 100,
  enabled     INTEGER NOT NULL DEFAULT 1
);

-- 作业与审计（可选，便于排错和回放）
CREATE TABLE IF NOT EXISTS jobs (
  id          INTEGER PRIMARY KEY,
  job_type    TEXT NOT NULL,         -- import/assign/export/push/device-scan...
  payload     TEXT,                  -- JSON
  status      TEXT NOT NULL DEFAULT 'queued',
  result      TEXT,
  created_at  TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS audit_logs (
  id          INTEGER PRIMARY KEY,
  actor       TEXT,                  -- user/system
  action      TEXT,
  detail      TEXT,
  created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);
```

> 如果你想允许“一个号码可分配到最多K台设备”，把 `assignments.normalized` 的 UNIQUE 改为 UNIQUE(normalized, device_id)，再用触发器限制每个 normalized 最多 K 条。

---

# 四、关键流程（端到端）

## 4.1 导入与清洗（入库）

1. 选择 `.txt` 文件（每行一个号码或“姓名,号码”）
2. **规范化**（E.164），过滤脏数据（非数字、无效区号）。
3. 写入 `contacts(normalized)`：`INSERT OR IGNORE`（保证全局去重）
4. 首次出现则填 `raw_example`、`display_name`、`source_tag`；并**执行行业规则**打 `industry_tag`。
5. `source_files` 记录文件统计（总行、接受、拒绝）。

## 4.2 分配（跨设备不重复）

1. 枚举 `devices`（ADB 设备在线状态）
2. 选择**分配策略**（后文）
3. 在事务内，按策略把**未分配**的 `contacts` 生成 `assignments`（`status=planned`）
4. 事务提交后，UI 显示可导出/导入的明细（设备 → 数量、行业分布）

## 4.3 导出（VCF/CSV）

* 为每台设备导出一个或多个文件（按上限分片，如每 5K 条一个 vcf）。
* 写入 `imports` + `import_items`；对应 `assignments` 置 `status=exported`。

## 4.4 推送与导入（ADB）

* `adb push` 到 `/sdcard/Download/…/*.vcf`
* 触发系统导入（见后文三种方式）→ 更新 `assignments.status` 为 `importing`
* 导入完成做**校验**（可选：抽样或全量比对），成功则 `success`，失败记录 `last_error` 并可重试/改派。

---

# 五、号码规范化（E.164）

* 基础规则：剔除空白与分隔符，仅保留 `+` 和数字；
  无国家码时按“**默认地区**”补齐（在设置里选 CN/TW/US 等）；去前导 0（视国家规则）。
* **推荐**：用 Rust `phonenumber`（libphonenumber 数据）进一步校验与格式化。
* `contacts.normalized` 就用 E.164 结果，确保跨批次一致去重。

**Rust 示例（简化版，含中文注释 & 文件头）**：

```rust
// src-tauri/src/phone_norm.rs
/// 号码规范化：尝试使用 `phonenumber`；失败则按简易规则处理。
use phonenumber::{parse, Mode, country, PhoneNumber};

pub fn normalize(raw: &str, default_region: &str) -> Option<String> {
    let cleaned: String = raw.chars()
        .filter(|c| c.is_ascii_digit() || *c == '+')
        .collect();

    if cleaned.is_empty() { return None; }

    // 优先使用 libphonenumber
    if let Ok(region) = country::Id::from_str(default_region) {
        if let Ok(num) = parse(Some(region), &cleaned) {
            return Some(num.format().mode(Mode::E164).to_string());
        }
    }
    // 兜底：如果没有 +，按默认地区补国家码（示例：TW=886/CN=86/US=1）
    let with_cc = if cleaned.starts_with('+') {
        cleaned
    } else {
        match default_region {
            "TW" => format!("+886{}", cleaned.trim_start_matches('0')),
            "CN" => format!("+86{}", cleaned.trim_start_matches('0')),
            "US" => format!("+1{}", cleaned.trim_start_matches('0')),
            _    => format!("+{}", cleaned.trim_start_matches('0')),
        }
    };
    // 粗检长度
    if with_cc.len() < 7 { return None; }
    Some(with_cc)
}
```

---

# 六、分配策略（可插拔）

常见策略（可组合）：

* **均衡（Round-Robin / 按容量加权）**：考虑 `devices.capacity_hint`。
* **行业优先**：让特定行业优先流向带有某些 `tags` 的设备。
* **地区/号段**：按国家码/前缀/归属地聚类分配。
* **排除规则**：某设备禁收某些行业或号段。
* **去重约束**：同一 normalized **仅能拥有一个 assignment**（核心约束已由 DB 唯一索引保证）。

**分配伪代码（事务内）**：

```rust
// src-tauri/src/assign.rs
/// 输入：未分配 contacts 列表、在线设备及策略
/// 输出：写入 assignments（status=planned），保证 normalized 全局唯一
pub fn assign_contacts(conn: &rusqlite::Connection, strategy: &Strategy) -> Result<()> {
    let tx = conn.unchecked_transaction()?;
    // 1) 取未分配的联系人（可分批）
    // 2) 根据策略把每个联系人选择 device_id
    // 3) INSERT INTO assignments (contact_id, device_id, normalized, status='planned')
    //    normalized UNIQUE 保障跨设备不重复
    tx.commit()?;
    Ok(())
}
```

---

# 七、行业分类（先规则，后扩展）

* 在入库/更新时执行 `industry_rules`：

  * `prefix`：如 `+8869` → “移动用户/营销”
  * `regex`：复杂匹配
  * `area_code`：结合号段库（可外置 CSV）
  * `contains`：当携带业务标记列（如姓名/备注中包含“汽车/培训”等）
* 命中最高优先级规则 → `contacts.industry_tag`。
* 后续可接本地 ML 模型或第三方字典，但规则先行最稳。

---

# 八、VCF/CSV 导出

* **VCF 版本**：建议 vCard 3.0（兼容性较好）；4.0 也可配置。
* **字段**：`FN`（显示名，可用行业+尾号）、`TEL;TYPE=CELL`（E.164 号码）。
* **分片**：每 N 条生成一个文件，便于大批导入。
* **命名**：`exports/<批次>/<serial>/<serial>_part001.vcf`

VCF 示例（一条）：

```
BEGIN:VCARD
VERSION:3.0
FN:电商-98678
TEL;TYPE=CELL:+886912345678
END:VCARD
```

---

# 九、ADB 导入（三种方式，自动回退）

> Android 厂商各异，推荐**“层层回退”策略**：

**方式 A（首选，系统意图）：**

* `adb push` VCF 到 `/sdcard/Download/xxx.vcf`
* 触发导入：

  ```
  adb -s <serial> shell am start \
    -a android.intent.action.VIEW \
    -d "file:///sdcard/Download/xxx.vcf" \
    -t "text/x-vcard"
  ```

  * 有些 Android 11+ 对 `file://` 更严格；可尝试 `content://` 或让用户授权“文件管理器”打开。
  * 进入联系人导入 UI，可能需要一次**模拟点击确认**（可配合 uiautomator/scrcpy/Accessibility）。

**方式 B（厂商私有导入 Activity，自动探测）：**

* 动态用 `adb shell cmd package resolve-activity` / `pm dump` 搜索 `contacts` 包里带有 `ImportVCard` 之类的 Activity，若存在，直接 `am start -n <pkg>/<activity>`。
* 各厂商类名不一，**程序内做自动探测**并缓存。

**方式 C（UI 自动化回退）：**

* 打开“联系人”App → 导入/导出 → 选择 VCF → 确认
* 配合 `uiautomator dump` + 坐标点击 或 scrcpy 辅助。
* 作为兜底，在 A/B 失败时使用。

**导入结果校验（可选）**：

* 简单：导入后抽样拨打 `content query` 检查是否存在对应号码（有的系统允许 shell 读取查询，有的受限）。
* 可靠：把**导入确认**当作“人工/半自动确认”事件，点击“已完成”→ 更新 `assignments.status=success`。
* 若能查询：

  ```
  adb -s <serial> shell content query --uri content://com.android.contacts/data/phones
  ```

  *注意权限差异；不是所有机型都放行。*

---

# 十、并发与健壮性

* SQLite：开启 WAL，**按设备并行**，但每个设备一个导入队列；
* 导出/推送/导入**分阶段**、可重试；
* 大文件：每 5k~10k 分片，减少失败影响面；
* 状态机：`planned → exported → pushed → importing → success/failed`；失败可回滚到 `planned` 重新分派或重试。

---

# 十一、查询与报表（你关心的提问）

* **哪个手机导入了哪些号码？**

  ```sql
  SELECT d.label, c.normalized, c.industry_tag, a.status, a.updated_at
  FROM assignments a
  JOIN devices d   ON a.device_id = d.id
  JOIN contacts c  ON a.contact_id = c.id
  WHERE d.adb_serial = ?;
  ```

* **不同手机之间不重复**（由 `assignments.normalized` UNIQUE 强制保障）。
  若某号码尝试再次分配，会在插入时报唯一约束错误 → 记录审计与告警。

* **某号码在哪台设备？**

  ```sql
  SELECT d.label, d.adb_serial, a.status
  FROM assignments a
  JOIN devices d ON a.device_id = d.id
  WHERE a.normalized = ?;
  ```

* **导入批次追踪**：
  `imports` + `import_items` 按批次、设备、文件的导出/推送/导入统计。

---

# 十二、Tauri 模块划分（建议）

前端（React/Vue 任一）：

* `Screens/FilesIngest`：文件上传、预览、清洗统计
* `Screens/Rules`：行业规则管理（增删改、优先级）
* `Screens/Devices`：ADB 设备扫描、容量/标签设置、在线状态
* `Screens/Assign`：选择策略、Dry-run 模拟、执行分配
* `Screens/Exports`：生成 VCF/CSV、分片与目录
* `Screens/ImportRunner`：ADB 推送与导入进度（设备×文件）
* `Screens/Search`：按号码/设备/行业/批次的查询
* `Screens/Audit`：作业与审计日志

后端（Rust）：

* `db.rs`：SQLite 连接/迁移/查询封装
* `phone_norm.rs`：号码规范化
* `industry.rs`：行业规则匹配
* `assign.rs`：分配策略（接口+实现）
* `exporter.rs`：VCF/CSV 生成
* `adb.rs`：ADB 工具（devices、push、start activity、回退）
* `commands.rs`：Tauri `#[tauri::command]` 对外 API
* `jobs.rs`：作业调度与状态机

---

# 十三、示例：Tauri 后端指令（骨架）

```rust
// src-tauri/src/commands.rs
//! Tauri 对外指令：文件导入/分配/导出/导入/查询

use tauri::State;

#[tauri::command]
pub fn ingest_file(path: String, default_region: String, state: State<AppState>) -> Result<IngestReport, String> {
    // 逐行读取 → normalize → INSERT OR IGNORE contacts
    // 命中 industry_rules → 更新 contacts.industry_tag
    // 写 source_files 统计
    // 返回报告（总行、接受、拒绝、去重）
    Ok(IngestReport::default())
}

#[tauri::command]
pub fn assign_contacts(strategy_json: String, state: State<AppState>) -> Result<AssignReport, String> {
    // 解析策略 → 事务内写 assignments（status=planned）
    Ok(AssignReport::default())
}

#[tauri::command]
pub fn export_vcf(import_name: String, per_chunk: usize, state: State<AppState>) -> Result<ExportReport, String> {
    // 每设备生成 vcf，写 imports/import_items，status=exported
    Ok(ExportReport::default())
}

#[tauri::command]
pub fn adb_push_and_import(import_id: i64, state: State<AppState>) -> Result<ImportRunReport, String> {
    // 遍历 import_items → adb push → 触发导入（A→B→C回退）→ 更新 assignments & import_items
    Ok(ImportRunReport::default())
}

#[tauri::command]
pub fn query_device_contacts(adb_serial: String, state: State<AppState>) -> Result<Vec<DeviceContactRow>, String> {
    // SELECT 连接 assignments + contacts + devices
    Ok(vec![])
}
```

---

# 十四、ADB 工具（片段）

```rust
// src-tauri/src/adb.rs
//! ADB 封装：列设备、push、启动导入

use std::process::Command;

pub fn list_devices() -> Vec<String> {
    // adb devices -l → 解析出 online 的 serial
    vec![]
}

pub fn adb_push(serial: &str, local: &str, remote: &str) -> anyhow::Result<()> {
    let status = Command::new("adb")
        .args(["-s", serial, "push", local, remote])
        .status()?;
    if !status.success() { anyhow::bail!("adb push failed"); }
    Ok(())
}

pub fn start_import_by_view(serial: &str, remote_vcf: &str) -> anyhow::Result<()> {
    // 方式A：VIEW text/x-vcard
    let status = Command::new("adb")
        .args(["-s", serial, "shell", "am", "start",
            "-a", "android.intent.action.VIEW",
            "-d", &format!("file://{}", remote_vcf),
            "-t", "text/x-vcard"])
        .status()?;
    if !status.success() { anyhow::bail!("am start failed"); }
    Ok(())
}
```

---

# 十五、配置与参数

* `default_region`（TW/CN/US…）
* `capacity_hint`（每台设备上限）
* `export.per_chunk`（VCF 分片大小）
* `strategy`（均衡/按行业/按地区，JSON 配置）
* `adb.path`（可自带 platform-tools）
* `rules`（行业规则文件加载/增删改）

---

# 十六、隐私与合规（强烈建议）

* 明确数据来源和使用目的，遵守当地法律法规；
* 数据库存放与备份加密；
* 导出文件保存在用户指定目录；
* 审计日志避免记录完整号码（可掩码显示）。

---

# 十七、开发任务清单（建议里程碑）

**M0 基础设施**

* [ ] 集成 SQLite（WAL）、迁移脚本
* [ ] `phonenumber` 规范化模块
* [ ] 行业规则加载与匹配

**M1 数据引入 & 查询**

* [ ] `.txt` 文件导入（解析/清洗/入库/统计）
* [ ] 查询页：按号码/设备/行业/批次

**M2 分配引擎**

* [ ] 均衡/容量策略
* [ ] 行业/地区偏置策略
* [ ] DB 级唯一约束与冲突处理

**M3 导出**

* [ ] VCF/CSV 生成与分片
* [ ] 批次管理（imports/import_items）

**M4 ADB 集成**

* [ ] 设备发现、push、导入（A→B→C 回退）
* [ ] 进度与可重试
* [ ] 导入结果校验与状态机

**M5 可靠性 & UX**

* [ ] 断点续传、失败回收
* [ ] 审计日志、报表导出（CSV/Excel）
* [ ] 配置界面 & 角色权限（可选）

---

# 十八、你现在就能用的查询/能力

* 「**哪个手机导入了哪些号码**」→ 上文 SQL
* 「**不同手机不重复**」→ DB 结构天然保障
* 「**如何自动分配手机**」→ 选策略（均衡/容量/行业/地区）
* 「**如何给号码添加行业分类**」→ 设置 `industry_rules`，入库时打标签

---

如果你需要，我可以**按上述模块**给你**初始项目骨架代码**（Tauri + Rust + SQLite），包含：

* 数据库初始化与迁移
* `#[tauri::command]` 接口
* 号码规范化与行业规则引擎（基础）
* 分配器（均衡 + 容量）
* VCF 导出器
* ADB 适配器（A/B/C 回退策略）

每个文件我都会**在第一行写上文件名路径**，并配上**详细中文注释**。你只要说一声“上代码”。
