"empty_self"情况下向下一步传递父/子/邻接线索：

可能不仅仅是 "empty_self" 而是各个字段评分都不够好。
会这样吗？刚刚你考虑到了这点了吗？

会的，而且你说得对：不仅“empty_self”（自身几乎没信息）要把**父/子/邻接线索**传给下一步，**当各字段都“不够好”**时也应该同时准备这些线索。我刚才的设计里涵盖了这个思路，不过没把“弱自我”单独命名。下面把它讲清楚并给出可执行规则。

# 我们区分两种场景

1. **empty_self**：自身几乎没可用属性（id/text/desc/class…都空或无效）。
   → 直接产出 `relationSeed`，把线索交给“关系锚定”。

2. **weak_self（弱自我）**：有属性，但**组合分不高**、**预估匹配数仍>1**、**稳定性差**（比如列表重复、动态文本、混淆id）。
   → **双轨输出**：既给出自我锚定候选（以防能用），又**同时**附上 `relationSeed` 作为备用，让下一步随时可切换。

# 何时判定 weak_self？

建议用这三条其一即触发（可配置）：

* **最佳候选分 < 0.78**（单字段/组合都不够稳）；
* **expectedCount > 3 且 top-gap < 0.10**（重复多且区分度差）；
* **稳定性 < 0.6**（如 id 有 `_obfuscated`/`item_`/动态 text，比重扣分）。

> 以上阈值与你当前口径相容；可以把它们放进 `config/self_anchor.yaml`。

# 产物怎么携带到下一步？

无论是 **empty_self** 还是 **weak_self**，都在 `SelfAnchorPlan` 里“同时”带上 `relationSeed` 和一个**切换策略**说明：

* `relationSeed.parentHints`：可点父/容器的 class/id/xpath 片段
* `relationSeed.childHints`：子级的强语义文本/desc/icon类型
* `relationSeed.neighborHints`：同层左右的标签文本/角色
* （可选）`relationSeed.regionBounds`：容器几何，便于限域
* `handoverPolicy`：什么时候把接力棒交给“关系锚定”（**eager** 立即、**lazy** 仅当真机闸门失败）

# 真机阶段的切换规则（闸门里执行）

* **count==0** 或 **count≫1 且 top-gap 仍低** → 切到关系锚定
* 精准模式下，**指纹比对失败**（IoU/祖先签名不匹配）→ 切到关系锚定
* 批量模式，**重复>阈值**且**单体分过低** → 先用关系锚定收窄范围再批量

# 极简示例（便于你落地）

```json
{
  "self_anchor": {
    "status": "weak_self",
    "candidates": [
      {"selector": "//*[@resource-id='btn_follow']", "expectedCount": 6, "score": 0.71}
    ],
    "duplicateOrder": "reading",
    "fingerprint": { "ancestryPathSig": "A1B2...", "tapBounds": {"left":860,"top":2240,"right":1080,"bottom":2358} },
    "relationSeed": {
      "parentHints": ["//card[@class='FeedItemRoot']"],
      "childHints":  ["desc='关注'","text='关注'"],
      "neighborHints": ["preceding-sibling::label[text()='作者']"]
    },
    "handoverPolicy": "lazy"  // 先试自我锚定，闸门失败再切
  }
}
```

# 小结（一句话原则）

* **empty_self**：直接把“关系线索”交出去。
* **weak_self**：**双轨**——“自我锚定候选 + 关系线索”一起交付，并在真机阶段按闸门条件**自动切换**。
* 这样做的好处是：**不走死路、不中断流程**，并且为“第一个/批量/精准”三模式都留好了退路与加固空间。

如果你愿意，我下一步可以把 `status: 'weak_self'`、`handoverPolicy` 和 `relationSeed` 的数据结构补到你现有的 `SelfAnchorPlan` 类型里，并给出对应的最小代码改动清单。


还有就是，后端是如何分析的？是不是前端发来静态分析的绝对全局Xpaht你开始分析？
然后父/子元素信息 需要在这一步提供给下一步吗？ 还是前端直接就提供了足够信息呢？