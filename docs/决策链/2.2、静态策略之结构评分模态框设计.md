我来帮你设计这个**结构评分系统**的模块化架构。让我先查看现有文档，然后给出完整的设计方案。 

读取 [](file:///d%3A/rust/active-projects/%E5%B0%8F%E7%BA%A2%E4%B9%A6/employeeGUI/docs/%E5%86%B3%E7%AD%96%E9%93%BE/2.1%E3%80%81%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5%E4%B9%8B%E7%BB%93%E6%9E%84%E8%AF%84%E5%88%86%E6%A8%A1%E6%80%81%E6%A1%86.md)

读取 [](file:///d%3A/rust/active-projects/%E5%B0%8F%E7%BA%A2%E4%B9%A6/employeeGUI/docs/%E5%86%B3%E7%AD%96%E9%93%BE/2.2%E3%80%81%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5%E4%B9%8B%E7%BB%93%E6%9E%84%E8%AF%84%E5%88%86%E6%A8%A1%E6%80%81%E6%A1%86.md)

Thinking

好的!让我给你设计一个完整的**结构评分系统**模块化架构。

## 🏗️ 模块化架构设计

### **方案概览**
基于你的需求和项目DDD架构，我建议采用**独立模块**设计：

```
📦 structural-matching (结构匹配模块)
├── 前端模块: src/modules/structural-matching/
└── 后端模块: src-tauri/src/modules/structural_matching/
```

---

## 📂 前端模块结构 (TypeScript/React)

```typescript
src/modules/structural-matching/
├── domain/                                   # 领域层 (纯逻辑)
│   ├── models/
│   │   ├── structural-field-config.ts       # 字段配置模型 ⭐
│   │   ├── structural-scoring-rule.ts       # 评分规则模型
│   │   ├── structural-match-result.ts       # 匹配结果
│   │   └── structural-template.ts           # 结构模板
│   ├── constants/
│   │   ├── field-types.ts                   # 字段类型常量
│   │   ├── scoring-weights.ts               # 默认权重
│   │   └── match-modes.ts                   # 匹配模式
│   └── validators/
│       └── structural-config-validator.ts   # 配置验证
│
├── application/                              # 应用层 (用例)
│   ├── create-structural-rule.ts            # 创建规则用例
│   ├── update-structural-rule.ts            # 更新规则用例
│   ├── preview-structural-score.ts          # 预览评分
│   └── apply-structural-rule.ts             # 应用规则到步骤
│
├── ui/                                       # UI层 (组件)
│   ├── components/
│   │   ├── structural-matching-modal/       # 主模态框 ⭐⭐⭐
│   │   │   ├── index.tsx                    # 入口
│   │   │   ├── structural-matching-modal.tsx
│   │   │   ├── element-structure-tree.tsx   # 元素结构树
│   │   │   ├── field-config-panel.tsx       # 字段配置面板
│   │   │   ├── field-config-item.tsx        # 单个字段配置
│   │   │   ├── scoring-preview.tsx          # 评分预览
│   │   │   ├── rule-summary.tsx             # 规则摘要
│   │   │   └── styles.module.css
│   │   │
│   │   ├── structural-strategy-selector/    # 策略选择器
│   │   │   ├── index.tsx
│   │   │   └── structural-strategy-selector.tsx
│   │   │
│   │   └── structural-rule-badge/           # 规则徽章 (显示在步骤卡片)
│   │       ├── index.tsx
│   │       └── structural-rule-badge.tsx
│   │
│   └── styles/
│       └── structural-matching-theme.css    # 主题样式
│
├── hooks/                                    # Hooks
│   ├── use-structural-matching-modal.ts     # 模态框状态管理 ⭐
│   ├── use-structural-field-config.ts       # 字段配置管理
│   ├── use-structural-preview.ts            # 实时预览
│   └── use-structural-template.ts           # 模板管理
│
├── services/                                 # 服务层
│   ├── structural-matching-api.ts           # Tauri API 调用
│   ├── structural-storage.ts                # 本地存储
│   └── structural-preset.ts                 # 预设模板
│
└── index.ts                                  # 统一导出
```

---

## 🦀 后端模块结构 (Rust)

```rust
src-tauri/src/modules/structural_matching/
├── domain/                                   # 领域层
│   ├── models/
│   │   ├── structural_pattern.rs            # 结构模式
│   │   ├── field_scoring_rule.rs            # 字段评分规则 ⭐
│   │   ├── scoring_config.rs                # 评分配置
│   │   └── match_result.rs                  # 匹配结果
│   │
│   ├── enums/
│   │   ├── field_type.rs                    # 字段类型枚举
│   │   ├── match_mode.rs                    # 匹配模式
│   │   └── score_weight.rs                  # 权重级别
│   │
│   └── validators/
│       └── structural_validator.rs          # 结构验证
│
├── application/                              # 应用层 (用例)
│   ├── calculate_structural_score.rs        # 计算评分 ⭐⭐
│   ├── match_structural_elements.rs         # 匹配元素
│   ├── filter_by_structure.rs               # 结构过滤
│   └── analyze_element_structure.rs         # 分析元素结构
│
├── services/                                 # 服务层
│   ├── structural_matching_service.rs       # 主服务 ⭐⭐⭐
│   ├── field_scorer.rs                      # 字段评分器
│   │   ├── resource_id_scorer.rs            # Resource-ID 评分
│   │   ├── content_desc_scorer.rs           # Content-Desc 评分
│   │   ├── text_scorer.rs                   # Text 评分
│   │   └── children_structure_scorer.rs     # 子元素结构评分
│   │
│   └── structure_analyzer.rs                # 结构分析器
│
├── infrastructure/                           # 基础设施
│   ├── structural_cache.rs                  # 缓存
│   └── structural_logger.rs                 # 日志
│
├── commands/                                 # Tauri Commands
│   ├── create_structural_rule.rs            # 创建规则
│   ├── preview_structural_match.rs          # 预览匹配
│   └── execute_structural_match.rs          # 执行匹配
│
└── mod.rs                                    # 模块导出
```

---

## 📊 核心数据模型设计

### **1. 字段配置模型 (前端)**

```typescript
// src/modules/structural-matching/domain/models/structural-field-config.ts

export enum FieldType {
  RESOURCE_ID = 'resource_id',
  CONTENT_DESC = 'content_desc',
  TEXT = 'text',
  CLASS_NAME = 'class_name',
  CHILDREN_STRUCTURE = 'children_structure',
  BOUNDS = 'bounds',  // 虽然不用,但保留以便扩展
}

export enum MatchMode {
  EXACT = 'exact',           // 值完全相同
  NON_EMPTY = 'non_empty',   // 都非空即可
  EMPTY = 'empty',           // 都为空即可
  STRUCTURE = 'structure',   // 结构匹配 (用于子元素)
  DISABLED = 'disabled',     // 不参与匹配
}

export interface ScoringRules {
  exactMatch: number;          // 值完全一样 (大分)
  bothNonEmpty: number;        // 都非空但值不同 (小分)
  bothEmpty: number;           // 都为空 (小分)
  mismatchPenalty: number;     // 一个空一个非空 (负分)
}

export interface StructuralFieldConfig {
  fieldType: FieldType;
  enabled: boolean;            // 是否参与评分
  matchMode: MatchMode;        // 匹配模式
  weight: number;              // 字段权重 (0-1)
  scoringRules: ScoringRules;  // 评分细则
  displayName: string;         // 显示名称
  description?: string;        // 说明
}

export interface StructuralMatchingConfig {
  configId: string;
  templateElementId: string;   // 模板元素ID (用户点选的元素)
  templateStructure: any;      // 模板元素完整结构
  fields: StructuralFieldConfig[];  // 各字段配置
  globalThreshold: number;     // 全局阈值 (0-1)
  createdAt: number;
  updatedAt: number;
}
```

### **2. 评分规则模型 (后端)**

```rust
// src-tauri/src/modules/structural_matching/domain/models/field_scoring_rule.rs

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FieldType {
    ResourceId,
    ContentDesc,
    Text,
    ClassName,
    ChildrenStructure,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MatchMode {
    Exact,           // 值完全相同
    NonEmpty,        // 都非空即可
    Empty,           // 都为空即可
    Structure,       // 结构匹配
    Disabled,        // 不参与
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringRules {
    pub exact_match: f64,        // 值完全一样 (如 0.3)
    pub both_non_empty: f64,     // 都非空但不同 (如 0.1)
    pub both_empty: f64,         // 都为空 (如 0.05)
    pub mismatch_penalty: f64,   // 空/非空不匹配 (如 -0.2)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FieldScoringRule {
    pub field_type: FieldType,
    pub enabled: bool,
    pub match_mode: MatchMode,
    pub weight: f64,             // 权重
    pub scoring_rules: ScoringRules,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructuralMatchingConfig {
    pub config_id: String,
    pub template_element: serde_json::Value,  // 模板元素
    pub fields: Vec<FieldScoringRule>,
    pub global_threshold: f64,
}
```

---

## 🎯 核心功能实现

### **功能1: 模态框UI (前端)**

```typescript
// src/modules/structural-matching/ui/components/structural-matching-modal/index.tsx

export const StructuralMatchingModal: React.FC<Props> = ({ 
  visible, 
  selectedElement, 
  onConfirm, 
  onCancel 
}) => {
  const {
    config,
    updateFieldConfig,
    toggleField,
    previewScore,
  } = useStructuralMatchingModal(selectedElement);

  return (
    <Modal
      title="结构匹配配置"
      open={visible}
      width={900}
      onOk={() => onConfirm(config)}
      onCancel={onCancel}
    >
      <div className="structural-matching-container">
        {/* 左侧: 元素结构树 */}
        <div className="structure-tree-panel">
          <ElementStructureTree element={selectedElement} />
        </div>

        {/* 右侧: 字段配置 */}
        <div className="field-config-panel">
          <h3>字段配置</h3>
          {config.fields.map(field => (
            <FieldConfigItem
              key={field.fieldType}
              field={field}
              onToggle={() => toggleField(field.fieldType)}
              onChange={(updated) => updateFieldConfig(field.fieldType, updated)}
            />
          ))}
        </div>

        {/* 底部: 评分预览 */}
        <div className="scoring-preview-panel">
          <ScoringPreview config={config} previewScore={previewScore} />
        </div>
      </div>
    </Modal>
  );
};
```

### **功能2: 字段评分器 (后端)**

```rust
// src-tauri/src/modules/structural_matching/services/field_scorer.rs

pub struct FieldScorer;

impl FieldScorer {
    /// Resource-ID 评分
    pub fn score_resource_id(
        template_id: &Option<String>,
        candidate_id: &Option<String>,
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        match (&template_id, &candidate_id) {
            // 值完全一样 (大分)
            (Some(t), Some(c)) if t == c => {
                rule.scoring_rules.exact_match * rule.weight
            },
            // 都非空但不同 (小分)
            (Some(_), Some(_)) => {
                rule.scoring_rules.both_non_empty * rule.weight
            },
            // 都为空 (小分)
            (None, None) => {
                rule.scoring_rules.both_empty * rule.weight
            },
            // 一个空一个非空 (负分)
            _ => {
                rule.scoring_rules.mismatch_penalty * rule.weight
            },
        }
    }

    /// Content-Desc 评分 (非空即可)
    pub fn score_content_desc(
        template_desc: &Option<String>,
        candidate_desc: &Option<String>,
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        match rule.match_mode {
            MatchMode::Exact => {
                // 完全匹配模式
                Self::score_resource_id(template_desc, candidate_desc, rule)
            },
            MatchMode::NonEmpty => {
                // 非空模式: 只要都非空就给分
                match (&template_desc, &candidate_desc) {
                    (Some(t), Some(c)) if !t.is_empty() && !c.is_empty() => {
                        rule.scoring_rules.both_non_empty * rule.weight
                    },
                    (None, None) => {
                        rule.scoring_rules.both_empty * rule.weight
                    },
                    _ => {
                        rule.scoring_rules.mismatch_penalty * rule.weight
                    },
                }
            },
            _ => 0.0,
        }
    }

    /// Text 评分 (非空/空状态一致)
    pub fn score_text(
        template_text: &Option<String>,
        candidate_text: &Option<String>,
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        // 不检查具体文本,只检查非空/空状态
        match (&template_text, &candidate_text) {
            (Some(t), Some(c)) if !t.is_empty() && !c.is_empty() => {
                rule.scoring_rules.both_non_empty * rule.weight
            },
            (None, None) | (Some(t), Some(c)) if t.is_empty() && c.is_empty() => {
                rule.scoring_rules.both_empty * rule.weight
            },
            _ => {
                rule.scoring_rules.mismatch_penalty * rule.weight
            },
        }
    }

    /// 子元素结构评分
    pub fn score_children_structure(
        template_children: &[ElementChild],
        candidate_children: &[ElementChild],
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        // 检查结构相似度
        let template_structure = Self::extract_structure_signature(template_children);
        let candidate_structure = Self::extract_structure_signature(candidate_children);

        if template_structure == candidate_structure {
            rule.scoring_rules.exact_match * rule.weight
        } else {
            rule.scoring_rules.mismatch_penalty * rule.weight
        }
    }

    /// 提取结构签名 (类名序列)
    fn extract_structure_signature(children: &[ElementChild]) -> Vec<String> {
        children.iter()
            .map(|child| child.class_name.clone())
            .collect()
    }
}
```

### **功能3: 结构匹配服务 (后端)**

```rust
// src-tauri/src/modules/structural_matching/services/structural_matching_service.rs

pub struct StructuralMatchingService;

impl StructuralMatchingService {
    /// 执行结构匹配
    pub fn match_elements(
        config: &StructuralMatchingConfig,
        candidates: Vec<UIElement>,
    ) -> Vec<ScoredElement> {
        let mut scored_elements = Vec::new();

        for candidate in candidates {
            let score = Self::calculate_score(config, &candidate);
            
            if score >= config.global_threshold {
                scored_elements.push(ScoredElement {
                    element: candidate,
                    score,
                    breakdown: Self::get_score_breakdown(config, &candidate),
                });
            }
        }

        // 按分数降序排序
        scored_elements.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());
        scored_elements
    }

    /// 计算总分
    fn calculate_score(
        config: &StructuralMatchingConfig,
        candidate: &UIElement,
    ) -> f64 {
        let mut total_score = 0.0;

        for rule in &config.fields {
            let field_score = match rule.field_type {
                FieldType::ResourceId => {
                    FieldScorer::score_resource_id(
                        &config.template_element.resource_id,
                        &candidate.resource_id,
                        rule,
                    )
                },
                FieldType::ContentDesc => {
                    FieldScorer::score_content_desc(
                        &config.template_element.content_desc,
                        &candidate.content_desc,
                        rule,
                    )
                },
                FieldType::Text => {
                    FieldScorer::score_text(
                        &config.template_element.text,
                        &candidate.text,
                        rule,
                    )
                },
                FieldType::ChildrenStructure => {
                    FieldScorer::score_children_structure(
                        &config.template_element.children,
                        &candidate.children,
                        rule,
                    )
                },
                _ => 0.0,
            };

            total_score += field_score;
        }

        total_score
    }
}
```

---

## 🔗 前后端协议

```typescript
// 前端 → 后端
interface StructuralMatchRequest {
  configId: string;
  config: StructuralMatchingConfig;
  mode: 'first' | 'last' | 'all' | 'random';
  xmlContent: string;  // 当前页面XML
}

// 后端 → 前端
interface StructuralMatchResponse {
  success: boolean;
  matched_elements: ScoredElement[];
  total_candidates: number;
  execution_time_ms: number;
}
```

---

## ✅ 设计优势

1. **✅ 模块化清晰**: domain/application/ui/services 分层
2. **✅ 可扩展性强**: 新增字段只需加配置,不改核心逻辑
3. **✅ 可测试性好**: 领域层纯函数,易于单元测试
4. **✅ 可维护性高**: 职责清晰,代码组织规范
5. **✅ 用户友好**: 模态框可视化配置,实时预览
6. **✅ 性能优化**: 支持缓存和增量计算

---

## 📝 实施建议

### **阶段1: 基础架构 (1-2天)**
- 创建目录结构
- 定义数据模型
- 实现基础评分器

### **阶段2: 核心功能 (2-3天)**
- 实现模态框UI
- 实现后端匹配服务
- 对接Tauri Command

### **阶段3: 集成测试 (1-2天)**
- 测试小红书笔记卡片匹配
- 性能优化
- 边界情况处理

### **阶段4: 用户体验 (1天)**
- 预设模板
- 导入/导出配置
- 帮助文档

---

你觉得这个设计如何? 需要调整哪些部分? 🚀