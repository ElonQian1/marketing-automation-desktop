æˆ‘æ¥å¸®ä½ è®¾è®¡è¿™ä¸ª**ç»“æ„è¯„åˆ†ç³»ç»Ÿ**çš„æ¨¡å—åŒ–æ¶æ„ã€‚è®©æˆ‘å…ˆæŸ¥çœ‹ç°æœ‰æ–‡æ¡£ï¼Œç„¶åç»™å‡ºå®Œæ•´çš„è®¾è®¡æ–¹æ¡ˆã€‚ 

è¯»å– [](file:///d%3A/rust/active-projects/%E5%B0%8F%E7%BA%A2%E4%B9%A6/employeeGUI/docs/%E5%86%B3%E7%AD%96%E9%93%BE/2.1%E3%80%81%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5%E4%B9%8B%E7%BB%93%E6%9E%84%E8%AF%84%E5%88%86%E6%A8%A1%E6%80%81%E6%A1%86.md)

è¯»å– [](file:///d%3A/rust/active-projects/%E5%B0%8F%E7%BA%A2%E4%B9%A6/employeeGUI/docs/%E5%86%B3%E7%AD%96%E9%93%BE/2.2%E3%80%81%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5%E4%B9%8B%E7%BB%93%E6%9E%84%E8%AF%84%E5%88%86%E6%A8%A1%E6%80%81%E6%A1%86.md)

Thinking

å¥½çš„!è®©æˆ‘ç»™ä½ è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„**ç»“æ„è¯„åˆ†ç³»ç»Ÿ**æ¨¡å—åŒ–æ¶æ„ã€‚

## ğŸ—ï¸ æ¨¡å—åŒ–æ¶æ„è®¾è®¡

### **æ–¹æ¡ˆæ¦‚è§ˆ**
åŸºäºä½ çš„éœ€æ±‚å’Œé¡¹ç›®DDDæ¶æ„ï¼Œæˆ‘å»ºè®®é‡‡ç”¨**ç‹¬ç«‹æ¨¡å—**è®¾è®¡ï¼š

```
ğŸ“¦ structural-matching (ç»“æ„åŒ¹é…æ¨¡å—)
â”œâ”€â”€ å‰ç«¯æ¨¡å—: src/modules/structural-matching/
â””â”€â”€ åç«¯æ¨¡å—: src-tauri/src/modules/structural_matching/
```

---

## ğŸ“‚ å‰ç«¯æ¨¡å—ç»“æ„ (TypeScript/React)

```typescript
src/modules/structural-matching/
â”œâ”€â”€ domain/                                   # é¢†åŸŸå±‚ (çº¯é€»è¾‘)
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ structural-field-config.ts       # å­—æ®µé…ç½®æ¨¡å‹ â­
â”‚   â”‚   â”œâ”€â”€ structural-scoring-rule.ts       # è¯„åˆ†è§„åˆ™æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ structural-match-result.ts       # åŒ¹é…ç»“æœ
â”‚   â”‚   â””â”€â”€ structural-template.ts           # ç»“æ„æ¨¡æ¿
â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â”œâ”€â”€ field-types.ts                   # å­—æ®µç±»å‹å¸¸é‡
â”‚   â”‚   â”œâ”€â”€ scoring-weights.ts               # é»˜è®¤æƒé‡
â”‚   â”‚   â””â”€â”€ match-modes.ts                   # åŒ¹é…æ¨¡å¼
â”‚   â””â”€â”€ validators/
â”‚       â””â”€â”€ structural-config-validator.ts   # é…ç½®éªŒè¯
â”‚
â”œâ”€â”€ application/                              # åº”ç”¨å±‚ (ç”¨ä¾‹)
â”‚   â”œâ”€â”€ create-structural-rule.ts            # åˆ›å»ºè§„åˆ™ç”¨ä¾‹
â”‚   â”œâ”€â”€ update-structural-rule.ts            # æ›´æ–°è§„åˆ™ç”¨ä¾‹
â”‚   â”œâ”€â”€ preview-structural-score.ts          # é¢„è§ˆè¯„åˆ†
â”‚   â””â”€â”€ apply-structural-rule.ts             # åº”ç”¨è§„åˆ™åˆ°æ­¥éª¤
â”‚
â”œâ”€â”€ ui/                                       # UIå±‚ (ç»„ä»¶)
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ structural-matching-modal/       # ä¸»æ¨¡æ€æ¡† â­â­â­
â”‚   â”‚   â”‚   â”œâ”€â”€ index.tsx                    # å…¥å£
â”‚   â”‚   â”‚   â”œâ”€â”€ structural-matching-modal.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ element-structure-tree.tsx   # å…ƒç´ ç»“æ„æ ‘
â”‚   â”‚   â”‚   â”œâ”€â”€ field-config-panel.tsx       # å­—æ®µé…ç½®é¢æ¿
â”‚   â”‚   â”‚   â”œâ”€â”€ field-config-item.tsx        # å•ä¸ªå­—æ®µé…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ scoring-preview.tsx          # è¯„åˆ†é¢„è§ˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ rule-summary.tsx             # è§„åˆ™æ‘˜è¦
â”‚   â”‚   â”‚   â””â”€â”€ styles.module.css
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ structural-strategy-selector/    # ç­–ç•¥é€‰æ‹©å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ index.tsx
â”‚   â”‚   â”‚   â””â”€â”€ structural-strategy-selector.tsx
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ structural-rule-badge/           # è§„åˆ™å¾½ç«  (æ˜¾ç¤ºåœ¨æ­¥éª¤å¡ç‰‡)
â”‚   â”‚       â”œâ”€â”€ index.tsx
â”‚   â”‚       â””â”€â”€ structural-rule-badge.tsx
â”‚   â”‚
â”‚   â””â”€â”€ styles/
â”‚       â””â”€â”€ structural-matching-theme.css    # ä¸»é¢˜æ ·å¼
â”‚
â”œâ”€â”€ hooks/                                    # Hooks
â”‚   â”œâ”€â”€ use-structural-matching-modal.ts     # æ¨¡æ€æ¡†çŠ¶æ€ç®¡ç† â­
â”‚   â”œâ”€â”€ use-structural-field-config.ts       # å­—æ®µé…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ use-structural-preview.ts            # å®æ—¶é¢„è§ˆ
â”‚   â””â”€â”€ use-structural-template.ts           # æ¨¡æ¿ç®¡ç†
â”‚
â”œâ”€â”€ services/                                 # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ structural-matching-api.ts           # Tauri API è°ƒç”¨
â”‚   â”œâ”€â”€ structural-storage.ts                # æœ¬åœ°å­˜å‚¨
â”‚   â””â”€â”€ structural-preset.ts                 # é¢„è®¾æ¨¡æ¿
â”‚
â””â”€â”€ index.ts                                  # ç»Ÿä¸€å¯¼å‡º
```

---

## ğŸ¦€ åç«¯æ¨¡å—ç»“æ„ (Rust)

```rust
src-tauri/src/modules/structural_matching/
â”œâ”€â”€ domain/                                   # é¢†åŸŸå±‚
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ structural_pattern.rs            # ç»“æ„æ¨¡å¼
â”‚   â”‚   â”œâ”€â”€ field_scoring_rule.rs            # å­—æ®µè¯„åˆ†è§„åˆ™ â­
â”‚   â”‚   â”œâ”€â”€ scoring_config.rs                # è¯„åˆ†é…ç½®
â”‚   â”‚   â””â”€â”€ match_result.rs                  # åŒ¹é…ç»“æœ
â”‚   â”‚
â”‚   â”œâ”€â”€ enums/
â”‚   â”‚   â”œâ”€â”€ field_type.rs                    # å­—æ®µç±»å‹æšä¸¾
â”‚   â”‚   â”œâ”€â”€ match_mode.rs                    # åŒ¹é…æ¨¡å¼
â”‚   â”‚   â””â”€â”€ score_weight.rs                  # æƒé‡çº§åˆ«
â”‚   â”‚
â”‚   â””â”€â”€ validators/
â”‚       â””â”€â”€ structural_validator.rs          # ç»“æ„éªŒè¯
â”‚
â”œâ”€â”€ application/                              # åº”ç”¨å±‚ (ç”¨ä¾‹)
â”‚   â”œâ”€â”€ calculate_structural_score.rs        # è®¡ç®—è¯„åˆ† â­â­
â”‚   â”œâ”€â”€ match_structural_elements.rs         # åŒ¹é…å…ƒç´ 
â”‚   â”œâ”€â”€ filter_by_structure.rs               # ç»“æ„è¿‡æ»¤
â”‚   â””â”€â”€ analyze_element_structure.rs         # åˆ†æå…ƒç´ ç»“æ„
â”‚
â”œâ”€â”€ services/                                 # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ structural_matching_service.rs       # ä¸»æœåŠ¡ â­â­â­
â”‚   â”œâ”€â”€ field_scorer.rs                      # å­—æ®µè¯„åˆ†å™¨
â”‚   â”‚   â”œâ”€â”€ resource_id_scorer.rs            # Resource-ID è¯„åˆ†
â”‚   â”‚   â”œâ”€â”€ content_desc_scorer.rs           # Content-Desc è¯„åˆ†
â”‚   â”‚   â”œâ”€â”€ text_scorer.rs                   # Text è¯„åˆ†
â”‚   â”‚   â””â”€â”€ children_structure_scorer.rs     # å­å…ƒç´ ç»“æ„è¯„åˆ†
â”‚   â”‚
â”‚   â””â”€â”€ structure_analyzer.rs                # ç»“æ„åˆ†æå™¨
â”‚
â”œâ”€â”€ infrastructure/                           # åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ structural_cache.rs                  # ç¼“å­˜
â”‚   â””â”€â”€ structural_logger.rs                 # æ—¥å¿—
â”‚
â”œâ”€â”€ commands/                                 # Tauri Commands
â”‚   â”œâ”€â”€ create_structural_rule.rs            # åˆ›å»ºè§„åˆ™
â”‚   â”œâ”€â”€ preview_structural_match.rs          # é¢„è§ˆåŒ¹é…
â”‚   â””â”€â”€ execute_structural_match.rs          # æ‰§è¡ŒåŒ¹é…
â”‚
â””â”€â”€ mod.rs                                    # æ¨¡å—å¯¼å‡º
```

---

## ğŸ“Š æ ¸å¿ƒæ•°æ®æ¨¡å‹è®¾è®¡

### **1. å­—æ®µé…ç½®æ¨¡å‹ (å‰ç«¯)**

```typescript
// src/modules/structural-matching/domain/models/structural-field-config.ts

export enum FieldType {
  RESOURCE_ID = 'resource_id',
  CONTENT_DESC = 'content_desc',
  TEXT = 'text',
  CLASS_NAME = 'class_name',
  CHILDREN_STRUCTURE = 'children_structure',
  BOUNDS = 'bounds',  // è™½ç„¶ä¸ç”¨,ä½†ä¿ç•™ä»¥ä¾¿æ‰©å±•
}

export enum MatchMode {
  EXACT = 'exact',           // å€¼å®Œå…¨ç›¸åŒ
  NON_EMPTY = 'non_empty',   // éƒ½éç©ºå³å¯
  EMPTY = 'empty',           // éƒ½ä¸ºç©ºå³å¯
  STRUCTURE = 'structure',   // ç»“æ„åŒ¹é… (ç”¨äºå­å…ƒç´ )
  DISABLED = 'disabled',     // ä¸å‚ä¸åŒ¹é…
}

export interface ScoringRules {
  exactMatch: number;          // å€¼å®Œå…¨ä¸€æ · (å¤§åˆ†)
  bothNonEmpty: number;        // éƒ½éç©ºä½†å€¼ä¸åŒ (å°åˆ†)
  bothEmpty: number;           // éƒ½ä¸ºç©º (å°åˆ†)
  mismatchPenalty: number;     // ä¸€ä¸ªç©ºä¸€ä¸ªéç©º (è´Ÿåˆ†)
}

export interface StructuralFieldConfig {
  fieldType: FieldType;
  enabled: boolean;            // æ˜¯å¦å‚ä¸è¯„åˆ†
  matchMode: MatchMode;        // åŒ¹é…æ¨¡å¼
  weight: number;              // å­—æ®µæƒé‡ (0-1)
  scoringRules: ScoringRules;  // è¯„åˆ†ç»†åˆ™
  displayName: string;         // æ˜¾ç¤ºåç§°
  description?: string;        // è¯´æ˜
}

export interface StructuralMatchingConfig {
  configId: string;
  templateElementId: string;   // æ¨¡æ¿å…ƒç´ ID (ç”¨æˆ·ç‚¹é€‰çš„å…ƒç´ )
  templateStructure: any;      // æ¨¡æ¿å…ƒç´ å®Œæ•´ç»“æ„
  fields: StructuralFieldConfig[];  // å„å­—æ®µé…ç½®
  globalThreshold: number;     // å…¨å±€é˜ˆå€¼ (0-1)
  createdAt: number;
  updatedAt: number;
}
```

### **2. è¯„åˆ†è§„åˆ™æ¨¡å‹ (åç«¯)**

```rust
// src-tauri/src/modules/structural_matching/domain/models/field_scoring_rule.rs

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FieldType {
    ResourceId,
    ContentDesc,
    Text,
    ClassName,
    ChildrenStructure,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MatchMode {
    Exact,           // å€¼å®Œå…¨ç›¸åŒ
    NonEmpty,        // éƒ½éç©ºå³å¯
    Empty,           // éƒ½ä¸ºç©ºå³å¯
    Structure,       // ç»“æ„åŒ¹é…
    Disabled,        // ä¸å‚ä¸
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringRules {
    pub exact_match: f64,        // å€¼å®Œå…¨ä¸€æ · (å¦‚ 0.3)
    pub both_non_empty: f64,     // éƒ½éç©ºä½†ä¸åŒ (å¦‚ 0.1)
    pub both_empty: f64,         // éƒ½ä¸ºç©º (å¦‚ 0.05)
    pub mismatch_penalty: f64,   // ç©º/éç©ºä¸åŒ¹é… (å¦‚ -0.2)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FieldScoringRule {
    pub field_type: FieldType,
    pub enabled: bool,
    pub match_mode: MatchMode,
    pub weight: f64,             // æƒé‡
    pub scoring_rules: ScoringRules,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructuralMatchingConfig {
    pub config_id: String,
    pub template_element: serde_json::Value,  // æ¨¡æ¿å…ƒç´ 
    pub fields: Vec<FieldScoringRule>,
    pub global_threshold: f64,
}
```

---

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½å®ç°

### **åŠŸèƒ½1: æ¨¡æ€æ¡†UI (å‰ç«¯)**

```typescript
// src/modules/structural-matching/ui/components/structural-matching-modal/index.tsx

export const StructuralMatchingModal: React.FC<Props> = ({ 
  visible, 
  selectedElement, 
  onConfirm, 
  onCancel 
}) => {
  const {
    config,
    updateFieldConfig,
    toggleField,
    previewScore,
  } = useStructuralMatchingModal(selectedElement);

  return (
    <Modal
      title="ç»“æ„åŒ¹é…é…ç½®"
      open={visible}
      width={900}
      onOk={() => onConfirm(config)}
      onCancel={onCancel}
    >
      <div className="structural-matching-container">
        {/* å·¦ä¾§: å…ƒç´ ç»“æ„æ ‘ */}
        <div className="structure-tree-panel">
          <ElementStructureTree element={selectedElement} />
        </div>

        {/* å³ä¾§: å­—æ®µé…ç½® */}
        <div className="field-config-panel">
          <h3>å­—æ®µé…ç½®</h3>
          {config.fields.map(field => (
            <FieldConfigItem
              key={field.fieldType}
              field={field}
              onToggle={() => toggleField(field.fieldType)}
              onChange={(updated) => updateFieldConfig(field.fieldType, updated)}
            />
          ))}
        </div>

        {/* åº•éƒ¨: è¯„åˆ†é¢„è§ˆ */}
        <div className="scoring-preview-panel">
          <ScoringPreview config={config} previewScore={previewScore} />
        </div>
      </div>
    </Modal>
  );
};
```

### **åŠŸèƒ½2: å­—æ®µè¯„åˆ†å™¨ (åç«¯)**

```rust
// src-tauri/src/modules/structural_matching/services/field_scorer.rs

pub struct FieldScorer;

impl FieldScorer {
    /// Resource-ID è¯„åˆ†
    pub fn score_resource_id(
        template_id: &Option<String>,
        candidate_id: &Option<String>,
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        match (&template_id, &candidate_id) {
            // å€¼å®Œå…¨ä¸€æ · (å¤§åˆ†)
            (Some(t), Some(c)) if t == c => {
                rule.scoring_rules.exact_match * rule.weight
            },
            // éƒ½éç©ºä½†ä¸åŒ (å°åˆ†)
            (Some(_), Some(_)) => {
                rule.scoring_rules.both_non_empty * rule.weight
            },
            // éƒ½ä¸ºç©º (å°åˆ†)
            (None, None) => {
                rule.scoring_rules.both_empty * rule.weight
            },
            // ä¸€ä¸ªç©ºä¸€ä¸ªéç©º (è´Ÿåˆ†)
            _ => {
                rule.scoring_rules.mismatch_penalty * rule.weight
            },
        }
    }

    /// Content-Desc è¯„åˆ† (éç©ºå³å¯)
    pub fn score_content_desc(
        template_desc: &Option<String>,
        candidate_desc: &Option<String>,
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        match rule.match_mode {
            MatchMode::Exact => {
                // å®Œå…¨åŒ¹é…æ¨¡å¼
                Self::score_resource_id(template_desc, candidate_desc, rule)
            },
            MatchMode::NonEmpty => {
                // éç©ºæ¨¡å¼: åªè¦éƒ½éç©ºå°±ç»™åˆ†
                match (&template_desc, &candidate_desc) {
                    (Some(t), Some(c)) if !t.is_empty() && !c.is_empty() => {
                        rule.scoring_rules.both_non_empty * rule.weight
                    },
                    (None, None) => {
                        rule.scoring_rules.both_empty * rule.weight
                    },
                    _ => {
                        rule.scoring_rules.mismatch_penalty * rule.weight
                    },
                }
            },
            _ => 0.0,
        }
    }

    /// Text è¯„åˆ† (éç©º/ç©ºçŠ¶æ€ä¸€è‡´)
    pub fn score_text(
        template_text: &Option<String>,
        candidate_text: &Option<String>,
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        // ä¸æ£€æŸ¥å…·ä½“æ–‡æœ¬,åªæ£€æŸ¥éç©º/ç©ºçŠ¶æ€
        match (&template_text, &candidate_text) {
            (Some(t), Some(c)) if !t.is_empty() && !c.is_empty() => {
                rule.scoring_rules.both_non_empty * rule.weight
            },
            (None, None) | (Some(t), Some(c)) if t.is_empty() && c.is_empty() => {
                rule.scoring_rules.both_empty * rule.weight
            },
            _ => {
                rule.scoring_rules.mismatch_penalty * rule.weight
            },
        }
    }

    /// å­å…ƒç´ ç»“æ„è¯„åˆ†
    pub fn score_children_structure(
        template_children: &[ElementChild],
        candidate_children: &[ElementChild],
        rule: &FieldScoringRule,
    ) -> f64 {
        if !rule.enabled {
            return 0.0;
        }

        // æ£€æŸ¥ç»“æ„ç›¸ä¼¼åº¦
        let template_structure = Self::extract_structure_signature(template_children);
        let candidate_structure = Self::extract_structure_signature(candidate_children);

        if template_structure == candidate_structure {
            rule.scoring_rules.exact_match * rule.weight
        } else {
            rule.scoring_rules.mismatch_penalty * rule.weight
        }
    }

    /// æå–ç»“æ„ç­¾å (ç±»ååºåˆ—)
    fn extract_structure_signature(children: &[ElementChild]) -> Vec<String> {
        children.iter()
            .map(|child| child.class_name.clone())
            .collect()
    }
}
```

### **åŠŸèƒ½3: ç»“æ„åŒ¹é…æœåŠ¡ (åç«¯)**

```rust
// src-tauri/src/modules/structural_matching/services/structural_matching_service.rs

pub struct StructuralMatchingService;

impl StructuralMatchingService {
    /// æ‰§è¡Œç»“æ„åŒ¹é…
    pub fn match_elements(
        config: &StructuralMatchingConfig,
        candidates: Vec<UIElement>,
    ) -> Vec<ScoredElement> {
        let mut scored_elements = Vec::new();

        for candidate in candidates {
            let score = Self::calculate_score(config, &candidate);
            
            if score >= config.global_threshold {
                scored_elements.push(ScoredElement {
                    element: candidate,
                    score,
                    breakdown: Self::get_score_breakdown(config, &candidate),
                });
            }
        }

        // æŒ‰åˆ†æ•°é™åºæ’åº
        scored_elements.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());
        scored_elements
    }

    /// è®¡ç®—æ€»åˆ†
    fn calculate_score(
        config: &StructuralMatchingConfig,
        candidate: &UIElement,
    ) -> f64 {
        let mut total_score = 0.0;

        for rule in &config.fields {
            let field_score = match rule.field_type {
                FieldType::ResourceId => {
                    FieldScorer::score_resource_id(
                        &config.template_element.resource_id,
                        &candidate.resource_id,
                        rule,
                    )
                },
                FieldType::ContentDesc => {
                    FieldScorer::score_content_desc(
                        &config.template_element.content_desc,
                        &candidate.content_desc,
                        rule,
                    )
                },
                FieldType::Text => {
                    FieldScorer::score_text(
                        &config.template_element.text,
                        &candidate.text,
                        rule,
                    )
                },
                FieldType::ChildrenStructure => {
                    FieldScorer::score_children_structure(
                        &config.template_element.children,
                        &candidate.children,
                        rule,
                    )
                },
                _ => 0.0,
            };

            total_score += field_score;
        }

        total_score
    }
}
```

---

## ğŸ”— å‰åç«¯åè®®

```typescript
// å‰ç«¯ â†’ åç«¯
interface StructuralMatchRequest {
  configId: string;
  config: StructuralMatchingConfig;
  mode: 'first' | 'last' | 'all' | 'random';
  xmlContent: string;  // å½“å‰é¡µé¢XML
}

// åç«¯ â†’ å‰ç«¯
interface StructuralMatchResponse {
  success: boolean;
  matched_elements: ScoredElement[];
  total_candidates: number;
  execution_time_ms: number;
}
```

---

## âœ… è®¾è®¡ä¼˜åŠ¿

1. **âœ… æ¨¡å—åŒ–æ¸…æ™°**: domain/application/ui/services åˆ†å±‚
2. **âœ… å¯æ‰©å±•æ€§å¼º**: æ–°å¢å­—æ®µåªéœ€åŠ é…ç½®,ä¸æ”¹æ ¸å¿ƒé€»è¾‘
3. **âœ… å¯æµ‹è¯•æ€§å¥½**: é¢†åŸŸå±‚çº¯å‡½æ•°,æ˜“äºå•å…ƒæµ‹è¯•
4. **âœ… å¯ç»´æŠ¤æ€§é«˜**: èŒè´£æ¸…æ™°,ä»£ç ç»„ç»‡è§„èŒƒ
5. **âœ… ç”¨æˆ·å‹å¥½**: æ¨¡æ€æ¡†å¯è§†åŒ–é…ç½®,å®æ—¶é¢„è§ˆ
6. **âœ… æ€§èƒ½ä¼˜åŒ–**: æ”¯æŒç¼“å­˜å’Œå¢é‡è®¡ç®—

---

## ğŸ“ å®æ–½å»ºè®®

### **é˜¶æ®µ1: åŸºç¡€æ¶æ„ (1-2å¤©)**
- åˆ›å»ºç›®å½•ç»“æ„
- å®šä¹‰æ•°æ®æ¨¡å‹
- å®ç°åŸºç¡€è¯„åˆ†å™¨

### **é˜¶æ®µ2: æ ¸å¿ƒåŠŸèƒ½ (2-3å¤©)**
- å®ç°æ¨¡æ€æ¡†UI
- å®ç°åç«¯åŒ¹é…æœåŠ¡
- å¯¹æ¥Tauri Command

### **é˜¶æ®µ3: é›†æˆæµ‹è¯• (1-2å¤©)**
- æµ‹è¯•å°çº¢ä¹¦ç¬”è®°å¡ç‰‡åŒ¹é…
- æ€§èƒ½ä¼˜åŒ–
- è¾¹ç•Œæƒ…å†µå¤„ç†

### **é˜¶æ®µ4: ç”¨æˆ·ä½“éªŒ (1å¤©)**
- é¢„è®¾æ¨¡æ¿
- å¯¼å…¥/å¯¼å‡ºé…ç½®
- å¸®åŠ©æ–‡æ¡£

---

ä½ è§‰å¾—è¿™ä¸ªè®¾è®¡å¦‚ä½•? éœ€è¦è°ƒæ•´å“ªäº›éƒ¨åˆ†? ğŸš€