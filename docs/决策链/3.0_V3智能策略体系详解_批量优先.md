# V3 智能策略体系详解：批量优先架构

> **核心原则**：用户场景以 **瀑布流卡片** 和 **批量关注按钮** 为主。因此，策略体系必须优先保障 **批量结构匹配**，其次才是 **精确单一查找**。

## 1. 核心设计哲学

在自动化业务中，我们面临两类截然不同的查找需求：

1.  **批量/结构化需求 (Batch/Structural)** - **高频场景 (80%)**
    *   场景：瀑布流中的商品卡片、评论列表中的点赞按钮、用户列表中的关注按钮。
    *   特征：元素在页面中多次出现，结构相似，无法通过文本或ID唯一确定。
    *   痛点：传统 `text="关注"` 会匹配到几十个按钮，无法区分是第几个卡片的。
    *   **解决方案**：依赖 `card_subtree` (卡片结构) 和 `leaf_context` (兄弟/祖先关系)。

2.  **单一/语义化需求 (Single/Semantic)** - **低频场景 (20%)**
    *   场景：底部的"发布"按钮、顶部的"设置"图标、特定的"搜索"框。
    *   特征：页面中唯一存在，具有明确的文本或ID。
    *   痛点：结构可能因版本更新而变化，但文本/ID相对稳定。
    *   **解决方案**：依赖 `text_exact` (唯一文本) 和 `heuristic_id` (唯一ID)。

**歧义消除机制**：
为了防止 AI 混淆这两类需求，我们将策略分为 4 个 Tier (层级)。**Tier 1 永远优先**，确保在批量场景下，不会错误地使用单一匹配策略（导致只找到第一个或随机找到一个）。

---

## 2. 10步策略详解 (The 10-Step Ladder)

### 🏆 Tier 1: 批量结构匹配 (Batch Structure) - 瀑布流首选

此层级策略不依赖文本内容的唯一性，而是依赖元素的**结构指纹**。

#### **Step 1: 卡片子树评分 (`card_subtree_scoring`)**
*   **适用对象**：瀑布流卡片容器 (CardView, FrameLayout 等)。
*   **实现细节**：
    *   **特征提取**：分析子树中是否包含 `media_area` (媒体区)、`bottom_bar` (底栏)、`desc_on_root` (根节点描述)。
    *   **透视逻辑**：自动处理透明点击层 (Node 32) 覆盖内容层 (Node 31) 的常见安卓布局问题，通过 `find_overlapping_sibling` 合并兄弟节点特征。
    *   **评分逻辑**：结构特征越丰富（如同时有图、有文、有按钮），评分越高。
*   **为什么排第一**：它是所有批量操作的**容器基础**。只有先定位到卡片，才能定位卡片内的元素。

#### **Step 2: 叶子上下文评分 (`leaf_context_scoring`)**
*   **适用对象**：卡片内的具体元素 (关注按钮、点赞图标、标题文本)。
*   **实现细节**：
    *   **指纹构建**：记录 `ancestor_classes` (祖先链类型)、`sibling_shape` (兄弟节点形态分布)、`sibling_index` (在兄弟中的位置)。
    *   **相对坐标**：计算元素相对于 `clickable_parent` 或 `button_row` 的相对位置 (rel_xywh)。
    *   **行容器识别**：特别优化了 `find_button_row_container`，能精准识别水平排列的按钮组。
*   **为什么排第二**：在确定卡片后，它是区分卡片内"左边按钮"和"右边按钮"的最佳手段，且不依赖不稳定的文本（如关注/已关注状态变化）。

---

### 🏆 Tier 2: 结构定位兜底 (Structure Fallback)

当 Tier 1 无法提取足够特征时（如简单列表），使用纯位置/索引定位。

#### **Step 3: 索引路径定位 (`index_fallback`)**
*   **实现细节**：基于 DOM 树的绝对 `index_path` (如 `0/1/2/0`)。
*   **适用场景**：结构极其稳定的静态列表。
*   **风险**：UI 微调会导致路径失效，因此作为 Tier 1 的补充。

#### **Step 4: 区域约束策略 (`region_scoped`)**
*   **实现细节**：限定查找范围在某个 `ScrollView` 或 `RecyclerView` 容器内。
*   **适用场景**：当页面有多个滚动区域时，防止跨区域误找。

---

### 🏆 Tier 3: 语义精确匹配 (Semantic Exact) - 单一元素首选

此层级策略假设元素是**全局唯一**的。**在批量场景下，这些策略通常会失效或被降权**。

#### **Step 5: 文本唯一匹配 (`text_exact_scoring`)**
*   **实现细节**：
    *   **唯一性检查**：核心函数 `check_uniqueness`。如果 `text="关注"` 在页面出现 10 次，此策略会**直接拒绝**或给予极低分。
    *   **稳定性分析**：拒绝纯数字、时间、价格等动态文本。白名单包含 "设置", "发布" 等稳定词。
*   **关键点**：这是防止 AI 在瀑布流中错误使用文本匹配的关键。**如果不是唯一的，就不要用这个策略。**

#### **Step 6: ID稳定性评分 (`heuristic_id_scoring`)**
*   **实现细节**：评估 `resource-id` 的可读性。拒绝 `com.app:id/a1b` (混淆ID)，偏好 `com.app:id/btn_submit` (语义ID)。
*   **适用场景**：功能性按钮。

#### **Step 7: 描述文本定位 (`content_desc`)**
*   **实现细节**：针对 `content-desc` 属性（无障碍标签）。通常比 `text` 更稳定。

---

### 🏆 Tier 4: 传统 XPath 兜底 (The Safety Net)

最后手段，生成的 XPath 通常较长且脆弱。

#### **Step 8: 自锚定策略 (`self_anchor`)**
*   简单基于 ID 生成 XPath。

#### **Step 9: XPath 启发生成 (`heuristic_xpath_scoring`)**
*   综合多种属性生成的复杂 XPath。

#### **Step 10: XPath 兜底策略 (`xpath_fallback`)**
*   绝对路径 XPath，最脆弱但肯定能找到（如果页面没变）。

---

## 3. 给 AI 代理的执行指令 (The Prime Directive)

为了确保所有 AI 代理（包括未来的你）不会产生歧义，请遵循以下决策树：

1.  **判断场景**：
    *   用户是否在操作一个**列表**、**网格**或**重复项**？
    *   目标元素是否在页面上**出现多次**？
    *   **如果是** 👉 **必须锁定 Tier 1 (Step 1-2)**。不要试图用 Step 5 (文本) 去匹配列表项，除非你配合了 Step 4 (区域约束)。

2.  **判断唯一性**：
    *   目标元素是否是**全局唯一**的功能入口（如"设置"、"发布"）？
    *   **如果是** 👉 **Tier 3 (Step 5-7) 是最佳选择**。

3.  **关于"关注"按钮的特殊悖论**：
    *   "关注"按钮既有文本（Tier 3特征），又是列表项（Tier 1场景）。
    *   **裁决**：**按 Tier 1 处理**。因为在业务中，我们通常需要区分"第几个"关注按钮，或者"哪个卡片内"的关注按钮。单纯的 `text="关注"` 丢失了上下文信息，是**错误**的策略选择。

## 4. 总结

最佳排序（已固化到代码）：
1.  **Step 1: 卡片子树** (找爸爸)
2.  **Step 2: 叶子上下文** (找兄弟)
3.  **Step 3: 索引路径** (死记硬背)
4.  **Step 4: 区域约束** (画圈圈)
5.  **Step 5: 文本唯一** (找唯一)
6.  **Step 6: ID 稳定** (找ID)
7.  **Step 7: 描述文本** (找标签)
8.  **Step 8-10: XPath** (最后的倔强)

此文档为 V3 架构的**最终解释权**归属。任何代码修改必须遵循此优先级。
