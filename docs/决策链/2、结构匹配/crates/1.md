
你这个架构的文件名字是不是不太好，

因为我这个专注于 “结构匹配”这个子功能模块的。

程序的其他功能， 
也可能叫做 engine 这样

你说得对，“engine”太泛、容易和你别的模块撞名。下面给你一套**专注“结构匹配”子功能**的命名与分层，把之前那套流程（几何→模板签名→骨架→字段→打分→早停）装进一个**独立可复用模块**，不跟全局 engine 冲突。

---

# 推荐命名与目录（Rust 后端）

把它做成一个**独立域模块：`structure_match/`**（或独立 crate：`crates/structure-match/`），内部子模块用更贴切的名字，避免“engine”。

```
src-tauri/src/structure_match/
│
├─ prelude.rs                # 对外导出的统一入口（Facade）
├─ types.rs                  # 基本类型：ItemHit、Scores、LayoutType、Config...
├─ orchestrator.rs           # 一次 dump 的编排（顺序 + 早停 + 缓存）
│
├─ container_gate/           # 容器限域（只识别“那个大盒子”，不锁屏幕角落）
│  ├─ detector.rs            # 找滚动容器/候选容器
│  └─ hint.rs                # StepCard 的 container_xpath / fallback 指纹
│
├─ layout_gate/              # = “几何层/版式分类器”（不是只给瀑布用）
│  ├─ columns.rs             # 按 left 聚列；列宽一致性/行对齐
│  ├─ metrics.rs             # 高度CV、宽度占比等通用几何指标
│  └─ classifier.rs          # 输出 LayoutType + S_geom
│
├─ signature/                # = “模板签名/重复性”
│  ├─ features.rs            # 分桶特征提取（相对宽度桶、AR桶、文本数桶、深度桶…）
│  ├─ hasher.rs              # 位图编码 + xxhash64 / Hamming
│  ├─ learner.rs             # 采样学习 Top-K 模板，支持缓存
│  └─ matcher.rs             # 匹配模板，出 S_tpl
│
├─ skeleton/                 # = “骨架/规则校验”
│  ├─ dsl.rs                 # 规则DSL（必须有图/文本、上下顺序、弹性±1）
│  └─ checker.rs             # 执行校验，出 S_struct
│
├─ field_refine/             # = “字段/文本细则”
│  └─ scorer.rs              # 空/非空一致、完全匹配、相似度、必等于，出 S_field
│
├─ scoring/                  # = “权重/合成/闸门”
│  ├─ weights.rs             # Speed/Default/Robust 三档权重
│  ├─ combiner.rs            # S_total = w⋅(geom,tpl,struct,field)
│  └─ gates.rs               # 唯一性、top-gap、min_conf 闸门
│
└─ diag/                     # = “诊断/打点（可选）”
   ├─ log.rs                 # 阶段耗时与各分值
   └─ overlay.rs             # 列分布/命中高亮导出给前端
```

> 关键词替换：
>
> * “几何”→ `layout_gate`（版式门）
> * “模板签名”→ `signature`
> * “骨架”→ `skeleton`
> * “字段/文本”→ `field_refine`
>   **不再出现“engine”**，模块边界一眼明了。

---

# 对外 API（Facade）

对别的模块只暴露**一个入口**，其它细节都内聚在内部子模块。

**路径与函数名示例（不贴大段代码）：**

* `structure_match::prelude::run_once(ctx: &XmlCtx, cfg: &StructureMatchConfig) -> StructureMatchResult`

**`StructureMatchConfig` 里放：**

* `allowed_layouts`（Auto/WaterfallMulti/MasonrySingle/Grid/List/Carousel）
* `mode`（Speed/Default/Robust → 内置权重）
* `skip_geometry / skip_template_when_single / strict_skeleton_only`（早停三开关）
* `skeleton_rules`（骨架DSL）
* `field_rules`（“子元素文本必须=某值”等）
* `container_hint`（container_xpath 或 指纹）

**`StructureMatchResult`：**

* `container: Option<ContainerHit>`
* `items: Vec<ItemHit>`（含 `node_id / bounds / scores{geom,tpl,struct,field,total}`）

---

# 前端/调用侧只需这样接（示意）

* V3 执行引擎继续待在你的 `exec/v3/chain_engine.rs`；
* 当需要“结构匹配”时，只**调用**：

  * `structure_match::run_once(xml_ctx, step_card.structure_match_config)`

这样**命名不冲突**：全局“引擎”还是引擎；“结构匹配”是**一个独立子系统**。

---

# 命名细则与可维护性

* **统一前缀**（可选）：内部模块里导出的类型用 `Sm*` 前缀（Structure-match），如 `SmScores`，避免和别处 `Scores` 混淆。
* **prelude 模式**：上层只 `use structure_match::prelude::*;` 就能拿到需要的类型与函数。
* **缓存/采样**：放在 `signature::learner` 与 `xml` 层，按 `xml_hash + container_id` 缓存，不污染其它域。
* **可替换**：要支持新布局，只新增 `layout_gate::classifier` 的判定；要改签名特征，只动 `signature/*`。
* **测试/基准**：在 `structure_match/tests/` 放单元测试；`benches/` 做 XML 大小/候选量不同下的基准。

---

# 最小落地路线（一步步来）

1. 先建 `structure_match/{types,orchestrator,prelude}`，能把“只骨架”跑起来（`strict_skeleton_only=true`）。
2. 接上 `container_gate`（容器限域），再跑一次。
3. 加 `layout_gate`（几何/版式），再跑。
4. 加 `signature`（模板学习+匹配），打开 `want_all=true` 找全同类。
5. 接 `field_refine` 与 `scoring` 合成分+闸门。
6. 最后接 `diag` 打点与前端 overlay。

---

**总结**：
把“结构匹配”做成一个**有界上下文**：`structure_match/*`，里面用 `layout_gate / signature / skeleton / field_refine / scoring / orchestrator` 这些**更语义化**的名字；对外只暴露 `prelude::run_once(...)`。这样既**专注**、又**不和全局 engine 混名**，后续扩展/调参也更清晰。
