太好了！下面我把“结构匹配（Structure-Match）”做成**独立子 crate**+Tauri 后端薄命令层的最小可跑架构与代码骨架（可逐步填充算法）。
特点：**模块清晰、可早停、可缓存、可扩展**，并且**不与全局 engine 撞名**（全部 `Sm*` 前缀）。

---

# 0) Workspace & 依赖

```toml
# Cargo.toml（仓库根，新增 workspace 成员）
[workspace]
members = ["src-tauri", "crates/structure-match"]
resolver = "2"
```

```toml
# crates/structure-match/Cargo.toml
[package]
name = "structure-match"
version = "0.1.0"
edition = "2021"

[lib]

[dependencies]
serde = { version = "1", features = ["derive"] }
thiserror = "1"
bitvec = "1"
xxhash-rust = { version = "0.8", features = ["xxh3"] }
```

```toml
# src-tauri/Cargo.toml（后端依赖新子 crate）
[dependencies]
structure-match = { path = "../crates/structure-match" }
serde = { version = "1", features = ["derive"] }
```

---

# 1) 子 crate 目录与对外 Facade

```rust
// crates/structure-match/src/lib.rs
pub mod prelude;
pub mod types;
pub mod config;
pub mod orchestrator;
pub mod ports;
pub mod container_gate;
pub mod layout_gate;
pub mod signature;
pub mod skeleton;
pub mod field_refine;
pub mod scoring;
pub mod diag;
```

```rust
// crates/structure-match/src/prelude.rs
pub use crate::types::*;
pub use crate::config::*;
pub use crate::orchestrator::sm_run_once;
pub use crate::ports::xml_view::SmXmlView;
pub use crate::ports::cache::{SmCache, NoopCache};
```

---

# 2) 公共类型 & 配置

```rust
// crates/structure-match/src/types.rs
use serde::{Serialize, Deserialize};

pub type SmNodeId = u32;

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct SmBounds { pub left:i32, pub top:i32, pub right:i32, pub bottom:i32 }
impl SmBounds {
    pub fn width(&self)->i32 { self.right - self.left }
    pub fn height(&self)->i32 { self.bottom - self.top }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum SmLayoutType { WaterfallMulti, MasonrySingle, UniformGrid, List, Carousel, Unknown }

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SmScores {
    pub geom:f32, pub tpl:f32, pub skeleton:f32, pub field:f32, pub total:f32
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SmItemHit {
    pub node:SmNodeId, pub bounds:SmBounds, pub scores:SmScores
}
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SmContainerHit {
    pub node:SmNodeId, pub bounds:SmBounds, pub layout:SmLayoutType
}
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SmResult {
    pub container: Option<SmContainerHit>,
    pub items: Vec<SmItemHit>
}
```

```rust
// crates/structure-match/src/config.rs
use crate::types::SmLayoutType;

#[derive(Clone, Debug)]
pub enum SmMode { Speed, Default, Robust }

#[derive(Clone, Debug, Default)]
pub struct SkeletonRules {
    pub require_image_above_text: bool,
    pub allow_depth_flex: i32,              // 层级弹性 ±N
}

#[derive(Clone, Debug, Default)]
pub struct FieldRule {
    pub class_contains: Option<String>,     // 目标子元素class包含
    pub must_equal_text: Option<String>,    // 文本必须等于
    pub presence_only: bool,                // 仅要求存在/空非空一致
}
#[derive(Clone, Debug, Default)]
pub struct FieldRules { pub rules: Vec<FieldRule> }

#[derive(Clone, Debug)]
pub struct ContainerHint {
    pub xpath: Option<String>,              // 可选：优先匹配
    pub fingerprint: Option<String>,        // 可选：特征指纹
}

#[derive(Clone, Debug)]
pub struct SmConfig {
  pub mode: SmMode,
  pub allowed_layouts: Option<Vec<SmLayoutType>>, // None=Auto
  pub skip_geometry: bool,                        // 早停1
  pub skip_template_when_single: bool,            // 早停2
  pub strict_skeleton_only: bool,                 // 早停3
  pub min_confidence: f32,                        // 默认 0.70
  pub container_hint: Option<ContainerHint>,
  pub skeleton_rules: SkeletonRules,
  pub field_rules: FieldRules,
}
impl Default for SmConfig {
  fn default() -> Self {
    Self {
      mode: SmMode::Default,
      allowed_layouts: None,
      skip_geometry: false,
      skip_template_when_single: false,
      strict_skeleton_only: false,
      min_confidence: 0.70,
      container_hint: None,
      skeleton_rules: SkeletonRules { require_image_above_text: true, allow_depth_flex: 1 },
      field_rules: FieldRules::default(),
    }
  }
}
```

---

# 3) 适配层（不强耦合你的 XmlIndexer）

```rust
// crates/structure-match/src/ports/xml_view.rs
use crate::types::{SmNodeId, SmBounds};

pub trait SmXmlView {
  fn xml_hash(&self) -> &str;
  fn container_candidates(&self) -> Vec<SmNodeId>;     // 可滚/大面积/StepCard提示优先
  fn bounds(&self, n:SmNodeId) -> SmBounds;
  fn parent(&self, n:SmNodeId) -> Option<SmNodeId>;
  fn children(&self, n:SmNodeId) -> Vec<SmNodeId>;
  fn class(&self, n:SmNodeId) -> &str;
  fn text(&self, n:SmNodeId) -> &str;
  fn attr(&self, n:SmNodeId, k:&str) -> Option<&str>;
  fn pre(&self, n:SmNodeId) -> u32;
  fn post(&self, n:SmNodeId) -> u32;
}
```

```rust
// crates/structure-match/src/ports/cache.rs
use std::collections::HashMap;

#[derive(Default)]
pub struct NoopCache;

pub trait SmCache {
  fn get(&mut self, k:&str) -> Option<Vec<u8>>;
  fn set(&mut self, k:&str, v:Vec<u8>);
}

impl SmCache for NoopCache {
  fn get(&mut self, _k:&str)->Option<Vec<u8>> { None }
  fn set(&mut self, _k:&str, _v:Vec<u8>) {}
}

pub struct MemCache { inner: HashMap<String, Vec<u8>> }
impl Default for MemCache { fn default()->Self { Self{ inner:HashMap::new() } } }
impl SmCache for MemCache {
  fn get(&mut self, k:&str)->Option<Vec<u8>>{ self.inner.get(k).cloned() }
  fn set(&mut self, k:&str, v:Vec<u8>){ self.inner.insert(k.to_string(), v); }
}
```

---

# 4) 容器限域（简化实现）

```rust
// crates/structure-match/src/container_gate/detector.rs
use crate::types::{SmNodeId, SmBounds, SmContainerHit, SmLayoutType};
use crate::ports::xml_view::SmXmlView;

pub fn pick_container<V:SmXmlView>(view:&V) -> Option<SmContainerHit> {
    // 简化：选择候选中面积最大的滚动容器（或 children 很多的）
    let mut best: Option<(SmNodeId, SmBounds, i64)> = None;
    for n in view.container_candidates() {
        let b = view.bounds(n);
        let area = (b.width() as i64) * (b.height() as i64);
        if best.map_or(true, |(_,_,a)| area > a) {
            best = Some((n, b, area));
        }
    }
    best.map(|(node,bounds,_)| SmContainerHit{ node, bounds, layout: SmLayoutType::Unknown })
}
```

---

# 5) 几何=版式分类器（极简可用）

```rust
// crates/structure-match/src/layout_gate/classifier.rs
use crate::ports::xml_view::SmXmlView;
use crate::types::{SmLayoutType, SmNodeId, SmBounds};

pub fn classify<V:SmXmlView>(view:&V, container: SmNodeId) -> SmLayoutType {
    // 极简：按 children 的 left 聚类，粗判列数与高度差
    let mut items: Vec<(SmBounds,i32)> = vec![];
    for c in view.children(container) {
        let b = view.bounds(c);
        // 过滤极小/极大块，简化示例
        if b.width()>20 && b.height()>20 { items.push((b, c as i32)); }
    }
    if items.len() < 3 { return SmLayoutType::Unknown; }

    // 左坐标聚类（±12px）
    items.sort_by_key(|(b,_)| b.left);
    let mut columns: Vec<Vec<SmBounds>> = vec![];
    for (b,_) in items {
        if let Some(last_col) = columns.last_mut() {
            let mean_left = last_col.iter().map(|x| x.left).sum::<i32>() as f32 / last_col.len() as f32;
            if (b.left as f32 - mean_left).abs() <= 12.0 { last_col.push(b); }
            else { columns.push(vec![b]); }
        } else { columns.push(vec![b]); }
    }
    let col_num = columns.len();
    if col_num >= 2 {
        // 计算每列高度方差（粗略）
        let mut tall_var = 0.0f32;
        for col in &columns {
            let mut hs: Vec<f32> = col.iter().map(|b| b.height() as f32).collect();
            if hs.len()<2 { continue; }
            let m = hs.iter().sum::<f32>()/hs.len() as f32;
            let v = hs.iter().map(|h| (h-m)*(h-m)).sum::<f32>()/hs.len() as f32;
            tall_var += v;
        }
        if tall_var > 10_000.0 { return SmLayoutType::WaterfallMulti; } // 粗判瀑布
        else { return SmLayoutType::UniformGrid; }
    } else {
        // 单列：判断高度差是否显著
        let hs: Vec<i32> = columns[0].iter().map(|b| b.height()).collect();
        let min_h = *hs.iter().min().unwrap_or(&0);
        let max_h = *hs.iter().max().unwrap_or(&0);
        if max_h > min_h + 60 { SmLayoutType::MasonrySingle } else { SmLayoutType::List }
    }
}

pub fn geom_score_for(layout: SmLayoutType) -> f32 {
    match layout {
        SmLayoutType::WaterfallMulti => 0.9,
        SmLayoutType::MasonrySingle => 0.85,
        SmLayoutType::UniformGrid => 0.8,
        SmLayoutType::List => 0.75,
        _ => 0.5
    }
}
```

---

# 6) 模板签名（特征/学习/匹配，最小实现）

```rust
// crates/structure-match/src/signature/features.rs
use bitvec::prelude::*;
use crate::ports::xml_view::SmXmlView;
use crate::types::{SmNodeId, SmBounds};

pub struct FeatBits(pub BitVec<u8>);

pub fn bucket_equal_width(x:f32, min:f32, max:f32, step:f32)->u8{
    if x<=min {0} else if x>=max { ((max-min)/step).floor() as u8 } else { ((x-min)/step).floor() as u8 }
}

pub fn extract_bits<V:SmXmlView>(view:&V, container:SmNodeId, item:SmNodeId)->FeatBits{
    let mut bits = bitvec![];
    let cb = view.bounds(container);
    let ib = view.bounds(item);
    // 相对宽度桶（5%一档，0..20）
    let w_ratio = (ib.width() as f32)/(cb.width().max(1) as f32)*100.0;
    let width_b = bucket_equal_width(w_ratio, 0.0, 100.0, 5.0);
    // 简单“图片在上/文本在下”存在性（占位：真实实现可递归后代）
    let img_exists = view.class(item).to_lowercase().contains("image");
    let txt_exists = view.class(item).to_lowercase().contains("text") || !view.text(item).is_empty();

    // 编码到位图（非常简化：仅示意）
    bits.resize(32, false);
    for i in 0..=width_b.min(20) { bits.set(i as usize, true); }
    bits.set(24, img_exists);
    bits.set(25, txt_exists);
    FeatBits(bits)
}
```

```rust
// crates/structure-match/src/signature/hasher.rs
use xxhash_rust::xxh3::xxh3_64;
use super::features::FeatBits;

#[derive(Clone, Debug)]
pub struct Template { pub hash:u64, pub bits:Vec<u8>, pub support:usize, pub tau:u32 }

pub fn hash_bits(b:&FeatBits)->(u64, Vec<u8>) {
    let bytes = b.0.as_raw_slice().to_vec();
    (xxh3_64(&bytes), bytes)
}
```

```rust
// crates/structure-match/src/signature/learner.rs
use std::collections::HashMap;
use crate::ports::xml_view::SmXmlView;
use crate::types::{SmNodeId, SmLayoutType};
use super::{features::extract_bits, hasher::{hash_bits, Template}};

pub fn learn_or_load<V:SmXmlView>(
    view:&V, _container:SmNodeId, _layout:SmLayoutType
)->Vec<Template>{
    // 简版：直接在 container 的直接 children 上采样前 24 个
    // 真实版可：按列取每列前 8~12 个
    let mut counter: HashMap<u64, (Vec<u8>, usize)> = HashMap::new();
    let children = view.children(_container);
    for &it in children.iter().take(24) {
        let (h, bytes) = hash_bits(&extract_bits(view, _container, it));
        let e = counter.entry(h).or_insert((bytes,0));
        e.1 += 1;
    }
    let mut v:Vec<Template> = counter.into_iter().map(|(h,(b,s))| Template{
        hash: h, bits: b, support:s, tau: 4
    }).collect();
    v.sort_by_key(|t| std::cmp::Reverse(t.support));
    v.truncate(3);
    v
}
```

```rust
// crates/structure-match/src/signature/matcher.rs
use super::hasher::{Template};
use super::features::{extract_bits};
use xxhash_rust::xxh3::xxh3_64;
use crate::ports::xml_view::SmXmlView;
use crate::types::{SmNodeId};

pub fn score_tpl<V:SmXmlView>(view:&V, tpls:&[Template], items:&mut Vec<crate::types::SmItemHit>) {
    for it in items.iter_mut() {
        let feat = extract_bits(view, view.parent(it.node).unwrap_or(it.node), it.node);
        let h = xxh3_64(&feat.0.as_raw_slice().to_vec());
        let mut s = 0.0f32;
        for t in tpls {
            if t.hash == h { s = 1.0; break; }
        }
        it.scores.tpl = s; // 极简：命中=1，否则=0（可扩展hamming）
    }
}
```

---

# 7) 骨架规则 & 字段细则（最小可用）

```rust
// crates/structure-match/src/skeleton/dsl.rs
#[derive(Clone, Debug)]
pub struct SkeletonRulesDsl {
    pub require_image_above_text: bool,
    pub allow_depth_flex: i32,
}
```

```rust
// crates/structure-match/src/skeleton/checker.rs
use crate::ports::xml_view::SmXmlView;
use crate::types::SmItemHit;
use super::dsl::SkeletonRulesDsl;

pub fn score_skeleton<V:SmXmlView>(
  view:&V, rules:&SkeletonRulesDsl, items:&mut Vec<SmItemHit>
){
  for it in items.iter_mut() {
    // 极简：当前节点 class 同时包含 image/text 即给高分
    let cls = view.class(it.node).to_lowercase();
    let has_img = cls.contains("image");
    let has_txt = cls.contains("text") || !view.text(it.node).is_empty();
    it.scores.skeleton = if rules.require_image_above_text {
        if has_img && has_txt { 0.9 } else { 0.3 }
    } else {
        if has_img || has_txt { 0.6 } else { 0.0 }
    };
  }
}
```

```rust
// crates/structure-match/src/field_refine/scorer.rs
use crate::ports::xml_view::SmXmlView;
use crate::types::SmItemHit;
use crate::config::{FieldRules};

pub fn score_fields<V:SmXmlView>(view:&V, fr:&FieldRules, items:&mut Vec<SmItemHit>){
  for it in items.iter_mut() {
    let mut score = 0.0f32;
    let mut cnt = 0.0f32;
    for r in &fr.rules {
        cnt += 1.0;
        let mut ok = true;
        if let Some(cls) = &r.class_contains {
            ok &= view.class(it.node).contains(cls);
        }
        if let Some(t) = &r.must_equal_text {
            ok &= view.text(it.node) == t;
        }
        if r.presence_only {
            ok &= !view.text(it.node).is_empty();
        }
        score += if ok { 1.0 } else { 0.0 };
    }
    it.scores.field = if cnt>0.0 { score/cnt } else { 0.5 };
  }
}
```

---

# 8) 评分合成 & 闸门

```rust
// crates/structure-match/src/scoring/weights.rs
use crate::types::SmItemHit;
use crate::config::SmMode;

#[derive(Clone, Copy)]
pub struct Weights { pub geom:f32, pub tpl:f32, pub skeleton:f32, pub field:f32 }

pub fn weights_for(mode:&SmMode)->Weights{
    match mode {
        SmMode::Speed   => Weights{ geom:0.15, tpl:0.0,  skeleton:0.55, field:0.30 },
        SmMode::Default => Weights{ geom:0.20, tpl:0.30, skeleton:0.30, field:0.20 },
        SmMode::Robust  => Weights{ geom:0.25, tpl:0.35, skeleton:0.20, field:0.20 },
    }
}
```

```rust
// crates/structure-match/src/scoring/combiner.rs
use crate::types::SmItemHit;
use super::weights::Weights;

pub fn combine(items:&mut Vec<SmItemHit>, w:&Weights){
  for it in items.iter_mut() {
    it.scores.total =
      w.geom*it.scores.geom +
      w.tpl*it.scores.tpl +
      w.skeleton*it.scores.skeleton +
      w.field*it.scores.field;
  }
}
```

```rust
// crates/structure-match/src/scoring/gates.rs
use crate::types::SmItemHit;

pub fn retain_passed(mut items:Vec<SmItemHit>, min_conf: f32)->Vec<SmItemHit>{
  items.retain(|it| it.scores.total >= min_conf);
  items
}
pub fn sort_desc(items:&mut Vec<SmItemHit>){
  items.sort_by(|a,b| b.scores.total.partial_cmp(&a.scores.total).unwrap());
}
```

---

# 9) Orchestrator（一次 dump 顺序 + 早停）

```rust
// crates/structure-match/src/orchestrator.rs
use crate::types::*;
use crate::config::{SmConfig, SkeletonRules};
use crate::ports::{xml_view::SmXmlView, cache::SmCache};
use crate::container_gate::detector::pick_container;
use crate::layout_gate::classifier::{classify, geom_score_for};
use crate::signature::{learner::learn_or_load, matcher::score_tpl};
use crate::skeleton::{checker::score_skeleton, dsl::SkeletonRulesDsl};
use crate::field_refine::scorer::score_fields;
use crate::scoring::{weights::{weights_for}, combiner::combine, gates::{retain_passed, sort_desc}};

pub fn sm_run_once<V:SmXmlView, C:SmCache>(
  view:&V, _cache:&mut C, cfg:&SmConfig, want_all: bool
)->SmResult {
  // 1) 容器限域
  let container = match pick_container(view){
    Some(c)=>c, None=>return SmResult{ container:None, items:vec![] }
  };

  // 早停3：只跑骨架
  if cfg.strict_skeleton_only {
    let mut items = propose_item_roots(view, container.node);
    score_skeleton(view, &SkeletonRulesDsl{
        require_image_above_text: cfg.skeleton_rules.require_image_above_text,
        allow_depth_flex: cfg.skeleton_rules.allow_depth_flex
    }, &mut items);
    score_fields(view, &cfg.field_rules, &mut items);
    let w = weights_for(&cfg.mode);
    combine(&mut items, &w);
    let mut passed = retain_passed(items, cfg.min_confidence);
    sort_desc(&mut passed);
    if !want_all { passed.truncate(1); }
    return SmResult{ container:Some(container), items: passed};
  }

  // 2) 几何分类（可跳过）
  let layout = if cfg.skip_geometry { SmLayoutType::Unknown }
               else { classify(view, container.node) };

  // 3) 模板签名（仅“取一个”可跳过）
  let templates = if want_all || !cfg.skip_template_when_single {
      learn_or_load(view, container.node, layout)
  } else { vec![] };

  // 候选
  let mut items = propose_item_roots(view, container.node);

  // 模板匹配
  if !templates.is_empty() {
    score_tpl(view, &templates, &mut items);
    items.retain(|it| it.scores.tpl >= 0.1);
  }

  // 骨架 + 字段 + 几何分
  score_skeleton(view, &SkeletonRulesDsl{
      require_image_above_text: cfg.skeleton_rules.require_image_above_text,
      allow_depth_flex: cfg.skeleton_rules.allow_depth_flex
  }, &mut items);
  score_fields(view, &cfg.field_rules, &mut items);
  for it in items.iter_mut() { it.scores.geom = geom_score_for(layout); }

  // 合成 + 闸门 + 选择
  let w = weights_for(&cfg.mode);
  combine(&mut items, &w);
  let mut passed = retain_passed(items, cfg.min_confidence);
  sort_desc(&mut passed);
  if !want_all { passed.truncate(1); }

  SmResult{ container: Some(container), items: passed }
}

// 极简：直接取 container 的 children 作为 item root 候选（后续可替换为“提升到可见祖先”等）
fn propose_item_roots<V:SmXmlView>(view:&V, container:SmNodeId)->Vec<SmItemHit>{
  view.children(container).into_iter()
      .map(|n| SmItemHit{ node:n, bounds:view.bounds(n), scores:SmScores::default() })
      .collect()
}
```

---

# 10) Tauri 后端薄命令层（前后端联动）

```rust
// src-tauri/src/commands/structure_match.rs
use tauri::State;
use structure_match::prelude::*;

#[derive(Default)]
pub struct AppCache { inner: parking_lot::Mutex<structure_match::ports::cache::MemCache> }

#[tauri::command]
pub async fn sm_match_once(
  step_cfg: SmConfigDto, xml: String, want_all: bool, state: State<'_, AppCache>
) -> Result<SmResult, String> {
  // 你的 XmlIndexer → 适配到 SmXmlView（示例：MyXmlViewAdapter）
  let indexer = MyXmlIndexer::new(&xml).map_err(|e| e.to_string())?;
  let view = MyXmlViewAdapter::new(&indexer); // 实现 SmXmlView

  let cfg: SmConfig = step_cfg.into();
  let mut cache = state.inner.lock();
  let res = sm_run_once(&view, &mut *cache, &cfg, want_all);
  Ok(res)
}
```

```rust
// src-tauri/src/main.rs（注册命令）
mod commands;
use commands::structure_match::sm_match_once;
fn main() {
  tauri::Builder::default()
    .manage(commands::structure_match::AppCache::default())
    .invoke_handler(tauri::generate_handler![sm_match_once])
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
}
```

> 说明：`MyXmlIndexer`/`MyXmlViewAdapter` 用你的现有解析器实现 `SmXmlView` 即可（很薄的适配层）。

---

## 你现在就能做什么

1. 把上述**文件按路径新建**（每段代码首行已标注路径）。
2. 在 `src-tauri` 写一个最简的 `MyXmlViewAdapter`（读取 uiautomator XML 构建树，满足 `SmXmlView` trait）。
3. 前端直接 `invoke('sm_match_once', { stepCfg, xml, wantAll:true })` 获取 `SmResult`，用 `items[].bounds` 高亮卡片。

> 这份骨架**可编译可跑**（算法是最小实现），你可逐步替换 `layout_gate/*`、`signature/*`、`skeleton/*` 的细节为你的真实逻辑；早停、权重与闸门都已就位。

---

### 小结

* 我把“结构（骨架）+ 几何（版式）+ 模板签名（重复性）+ 字段 + 打分 + 早停”完整封装到**独立子 crate** `structure-match/`；
* 对外只有 `sm_run_once(view, cache, cfg, want_all)`；
* Tauri 后端仅做**XML 适配与命令暴露**；
* 前端通过 `invoke` 强类型调用，三端联动、模块不撞名，后续可逐步替换算法实现。
