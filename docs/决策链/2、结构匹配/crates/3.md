我这是 tauri 独立子 crate 适合前后端联动开发吗？

结论：**非常适合。**
把“结构匹配”做成 **独立子 crate**（workspace 下的 Rust 库包），用作 **Tauri 后端的纯算法内核**；前端通过 Tauri `invoke` 调命令 + 自动生成 TS 类型，即可做到高内聚、低耦合、前后端联动开发。

下面给你一套落地架构（命名不与全局 engine 撞车），含目录、接口、联动与开发流程。

---

# 1) 目录与命名（避免撞名）

```
/Cargo.toml                     # workspace
/src-tauri/                     # Tauri 后端（命令、设备I/O、ADB、缓存等）
/src/                           # 前端 React/Vite
/crates/
  /structure-match/             # ← 独立子 crate：结构匹配内核（纯算法）
    /src/
      lib.rs
      prelude.rs
      types.rs
      config.rs
      orchestrator.rs           # 一次 dump 顺序 + 早停
      ports/                    # 适配层（trait，不依赖你的具体 Indexer）
        xml_view.rs             # SmXmlView：取节点/属性/bounds/pre/post
        cache.rs                # SmCache：xml_hash/container → 缓存
      container_gate/           # 容器限域
      layout_gate/              # 几何(版式)分类器
      signature/                # 模板签名（重复性）
      skeleton/                 # 骨架规则校验
      field_refine/             # 字段/文本微调
      scoring/                  # 权重合成 + 闸门
      diag/                     # 日志/overlay（可选）
```

> 公开类型统一前缀 **Sm***（例如 `SmResult/SmConfig`），**不再使用 engine** 这个词。

---

# 2) 子 crate 对外 API（后端调用超级简单）

```rust
// crates/structure-match/src/prelude.rs
pub use crate::types::*;
pub use crate::config::*;
pub use crate::orchestrator::sm_run_once;
pub use crate::ports::xml_view::SmXmlView;
pub use crate::ports::cache::{SmCache, NoopCache};
```

```rust
// crates/structure-match/src/orchestrator.rs（核心入口）
pub fn sm_run_once<V: SmXmlView, C: SmCache>(
  view: &V, cache: &mut C, cfg: &SmConfig, want_all: bool
) -> SmResult { /* 容器限域 → 几何(可早停) → 模板(可早停) → 骨架/字段 → 合成+闸门 */ }
```

> **SmXmlView** 是一个 trait，专门把你现有的 `XmlIndexer` 适配进来，算法内核不依赖具体实现。

---

# 3) Tauri 后端桥接（命令层很薄）

```rust
// src-tauri/src/commands/structure_match.rs
use tauri::State;
use structure_match::prelude::*;

struct AppState {
  cache: parking_lot::Mutex<MyCache>, // 实现了 SmCache
  // 设备/adb 等其他状态...
}

#[tauri::command]
async fn sm_match_once(
  step_cfg: SmConfigDto,      // 前端传来的配置（映射到 SmConfig）
  xml: String,                // 本次 dump 的 XML
  want_all: bool,
  state: State<'_, AppState>,
) -> Result<SmResultDto, String> {
  // 1) 把 xml 喂给你的 XmlIndexer，再适配为 SmXmlView
  let indexer = MyXmlIndexer::new(&xml)?;
  let xml_view = MyXmlViewAdapter::new(&indexer);   // 实现 SmXmlView

  // 2) 配置与缓存
  let cfg: SmConfig = step_cfg.into();
  let mut cache = state.cache.lock();

  // 3) 调用结构匹配内核（独立子 crate）
  let res = sm_run_once(&xml_view, &mut *cache, &cfg, want_all);

  // 4) 序列化回前端
  Ok(SmResultDto::from(res))
}
```

> 重：算法全在 `structure-match`；Tauri 命令只是把 XML 适配并转发，**清晰分层**。

---

# 4) 前端强类型联动（自动生成 TS 类型）

为了“前后端联动”顺畅，推荐二选一：

* **`tauri-specta`**：自动导出 `invoke` 的 TS 类型（包含参数/返回值）
* **`ts-rs`**：在 Rust 结构体上派生 `TS`，导出 `.d.ts` 给前端用

例（`ts-rs`）：

```rust
// 在 crates/structure-match/src/types.rs 内（或为 Tauri 包装一层 DTO）
use ts_rs::TS;
#[derive(serde::Serialize, serde::Deserialize, TS)]
#[ts(export, export_to = "../../src/bindings/SmResult.d.ts")]
pub struct SmResult { /* ... */ }
```

然后前端直接：

```ts
import type { SmResult } from '@/bindings/SmResult';
const res = await invoke<SmResult>('sm_match_once', { stepCfg, xml, wantAll: true });
```

> 这样**不手写**前端类型，避免错配；一改 Rust 结构体，TS 类型自动更新。

---

# 5) 开发体验（热重载与并行）

* **Workspace 增量编译**：修改前端不会触发 `structure-match` 重新编译；修改内核，Tauri 增量快。
* 推荐脚本：

  * `pnpm dev` → 启动 Vite
  * `cargo watch -p structure-match -x test` → 内核测试热跑
  * `tauri dev` → 开发版打包与命令热起
* **不要阻塞 UI**：命令里用 `tauri::async_runtime::spawn_blocking` 执行重计算（XML 大、CPU 高时）。

---

# 6) 可选：双目标（前端也能跑算法的“预览版”）

如果将来想在前端 WebView **离线预览/试算**（不连设备），可把子 crate 做成 **双目标**：

* `default`（native）：给 Tauri 后端用
* `wasm` feature：关掉不可移植依赖，`wasm32-unknown-unknown` 编译给前端演示（轻量模式）

```toml
# crates/structure-match/Cargo.toml
[features]
wasm = []
```

> 不是必须；先把 native 跑顺即可。

---

# 7) 小坑提醒

* **共享类型别混**：后端 Tauri 命令层尽量用 **DTO**（可为 TS 导出）与内核 `Sm*` 类型分离一层，避免把所有内核细节暴露给前端。
* **跨线程安全**：缓存、索引等放到 `Send + Sync` 容器（`parking_lot::Mutex/Arc`）。
* **大 XML 传输**：可以考虑传文件路径或 gzip 压缩后 base64；或由后端自己 `adb pull`，前端只发「触发命令」。
* **跨平台依赖**：`structure-match` 只放纯算法（`serde/xxhash/bitvec` 这类），不要引入 OS 相关依赖，打包更稳。

---

## 总结

* **是的，非常适合前后端联动**：

  * **独立子 crate = 结构匹配内核**（纯算法、可测试、可缓存、可扩展）
  * **Tauri 后端 = 薄命令层**（适配 XML、持久缓存、设备 I/O）
  * **前端 = UI + 强类型 `invoke`**（自动生成 TS 类型）

* 这套分层让你：

  * 避免命名撞车（全部以 `structure_match::Sm*` 命名）
  * 快速并行开发（内核/命令/UI 各自迭代）
  * 将来能在别的项目/CLI 里直接复用“结构匹配”能力。

