我一个 多crate 的tauri项目， ai代理它如何通过vscode理解？ 

绝对能搞定，而且多 crate 的 Tauri 项目**更适合**做“可被 AI 代理读懂”的工程化结构。下面给你一套**最小但专业**的 VS Code + 多 crate 架构，让 Copilot/ChatGPT（含你自己的 AI-Explorer）秒懂项目、能跑、能定位、能按模块改。

---

# 你要的目标

1. AI 知道**项目地图**（有哪些 crate/前端/命令）。
2. AI 能**一键跑/测/查**每个 crate（不会在根目录乱跑）。
3. AI 有**清晰指令**（AGENTS 指南 + 任务/脚本 + 类型映射）。
4. 结构匹配内核是**独立子 crate**，与 Tauri 后端**低耦合**。

---

# ① Workspace 与目录约定

```
/Cargo.toml                  # [workspace] 声明
/src-tauri/                  # Tauri 后端命令层（调用结构匹配内核） 
/src/                        # 前端（React/Vite）
/crates/
  /structure-match/          # ← 结构匹配内核（独立子 crate）
/docs/
  CRATES.md                  # 自动生成的项目地图（AI 入口）
.vscode/
  settings.json              # rust-analyzer / TypeScript 映射
  tasks.json                 # AI 可直接点的任务
  launch.json                # Tauri 调试
  extensions.json            # 推荐插件
AGENTS.md                    # 给 AI 的“怎么读/怎么改/怎么跑”的清单
```

**根 Cargo.toml（必须有 workspace）**

```toml
[workspace]
members = ["src-tauri", "crates/structure-match"]
resolver = "2"
```

---

# ② VS Code 设置（让 AI 和 LSP 真正“看懂”）

**.vscode/settings.json**

```json
{
  "rust-analyzer.linkedProjects": [
    "${workspaceFolder}/Cargo.toml",
    "${workspaceFolder}/src-tauri/Cargo.toml",
    "${workspaceFolder}/crates/structure-match/Cargo.toml"
  ],
  "rust-analyzer.cargo.features": "all",
  "rust-analyzer.procMacro.enable": true,
  "rust-analyzer.check.allTargets": true,
  "editor.formatOnSave": true,
  "files.exclude": { "**/target": true },
  "typescript.tsserver.maxTsServerMemory": 4096
}
```

**.vscode/extensions.json**

```json
{ "recommendations": [
  "rust-lang.rust-analyzer", "tamasfe.even-better-toml",
  "tauri-apps.tauri-vscode", "ms-vscode.vscode-typescript-next"
]}
```

---

# ③ 任务与一键操作（AI 代理最爱）

**.vscode/tasks.json**（统一任务名，AI 只要执行这些）

```json
{
  "version": "2.0.0",
  "tasks": [
    { "label": "[AI] Check all", "type": "shell", "command": "cargo check --workspace" },
    { "label": "[AI] Test structure-match", "type": "shell", "command": "cargo test -p structure-match" },
    { "label": "[AI] Bench structure-match", "type": "shell", "command": "cargo bench -p structure-match", "problemMatcher": [] },
    { "label": "[AI] Dev Tauri", "type": "shell", "command": "pnpm tauri dev", "options": { "cwd": "${workspaceFolder}" } }
  ]
}
```

---

# ④ 给 AI 的“读法说明”（强烈建议）

**AGENTS.md（精简但关键）**

```md
# AGENTS 指南（多 crate Tauri）
- 根是 Cargo workspace；核心算法在 `crates/structure-match`（不可引 UI 依赖）。
- Tauri 命令层在 `src-tauri`，只做 XML 适配 + 调用 `structure_match::sm_run_once(...)`。
- 前端 `src` 通过 Tauri invoke 调后端 `sm_match_once` 命令。

## 常用命令（VS Code 任务）
- 构建/检查：`[AI] Check all`
- 内核测试：`[AI] Test structure-match`
- Tauri 调试：`[AI] Dev Tauri`

## 修改守则
- **结构匹配算法**：只改 `crates/structure-match/*`。
- **后端命令/设备I/O**：改 `src-tauri/*`。
- **前端 UI/类型**：改 `src/*`。若改了后端 DTO，请同步生成 TS 类型。
```

---

# ⑤ 自动“项目地图”（AI 一眼看懂）

用 `cargo metadata` 自动生成 `/docs/CRATES.md`（crate 依赖图 + 入口文件）。

```rust
// scripts/gen_crates_map.rs
// scripts/gen_crates_map.rs
use cargo_metadata::{MetadataCommand};
fn main() {
  let md = MetadataCommand::new().exec().unwrap();
  println!("# CRATES MAP\n");
  for p in &md.packages {
    println!("- `{}` → {}", p.name, p.manifest_path.display());
  }
}
```

运行：`cargo run --quiet --manifest-path scripts/Cargo.toml` → 写入 `docs/CRATES.md`。
（也可用 `cargo tree` 输出依赖图。）

---

# ⑥ 结构匹配内核（独立子 crate）对外 API

* crate 名：`structure-match`（代码里 `structure_match`）
* 只暴露 Facade：`sm_run_once(...)` + `SmConfig/SmResult` + 2 个 trait（`SmXmlView/SmCache`）

```rust
// crates/structure-match/src/lib.rs
// crates/structure-match/src/lib.rs
pub mod prelude;
pub mod types; pub mod config; pub mod orchestrator;
pub mod ports; pub mod container_gate; pub mod layout_gate;
pub mod signature; pub mod skeleton; pub mod field_refine;
pub mod scoring; pub mod diag;
```

```rust
// crates/structure-match/src/prelude.rs
// crates/structure-match/src/prelude.rs
pub use crate::types::*;
pub use crate::config::*;
pub use crate::orchestrator::sm_run_once;
pub use crate::ports::xml_view::SmXmlView;
pub use crate::ports::cache::{SmCache, NoopCache};
```

> 这样 AI（和人）只需打开 `prelude.rs` 就能知道**怎么用**。

---

# ⑦ Tauri 后端：**薄**命令层桥接

```rust
// src-tauri/src/commands/structure_match.rs
// src-tauri/src/commands/structure_match.rs
use tauri::State;
use structure_match::prelude::*;
#[tauri::command]
async fn sm_match_once(step_cfg: SmConfigDto, xml: String, want_all: bool, state: State<'_, AppState>)
 -> Result<SmResultDto, String> {
  let indexer = MyXmlIndexer::new(&xml)?;
  let view = MyXmlViewAdapter::new(&indexer);     // 实现 SmXmlView
  let mut cache = state.cache.lock();
  let cfg: SmConfig = step_cfg.into();
  let res = sm_run_once(&view, &mut *cache, &cfg, want_all);
  Ok(SmResultDto::from(res))
}
```

---

# ⑧ 强类型联动（TS 类型自动同步）

* 用 `ts-rs` 或 `tauri-specta` 导出 DTO 到 `src/bindings/`：
  前端直接 `import type { SmResult } from '@/bindings/SmResult'`。
  AI 代理就不会在类型上“猜”。

---

# ⑨ “行为护栏”（防止 AI 乱改）

* `.github/CODEOWNERS`：`/crates/structure-match/ @you`
* `AGENTS.md` 里明确**只在指定目录改**；PR 模板要求勾选“改动范围”。
* 可选：在 `structure-match` 的 `Cargo.toml` 加 `publish = false` 与注释，防止误发布。

---

# ⑩ 给 AI 的首条提示（放到 `.github/copilot-instructions.md`）

```md
- 总入口：`crates/structure-match/src/prelude.rs`
- 如需修改算法，仅在 `crates/structure-match` 下操作；不要动 `src-tauri` 设备I/O。
- 先跑 `[AI] Test structure-match`，再跑 `[AI] Dev Tauri`。
- 若新增对前端返回字段，请同步导出 TS 类型（ts-rs/tauri-specta）。
```

---

## 小结（给你一句话）

把“结构匹配”放到**独立子 crate**，在 VS Code 里用 **Workspace + rust-analyzer + 统一任务 + 项目地图 + AGENTS 指南**，
AI 代理（和人）就能**快速定位**到正确目录、**调用正确 API**、**按任务跑起来**，
而且**不会跟 Tauri 后端和前端代码搅在一起**。
这就是多 crate Tauri 项目里“前后端联动 + AI 友好”的标准姿势。
