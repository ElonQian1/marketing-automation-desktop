好的， 我现在要 保持 子文件夹/子文件  模块化 的做好这个功能。

一次 dump 的推荐执行顺序（带早停）

我要怎么样的代码架构？

专注于 “结构匹配”这个子功能模块的。考虑到 模块撞名 的问题。 

你认为是怎么样的呢？ 请你给出架构

太对了，避免和你别的“engine”撞名，**把它做成一个独立的“结构匹配（Structure-Match）子系统”**。下面给你一套可以直接落到仓库的**模块化目录 + 对外 API + 早停管道**。名字都围绕“structure_match”，公开类型统一用 **Sm*** 前缀，彻底规避命名冲突。

---

# 顶层形态（推荐）

* ✅ **独立子 crate**（最佳）：`/crates/structure-match/`（被 Tauri 后端依赖）
* 或 ✅ **后端内聚模块**：`src-tauri/src/structure_match/`

工作区 `Cargo.toml` 里把它作为子包即可。

---

# 目录结构（专注“结构匹配”）

```
structure_match/
├─ lib.rs                 // Facade：对外只暴露 SmRunOnce / 配置 / 结果
├─ prelude.rs             // 方便上层 use
├─ types.rs               // Sm* 公共类型（SmLayoutType/SmScores/SmItemHit...）
├─ config.rs              // SmConfig（权重/早停/规则/容器提示）
├─ orchestrator.rs        // ★ 一次 dump 的顺序 + 早停 + 缓存入口（SmRunOnce）
│
├─ ports/                 // 适配层（不直接依赖你的 XmlIndexer）
│  ├─ xml_view.rs         // trait SmXmlView（get_bounds/children/attr/pre/post…）
│  └─ cache.rs            // trait SmCache（xml_hash/container → 缓存几何/模板）
│
├─ container_gate/        // 容器限域（找“那个大盒子”）
│  ├─ detector.rs         // 检测/回退：StepCard hint → 指纹 → 全局最大可滚容器
│  └─ hint.rs             // container_xpath / 指纹匹配策略
│
├─ layout_gate/           // 几何=版式分类器（不是只给瀑布）
│  ├─ columns.rs          // 按 left 聚列、列宽一致性、行对齐度
│  ├─ metrics.rs          // 高度CV/宽度占比/可见度等
│  └─ classifier.rs       // 输出 SmLayoutType + S_geom
│
├─ signature/             // 模板签名=重复性（从多卡片学“共同指纹”）
│  ├─ features.rs         // 分桶特征：宽桶、AR桶、文本数桶、深度桶、顺序位…
│  ├─ hasher.rs           // 位图编码 + xxhash64，Hamming 距离
│  ├─ learner.rs          // 只采样每列前 8~12 个，Top-K + 聚类，带缓存
│  └─ matcher.rs          // 与模板比对，产出 S_tpl
│
├─ skeleton/              // 骨架=规则校验（必须有图/文/上下顺序/弹性±1）
│  ├─ dsl.rs              // 规则 DSL（声明式）
│  └─ checker.rs          // 执行校验，产 S_struct
│
├─ field_refine/          // 字段/文本微调（你的面板权重/“必须等于”）
│  └─ scorer.rs           // 空/非空一致/完全匹配/相似度/必等于 → S_field
│
├─ scoring/
│  ├─ weights.rs          // 三档权重：Speed/Default/Robust（可被覆盖）
│  ├─ combiner.rs         // S_total = w⋅(geom,tpl,struct,field)
│  └─ gates.rs            // 闸门：唯一性==1 or top-gap≥0.15；min_conf≥0.70
│
└─ diag/
   ├─ log.rs              // 阶段耗时打点：dump/parse/geom/tpl/struct/field
   └─ overlay.rs          // （可选）导出列线/命中高亮给前端
```

---

# 关键对外 API（Facade）

```rust
// structure_match/lib.rs
pub use crate::prelude::*;

//
// structure_match/prelude.rs
//
pub use crate::types::{
    SmNodeId, SmBounds, SmLayoutType, SmScores, SmItemHit, SmContainerHit, SmResult
};
pub use crate::config::{SmMode, SmConfig};
pub use crate::orchestrator::sm_run_once;
pub use crate::ports::xml_view::SmXmlView;
pub use crate::ports::cache::{SmCache, NoopCache};
```

```rust
// structure_match/types.rs
pub type SmNodeId = u32;

#[derive(Clone, Copy)]
pub struct SmBounds { pub left:i32, pub top:i32, pub right:i32, pub bottom:i32 }

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum SmLayoutType { WaterfallMulti, MasonrySingle, UniformGrid, List, Carousel, Unknown }

#[derive(Default, Clone)]
pub struct SmScores { pub geom:f32, pub tpl:f32, pub skeleton:f32, pub field:f32, pub total:f32 }

pub struct SmItemHit { pub node:SmNodeId, pub bounds:SmBounds, pub scores:SmScores }
pub struct SmContainerHit { pub node:SmNodeId, pub bounds:SmBounds, pub layout:SmLayoutType }

pub struct SmResult { pub container: Option<SmContainerHit>, pub items: Vec<SmItemHit> }
```

```rust
// structure_match/config.rs
#[derive(Clone)]
pub enum SmMode { Speed, Default, Robust }

#[derive(Clone)]
pub struct SmConfig {
  pub mode: SmMode,
  pub allowed_layouts: Option<Vec<SmLayoutType>>, // None=Auto
  pub skip_geometry: bool,                        // 早停1：已知版式
  pub skip_template_when_single: bool,            // 早停2：只取一个目标时跳过模板
  pub strict_skeleton_only: bool,                 // 早停3：只跑骨架（极速/稳定）
  pub min_confidence: f32,                        // 缺省 0.70
  // 容器提示 & 规则
  pub container_hint: Option<ContainerHint>,      // xpath 或 指纹
  pub skeleton_rules: SkeletonRules,              // 骨架DSL
  pub field_rules: FieldRules,                    // 文本“必须等于”等
}
```

```rust
// structure_match/ports/xml_view.rs
pub trait SmXmlView {
  fn xml_hash(&self) -> &str;
  fn container_candidates(&self) -> Vec<SmNodeId>; // 可滚/面积大/StepCard hint命中优先
  fn bounds(&self, n:SmNodeId) -> SmBounds;
  fn parent(&self, n:SmNodeId) -> Option<SmNodeId>;
  fn children(&self, n:SmNodeId) -> Vec<SmNodeId>;
  fn class(&self, n:SmNodeId) -> &str;
  fn text(&self, n:SmNodeId) -> &str;
  fn attr(&self, n:SmNodeId, k:&str) -> Option<&str>;
  fn pre(&self, n:SmNodeId) -> u32;               // 祖先判断 O(1)
  fn post(&self, n:SmNodeId) -> u32;
}
```

```rust
// structure_match/orchestrator.rs
pub fn sm_run_once<V: SmXmlView, C: SmCache>(
  view: &V, cache: &mut C, cfg: &SmConfig, want_all: bool
) -> SmResult {
  // 1) 容器限域
  let container = container_gate::detector::pick_container(view, cache, cfg);
  if container.is_none() && !cfg.allow_fallback() { return SmResult{ container:None, items:vec![] } }
  let container = container.or_else(|| container_gate::detector::fallback(view));

  // 早停3：只骨架
  if cfg.strict_skeleton_only {
    return run_skeleton_only(view, &container, cfg, want_all);
  }

  // 2) 几何分类（可跳过）
  let layout = if cfg.skip_geometry { SmLayoutType::Unknown }
               else { layout_gate::classifier::classify(view, container.node) };

  // 3) 模板签名（找同类；仅“取一个”可跳过）
  let templates = if want_all || !cfg.skip_template_when_single {
    signature::learner::learn_or_load(view, cache, container.node, layout)
  } else { vec![] };

  // 候选 item 根
  let mut items = propose_item_roots(view, container.node);

  // 模板过滤（有模板时）
  if !templates.is_empty() {
    signature::matcher::score_tpl(view, &templates, &mut items);
    items.retain(|it| it.scores.tpl > 0.1);
  }

  // 4) 骨架 + 字段
  skeleton::checker::score_skeleton(view, &cfg.skeleton_rules, &mut items);
  field_refine::scorer::score_fields(view, &cfg.field_rules, &mut items);

  // 5) 合成 + 闸门 + 选择
  scoring::weights::apply_mode(cfg.mode, &mut items);
  scoring::combiner::combine(&mut items);
  let mut passed = scoring::gates::retain_passed(items, cfg.min_confidence);
  scoring::gates::sort_desc(&mut passed);
  if !want_all { passed.truncate(1); }

  SmResult { container: Some(container), items: passed }
}
```

> **早停一览**
>
> * `skip_geometry`：你已从 StepCard 指定版式 → 跳过几何分类
> * `skip_template_when_single`：只取一个目标 → 可跳过模板学习/匹配
> * `strict_skeleton_only`：稳定场景极限提速 → 仅跑骨架/字段

---

# 集成方式（不侵入原有代码）

1. 你的现有 `XmlIndexer` 实现 `SmXmlView` trait（适配即可，无需改内部）。
2. 在 V3 执行链需要“结构匹配”时调用：

   ```rust
   use structure_match::prelude::*;
   let res = sm_run_once(&xml_view, &mut cache, &cfg, /*want_all=*/true);
   ```
3. StepCard → `SmConfig`：把你面板里的“文本必须等于/字段权重/容器提示/预期版式”等映射过来。

---

# 为什么这样命名/分层更适合“结构匹配”子域

* **不再用 engine**，外部只看到 `structure_match::*`；公开名以 **Sm*** 起头，绝无冲突。
* **职责单一**：container_gate（限域）、layout_gate（几何=版式）、signature（重复性）、skeleton（硬规则）、field_refine（文本/字段）、scoring（权重/闸门）、orchestrator（顺序与早停）。
* **易扩展**：要支持新版式/新签名特征/新骨架规则，只改对应子目录。
* **易裁剪**：极速/默认/强鲁棒三档由 `SmMode` 和三个早停开关控制。
* **易测试**：每个 gate 都可单测；`ports::xml_view` 让你用假 DOM 做端到端测试。

---

# 最简实施路径（一天内跑起来）

1. 创建 `structure_match/`，放入 `types.rs / config.rs / prelude.rs / lib.rs`。
2. 先落 `skeleton/ + field_refine/ + scoring/ + orchestrator.rs`，打开 `strict_skeleton_only=true` 跑通。
3. 接 `container_gate/`（限域）与 `layout_gate/`（几何分类）。
4. 最后接 `signature/`（模板学习+匹配，带缓存），开启 `want_all=true` 找全同类卡片。

---

**一句话**：
把“几何→模板签名→骨架→字段→打分→早停”封装进**`structure_match` 子系统**，公开类型统一 **Sm*** 前缀，对外一个入口 `sm_run_once`。这既**专注“结构匹配”**、又**彻底避免命名撞车**，同时保留你要的**一次 dump 顺序与早停**。
