是的——你说的“向上查找最近的可滚动集合（RecyclerView/ListView/GridView/ViewPager…）”本质上就是**“容器限域”算法**里的「容器识别」步骤。更严谨地讲，可以把整套逻辑分成三层命名：

1. **容器限域（Container Scoping）——总称/目标**
   把真机匹配的搜索空间，限定在“正确的容器子树”里。

2. **容器识别（Container Discovery）——你提到的向上查找**
   从点选元素向上找到最近的**可滚动集合容器**（优先 RecyclerView 等），并生成 `container_xpath` / `container_id`。

3. **容器选择策略（Container Selection Policy）——有歧义时如何定夺**
   例如同层存在多个可滚动容器时按优先级选择；或用户手动指定时覆盖自动识别。

推荐在代码与协议里这样落名（中英双语）：

* 字段/协议

  * `container_scope`（容器限域）

    * `discovery`（识别）：`mode: 'scrollable_ancestor' | 'manual'`
    * `policy`（选择策略）：`class_whitelist`, `require_scrollable`, `max_depth`
    * `xpath`（识别产物）/ `id`（后端解析产物）

* 前端 TS（示例命名）

  * `container-scope.ts`

    * `discoverScrollableAncestor(element, tree)`（容器识别）
    * `chooseContainer(candidates, policy)`（容器选择策略）
    * `buildContainerXPath(node)`（XPath 生成）

* 后端 Rust（与你现有结构对齐）

  * `src-tauri/src/domain/structure_runtime_match/container_gate.rs`

    * `fn resolve_container_id(xpath: &str, xml: &Xml) -> Result<NodeId>`
    * `fn apply_container_scope(node_set, container_id) -> NodeSet`

* 日志口径（便于排错）

  * `[container_scope] xpath=..., resolved_id=..., class=..., bounds=..., child_count=...`
  * 若解析到 Root（id=0）→ 明确打印并拒绝继续匹配（除非策略允许）。

一句话：把“向上查找可滚动祖先”称为**容器识别**，它隶属于更大的**容器限域**算法；最终由**容器选择策略**决定用哪个容器并将搜索空间**限域**到该容器子树。这样命名既贴合你的文档表述，又便于模块化与后续扩展。
