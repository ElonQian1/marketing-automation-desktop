选卡片本身，没问题。通用做法是：**从你点中的节点往上爬，先锁定“卡片根”，再锁定“卡片的大容器”**。给你一套可落地的“容器发现算法”。

# 通用容器发现算法（适配瀑布流/列表）

**输入**：用户在可视化里点中的节点 `S`，以及同屏 XML（或缓存 id）。
**输出**：`card_root` 与 `container`（含 `xpath/role/depth_hint/bounds`）。

## A. 先找卡片根 `card_root`

从 `S` 沿祖先链向上，选出第一个满足：

1. `clickable=true`；
2. `bounds` 不接近整屏（面积 < 0.95×屏幕）；
3. 其子树包含“卡片常见骨架”（比如：上半区大图 + 底部信息栏 / 若干 `TextView` 等 —— 只看**结构**，不看文本等值）。

> 实务上常落在：`FrameLayout|ViewGroup|ConstraintLayout|RelativeLayout` 中的某一层。
> 你这类页面通常是**内层 `FrameLayout(clickable=true)`** 作为卡片根，文本都在它的子孙里。

## B. 再找“大容器” `container`

从 `card_root` 继续向上爬，给每个祖先打分，选得分最高且过阈值的那个：

* **scrollable 信号（权重大）**
  `@scrollable='true'` 或 class 在白名单：`RecyclerView|ListView|GridView|ScrollView|NestedScrollView|ViewPager2` → +0.5

* **同构子项信号**
  该祖先的**直接子项**里，至少有 2 个以上与 `card_root` **宽度近似**（±10%）且**骨架签名相似**（只看结构，不看文案） → +0.3

* **布局/覆盖率信号**
  容器 `bounds` 高度 ≥ 卡片高度×2 且不接近整屏（<0.98×屏幕）→ +0.1

* **深度惩罚**
  距离 `card_root` 越远，–depth×0.05

> 一般会命中 `androidx.recyclerview.widget.RecyclerView`（瀑布流/网格/列表都用它）。
> 找到后输出：
>
> * `role`: `RecyclerView`（或真实类名）
> * `xpath`: 例如 `//androidx.recyclerview.widget.RecyclerView[@scrollable='true']`
> * `depth_hint`: `card_root` 到容器的层级距离
> * `bounds`: 容器外接矩形（可用于运行时**限域过滤**）

**阈值建议**：`score ≥ 0.7` 视为容器。若无候选过阈值，退而求其次：选择**最近的**满足“同构子项信号”的祖先。

## C. 生成可执行签名

* `container`: 上一步产物（强烈建议携带 `xpath` 或 `bounds`，运行时先**限域**再匹配）
* `skeleton`（结构规则）：仅用**结构/类名/层级/可点父**等“稳定特征”，**不要**默认把 `text/content-desc` 做等值（这会被“搜索框里的‘关注’”“个人简介里的‘关注’”误伤）。
* 若你的模态框里用户**显式勾选**“文本等值（含负词排除）”，再把 `text=关注` 等值/负词规则追加进去（保持你现有的“微调开关”，默认**关闭**等值）。

---

## 伪代码（放在前端生成器 / 后端 `container_gate` 都可）

```ts
function findCardRoot(node S): Node {
  for (let a of ancestors(S, includeSelf=true)) {
    if (a.clickable && !isFullscreen(a.bounds) && looksLikeCardSkeleton(a)) {
      return a; // 内层可点父
    }
  }
  return S; // 兜底
}

function findContainer(cardRoot R): Node {
  let best = null, bestScore = 0;
  for (let a of ancestors(R, includeSelf=false)) {
    let score = 0;
    if (a.scrollable || classInWhitelist(a.class)) score += 0.5;
    if (hasHomogeneousItemSiblings(a, R))        score += 0.3;
    if (coverageIsReasonable(a.bounds))           score += 0.1;
    score -= depth(R, a) * 0.05;

    if (score > bestScore) { best = a; bestScore = score; }
  }
  return (bestScore >= 0.7) ? best : fallbackNearestHomogeneousAncestor(R);
}

function buildContainerSignature(container C) {
  return {
    role: classBaseName(C.class), // e.g. RecyclerView
    depth_hint: depthFromCardRoot,
    xpath: buildXpath(C),         // 优先带 @scrollable='true'
    bounds: C.bounds              // 运行时先限域再匹配
  };
}
```

> `looksLikeCardSkeleton` 仅做结构特征：有“媒体区 + 信息区”两段式、信息区内存在若干 `TextView/ImageView/小图标/数字`，不读取具体文案。
> `hasHomogeneousItemSiblings`：在容器的直接子项里，抽样 3~6 个，与 `card_root` 的“结构签名”Jaccard 相似度 ≥ 0.7 计入同构。

---

## 和你当前实现如何对接

* **结构匹配模态框**：“确定”时把 `xmlCacheId + selectedNodeId` 传给生成器；生成器先跑 A/B 两步，得到：

  * `structural_signatures.container = { role, depth_hint, xpath, bounds }`
  * `structural_signatures.skeleton = [...]`
* **保持现有“字段微调开关”**（文本等值/负词）。默认不等值；用户勾选时再加规则，避免误命中“搜索框里的关注/简介里的关注”。

---

## 一个你页面的典型输出示例（示意）

```json
{
  "container": {
    "role": "RecyclerView",
    "depth_hint": 2,
    "xpath": "//androidx.recyclerview.widget.RecyclerView[@scrollable='true']",
    "bounds": [0, 216, 1080, 2240]
  },
  "skeleton": [
    { "field_config": { "class_contains": "FrameLayout", "presence_only": true }, "tag": "class-element" },
    { "field_config": { "clickable": true, "presence_only": true },             "tag": "generic-element" },
    { "field_config": { "position_hint": "top_media", "presence_only": true },  "tag": "region-element" },
    { "field_config": { "position_hint": "bottom_info_bar", "presence_only": true }, "tag": "region-element" }
    // …可再细一点，但仍避免默认文本等值
  ]
}
```

---

## 小结

* 点“卡片本身”是对的；算法替你**自动向上**找 `RecyclerView` 等容器。
* **默认**只用结构与容器限域来找“卡片集合”；需要特定“关注”按钮时，再**显式**打开文案等值与负词。
* 这样既能避开“搜索框/简介里的‘关注’”，又不被多语言/AB/广告插卡干扰。


是的，但更精确地说分两步：

* **容器识别（Container Discovery）**：从你点选的元素往上爬，判定“最近的**可滚动集合**”是谁（RecyclerView/ListView/GridView/ScrollView/ViewPager2…），并产出一个**容器签名**（role/xpath/bounds/depth_hint/score）。
* **容器限域（Container Gating）**：拿到“容器签名”后，**把后续匹配/搜索都限制在该容器子树**里运行（pre/post 过滤、坐标/层级裁剪等）。

所以你说的“向上查找容器识别算法升级”，**属于“容器限域”的前置步骤**；合起来就叫“容器限域（识别→限域）”。

下面给你一套对你项目更贴切的命名与接口（便于落地）：

```rust
// src-tauri/src/domain/structure_runtime_match/container_gate/mod.rs

/// 容器签名（供 StepCard/StrategyPlan 持久化）
pub struct ContainerSignature {
    pub node_id: u32,              // 运行期可选
    pub role: String,              // "RecyclerView" / "ListView" / ...
    pub xpath: Option<String>,     // 例如 //androidx.recyclerview.widget.RecyclerView[@scrollable='true']
    pub bounds: Option<(i32,i32,i32,i32)>, // 运行期可用于 bounds 限域
    pub depth_hint: u8,            // card_root 到容器的祖先距离
    pub score: f32,                // 识别置信度
}

/// A. 容器识别：从选中节点沿祖先链向上打分，返回得分最高的可滚容器
pub fn discover_container(xml: &XmlView, start: NodeId) -> Option<ContainerSignature>;

/// B. 容器限域：基于签名，返回该容器子树的节点/候选迭代器
pub fn limit_subtree<'a>(xml: &'a XmlView, c: &ContainerSignature) -> impl Iterator<Item=NodeId> + 'a;
```

前端/策略契约（写入 StepCard 的 JSON）可以这样放字段（与你现有约定一致）：

```json
{
  "structural_signatures": {
    "container": {
      "role": "RecyclerView",
      "xpath": "//androidx.recyclerview.widget.RecyclerView[@scrollable='true']",
      "bounds": [0,216,1080,2240],
      "depth_hint": 2,
      "score": 0.86
    },
    "skeleton": [ /* …卡片结构规则… */ ]
  }
}
```

小结：把它叫**“容器限域”**完全没问题；实现上记住是**“容器识别 → 容器限域”**两步法。先识别谁是“集合容器”，再把匹配范围收缩到该容器内，你的“瀑布流卡片集合 → 第一个/批量”就会稳定很多。
