# 结构匹配模态框功能优化方案 - 决策讨论2

> **背景**: 基于决策讨论1中提出的"自动评价→自动选型"思路，分析当前结构匹配模态框的功能现状，提出增强优化方案。

---

## 📊 现有功能模块盘点

### ✅ **已实现模块**

#### 1. **全局配置模块**
```typescript
// 全局匹配阈值控制
globalThreshold: 0.7 (70%)
```
- **功能**: Slider 控制整体匹配成功的置信度阈值
- **位置**: 模态框顶部区域
- **状态**: ✅ 完整实现

#### 2. **智能模板系统**
```typescript
// 预定义模板类型
ELEMENT_TEMPLATES = {
  'card-item': '卡片项',
  'button-with-icon': '带图标按钮', 
  'input-field': '输入框',
  'list-item': '列表项',
  'content-block': '内容块'
}
```
- **功能**: 智能识别并应用模板、手动选择模板
- **特性**: 显示已应用模板标签、模板描述
- **状态**: ✅ 完整实现

#### 3. **结构快照生成器**
```typescript
// 自动生成空/非空匹配规则
StructuralSnapshotGenerator.generateSnapshot(selectedElement, {
  enableGeometry: false,
  enableTemplate: false,
  mode: 'Default'
})
```
- **功能**: 基于DOM结构自动生成匹配规则
- **特性**: 字段规则自动应用到配置
- **状态**: ✅ 完整实现

#### 4. **元素结构树预览**
```typescript
// 层级结构展示与字段配置
<ElementStructureTreeWithPreview
  selectedElement={selectedElement}
  getFieldConfig={getFieldConfig}
  onToggleField={toggleField}
  onUpdateField={updateField}
/>
```
- **功能**: 显示选中元素层级结构、字段开关与权重配置
- **特性**: 实时预览匹配效果
- **状态**: ✅ 完整实现

#### 5. **状态显示栏**
```typescript
// 匹配状态展示
displayInfo = { 
  scoreText: '85%', 
  percentage: 85, 
  statusText: '匹配', 
  statusColor: '#52c41a' 
}
```
- **功能**: 预计得分显示、匹配状态标签
- **状态**: ✅ 完整实现

---

## 🚨 缺失功能分析（基于决策讨论1需求）

### ❌ **核心缺失：自动模式评估与推荐**

**目标**: 用户点选元素后，系统自动进行三路评分，推荐最优模式

#### 缺失的三路评分系统:
1. **子孙骨架评分** (Card/Subtree) - 适合卡片/有结构容器
2. **叶子上下文评分** (Leaf/Context) - 适合点赞/头像等无子孙控件  
3. **文本强等值评分** (Text/Exact) - 仅用于"关注/已关注"等稳定按钮

#### 缺失的推荐机制:
```typescript
// 期望的推荐流程
AutoModeSelector.auto_pick(clicked_node) => {
  recommended: MatchMode,
  outcomes: [
    { mode: 'CardSubtree', conf: 0.78, passed_gate: true, explain: '子孙骨架：结构完整' },
    { mode: 'LeafContext', conf: 0.85, passed_gate: true, explain: '叶子上下文：可点父明确' }, 
    { mode: 'TextExact', conf: 0.45, passed_gate: false, explain: '文本不稳定（数字类）' }
  ]
}
```

### ❌ **瀑布流卡片特殊支持**

**背景**: 瀑布流卡片有多层重叠元素，用户随意点击应能找到同一卡片

#### 缺失的重叠层回收机制:
```rust
// 期望的回收规则
向上遍历找到最近可点父 -> 再上层找到项根FrameLayout -> 结构匹配主锚
```

#### 缺失的容器限域:
- RecyclerView 容器识别
- 左右列分区 (bounds.left ≈ 13 和 546)
- 列内相对排序 (bounds.top)

### ❌ **高级配置面板（可折叠）**

**需求**: 展开"高级开关"显示细化配置

#### 缺失配置项:
```typescript
// 期望的高级配置
{
  leafControl: {
    useContextSkeleton: true,  // 叶子控件：使用上下文骨架
    label: '上下文骨架（默认开）'
  },
  cardControl: {
    useSubtreeSkeleton: true,  // 卡片：使用子孙骨架
    label: '子孙骨架（默认开）'
  },
  textMatching: {
    mode: 'non_empty' | 'prefix' | 'exact',  // 仅非空/前缀/强等值
    autoExact: false,  // 检测到"关注/已关注"时自动勾选
    label: '文本匹配策略'
  }
}
```

### ❌ **评分解释面板**

**需求**: 显示三路评分的详细结果和推荐理由

---

## 🎯 新增功能模块规划

### 📊 **模块1: 智能推荐引擎**

#### 功能设计:
```tsx
<AutoRecommendationPanel>
  <Button type="primary" icon={<ThunderboltOutlined />}>
    智能推荐最佳模式
  </Button>
  
  {recommendationResult && (
    <Card className="recommendation-result">
      <Space direction="vertical">
        <Tag color="blue" size="large">
          推荐: {recommendationResult.recommended}
        </Tag>
        
        <Collapse>
          <Panel header="查看详细评分">
            {recommendationResult.outcomes.map(outcome => (
              <ScoreItem 
                mode={outcome.mode}
                confidence={outcome.conf} 
                passed={outcome.passed_gate}
                explanation={outcome.explain}
              />
            ))}
          </Panel>
        </Collapse>
      </Space>
    </Card>
  )}
</AutoRecommendationPanel>
```

#### 集成要点:
- 调用 `AutoModeSelector::auto_pick()` 获取推荐
- 默认选中推荐模式
- 用户可查看但无需手动配置

### 🎯 **模块2: 场景识别器**

#### 功能设计:
```tsx
<SceneDetector selectedElement={selectedElement}>
  <Alert 
    type="info" 
    message={`识别场景: ${detectedScene.type}`}
    description={detectedScene.description}
    showIcon
  />
  
  <Space>
    <Tag color="green">容器: {detectedScene.container}</Tag>
    <Tag color="blue">元素类型: {detectedScene.elementType}</Tag>
    {detectedScene.isWaterfall && (
      <Tag color="orange">瀑布流卡片</Tag>
    )}
  </Space>
</SceneDetector>
```

#### 识别逻辑:
```typescript
// 场景识别规则
detectScene(element) => {
  // 瀑布流卡片检测
  if (hasRecyclerViewAncestor(element) && 
      hasContentDescPattern(element, /^(笔记|视频|直播)/)) {
    return {
      type: 'WaterfallCard',
      container: 'RecyclerView',
      elementType: 'FrameLayout', 
      isWaterfall: true,
      description: '瀑布流卡片，建议使用子孙骨架匹配'
    }
  }
  
  // 按钮检测
  if (element.clickable && hasTextContent(element)) {
    return {
      type: 'Button',
      container: 'None',
      elementType: element.class,
      isWaterfall: false,
      description: '可点击按钮，建议使用文本或叶子匹配'
    }
  }
}
```

### 🔧 **模块3: 高级配置面板**

#### UI布局:
```tsx
<Collapse ghost>
  <Panel header="高级配置选项" key="advanced">
    <Space direction="vertical" style={{ width: '100%' }}>
      
      {/* 叶子控件配置 */}
      <Card size="small" title="叶子控件配置">
        <Switch 
          checked={config.leafControl.useContextSkeleton}
          onChange={(checked) => updateConfig('leafControl', { useContextSkeleton: checked })}
        />
        <span style={{ marginLeft: 8 }}>使用上下文骨架（默认开）</span>
      </Card>
      
      {/* 卡片配置 */} 
      <Card size="small" title="卡片配置">
        <Switch 
          checked={config.cardControl.useSubtreeSkeleton}
          onChange={(checked) => updateConfig('cardControl', { useSubtreeSkeleton: checked })}
        />
        <span style={{ marginLeft: 8 }}>使用子孙骨架（默认开）</span>
      </Card>
      
      {/* 文本匹配策略 */}
      <Card size="small" title="文本匹配策略">
        <Radio.Group 
          value={config.textMatching.mode}
          onChange={(e) => updateConfig('textMatching', { mode: e.target.value })}
        >
          <Radio value="non_empty">仅非空（默认）</Radio>
          <Radio value="prefix">前缀匹配</Radio> 
          <Radio value="exact">强等值</Radio>
        </Radio.Group>
        
        {config.textMatching.mode === 'exact' && (
          <Alert 
            type="warning" 
            message="强等值仅推荐用于'关注/已关注'等稳定按钮文本"
            style={{ marginTop: 8 }}
          />
        )}
      </Card>
      
    </Space>
  </Panel>
</Collapse>
```

### 📈 **模块4: 实时评分预览**

#### 功能设计:
```tsx
<RealTimeScorePreview>
  <Title level={5}>实时评分</Title>
  
  {scores.map(score => (
    <div key={score.mode} className="score-item">
      <Space justify="space-between" style={{ width: '100%' }}>
        <Text>{score.modeName}</Text>
        <Space>
          <Progress 
            percent={score.confidence * 100} 
            size="small" 
            status={score.passed ? 'success' : 'exception'}
            showInfo={false}
          />
          <Text type={score.passed ? 'success' : 'danger'}>
            {(score.confidence * 100).toFixed(0)}%
          </Text>
          {score.passed && <CheckCircleOutlined style={{ color: '#52c41a' }} />}
        </Space>
      </Space>
      
      {/* 阈值线标记 */}
      <div className="threshold-line" style={{ 
        position: 'relative',
        height: 2,
        background: '#f0f0f0',
        marginTop: 4
      }}>
        <div style={{
          position: 'absolute',
          left: `${globalThreshold * 100}%`,
          width: 2,
          height: 2,
          background: '#ff4d4f',
          top: 0
        }} />
      </div>
    </div>
  ))}
</RealTimeScorePreview>
```

### 🎨 **模块5: 预设方案库**

#### 功能设计:
```tsx
<PresetLibrary>
  <Title level={5}>快速预设</Title>
  
  <Space wrap>
    {presets.map(preset => (
      <Button 
        key={preset.id}
        type={appliedPreset === preset.id ? 'primary' : 'default'}
        onClick={() => applyPreset(preset)}
      >
        {preset.name}
      </Button>
    ))}
    
    <Button icon={<PlusOutlined />} onClick={openSaveDialog}>
      保存当前配置
    </Button>
  </Space>
  
  <Divider />
  
  {/* 预设详情 */}
  {selectedPreset && (
    <Card size="small" title={selectedPreset.name}>
      <Text type="secondary">{selectedPreset.description}</Text>
      <br />
      <Text code>适用场景: {selectedPreset.scenarios.join(', ')}</Text>
    </Card>
  )}
</PresetLibrary>
```

#### 预设方案示例:
```typescript
const PRESETS = [
  {
    id: 'follow-button',
    name: '关注按钮',
    description: '适用于关注/已关注状态切换按钮',
    scenarios: ['社交应用', '用户资料页'],
    config: {
      mode: 'TextExact',
      textMatching: { mode: 'exact', patterns: ['关注', '已关注', 'Follow'] },
      threshold: 0.80
    }
  },
  {
    id: 'waterfall-card', 
    name: '瀑布流卡片',
    description: '适用于小红书等瀑布流布局的卡片',
    scenarios: ['瀑布流', '网格布局', '卡片列表'],
    config: {
      mode: 'CardSubtree',
      containerLimit: 'RecyclerView',
      useSubtreeSkeleton: true,
      threshold: 0.75
    }
  },
  {
    id: 'like-button',
    name: '点赞按钮', 
    description: '适用于点赞、收藏等交互按钮',
    scenarios: ['社交应用', '内容页面'],
    config: {
      mode: 'LeafContext',
      useContextSkeleton: true,
      geometryWeight: 0.3,
      threshold: 0.70
    }
  }
];
```

---

## 🚀 实施优先级与建议

### **Phase 1: 核心自动推荐 (高优先级)**
1. ✅ 实现 `AutoModeSelector` Rust模块
2. ✅ 集成三路评分到模态框
3. ✅ 默认选中推荐模式

### **Phase 2: 瀑布流特殊支持 (高优先级)**  
1. ✅ 重叠层回收机制
2. ✅ 容器限域识别
3. ✅ 场景自动检测

### **Phase 3: UI体验优化 (中优先级)**
1. ✅ 高级配置面板
2. ✅ 实时评分预览  
3. ✅ 评分解释面板

### **Phase 4: 扩展功能 (低优先级)**
1. ✅ 预设方案库
2. ✅ 用户自定义方案
3. ✅ 批量配置功能

---

## 💡 关键技术要点

### **1. 保持向后兼容**
```typescript
// 现有模态框功能完全保留
// 新功能作为增强，不破坏现有流程
const enhancedModal = {
  ...existingFeatures,  // 保留现有功能
  autoRecommendation,   // 新增自动推荐
  sceneDetection,       // 新增场景识别
  advancedConfig        // 新增高级配置
};
```

### **2. 渐进式启用**
```typescript
// 通过feature flag控制新功能启用
const features = {
  autoRecommendation: true,   // 优先启用核心功能
  sceneDetection: true,       
  advancedConfig: false,      // 后续版本启用
  presetLibrary: false
};
```

### **3. 数据流整合**
```typescript
// 新功能与现有数据流无缝整合
useStructuralMatchingModal() => {
  // 现有功能
  const existingConfig = useHierarchicalMatchingModal();
  
  // 新增功能
  const recommendation = useAutoRecommendation(selectedElement);
  const sceneInfo = useSceneDetection(selectedElement);
  
  return {
    ...existingConfig,
    recommendation,
    sceneInfo,
    applyRecommendation: () => { /* 应用推荐配置到现有config */ }
  };
}
```

---

## 🎯 预期收益

### **用户体验提升**
- **零配置使用**: 直接点"确定"即可获得最优配置  
- **配置可解释**: 显示推荐理由和评分详情
- **场景感知**: 自动识别瀑布流等特殊场景

### **匹配成功率提升**
- **三路评分**: 覆盖更多元素类型和场景
- **智能回退**: 评分不通过时的兜底策略
- **稳定性**: 避免文本强等值的数字陷阱

### **开发效率提升**
- **预设方案**: 常见场景一键应用
- **批量配置**: 减少重复配置工作  
- **调试友好**: 详细的评分解释和日志

---

---

## 🎯 **最佳落地方案（总线统一架构）**

> **核心结论**: 把"旧六步 + 新结构匹配"统一成**一个三路自动选型的总线**，前台"零配置"，后台"强回退"。

### **🔄 架构转换：从"手工挑策略" → "自动评价推荐"**

#### 当前问题诊断:
```typescript
// ❌ 现状：需要人工挑选策略
用户点选 → 生成卡片 → 手动选择6种策略之一 → 后台执行
//        ↑ 决策负担在用户    ↑ 结构匹配只是第7个选项

// ✅ 目标：自动推荐最优策略  
用户点选 → 三路并行评分 → 自动推荐最佳模式 → 用户点"确定" → 执行
//                    ↑ 决策由系统完成        ↑ 零配置体验
```

#### 核心转换思路:
- **收敛策略**: 6+1种策略 → 3路评分器（子孙骨架/叶子上下文/文本强等值）
- **前移决策**: 用户手动选择 → 系统自动推荐
- **后置回退**: 单一策略失败 → 强回退链保障

---

### **📋 八步落地清单**

#### **步骤1: 引入三路评分总线（AutoModeSelector）**

```rust
// src-tauri/src/domain/structure_runtime_match/auto_mode_selector.rs
// 统一闸门：min_conf=0.70, top_gap=0.15

pub struct AutoModeSelector {
    subtree_matcher: SubtreeMatcher,      // A: 子孙骨架评分
    leaf_context_matcher: LeafContextMatcher, // B: 叶子上下文评分  
    text_exact_matcher: TextExactMatcher,     // C: 文本强等值评分
}

impl AutoModeSelector {
    pub fn auto_pick(&self, clicked_node: usize) -> AutoPickResult {
        // 三路并行打分
        let subtree_score = self.subtree_matcher.score(clicked_node);    // 适合卡片/有层级区域
        let leaf_score = self.leaf_context_matcher.score(clicked_node);  // 点赞/头像/小角标等
        let text_score = self.text_exact_matcher.score(clicked_node);    // 仅稳定按钮("关注/已关注")
        
        // 择优输出推荐，若全不过闸门按 B → A → C 回退
        select_best_mode(subtree_score, leaf_score, text_score)
    }
}
```

#### **步骤2: 升级"结构匹配"为三路评分器容器**

```typescript
// 现有"结构匹配"作为 A/B 两路的实现载体
StructuralMatching = {
  // A路：子孙骨架
  subtreeMode: {
    features: ['类名', '层级', '可点性', '子计数'],
    geometry: '几何比例（禁像素等值）',
    适用: '卡片/有结构容器'
  },
  
  // B路：叶子上下文  
  leafContextMode: {
    features: ['祖先链', '兄弟序列', '相对几何', '字段位图（空/非空）'],
    专为: '无子孙叶子控件',
    典型: 'like按钮/头像/角标'
  }
}

// C路：文本强等值（新增独立模块）
TextExactMatcher = {
  稳定性检查: '短词 && 非纯数字/时间',
  白名单: ['关注', '已关注', 'Follow', 'Following'], 
  黑名单: ['147赞', '2:30', '￥299'] // 防易变值误匹配
}
```

#### **步骤3: 瀑布流重叠层回收 + 容器限域（默认启用）**

```rust
// 重叠层统一回收机制
fn recover_overlapping_layers(clicked_element: Element) -> Element {
    // 向上回收：任意子节点 → 可点父 → 项根
    let clickable_parent = find_ancestor(clicked_element, |el| {
        el.class == "FrameLayout" && el.clickable == true
    });
    
    let item_root = find_ancestor(clickable_parent, |el| {
        el.class == "FrameLayout" && 
        el.content_desc.is_some() && 
        el.resource_id.is_empty()  // 关键特征：resource_id为空
    });
    
    return item_root; // 结构匹配的主锚
}

// 容器限域过滤
fn container_scoped_search(target_element: Element) -> Vec<Element> {
    let recycler_view = find_ancestor(target_element, |el| {
        el.class == "RecyclerView"
    });
    
    // 限定搜索范围 + 左右列分区 + 列内top排序
    return filter_candidates_within_container(recycler_view, target_element);
}
```

#### **步骤4: 前台模态框 - 默认智能推荐**

```tsx
// 模态框打开即显示推荐结果
<StructuralMatchingModal>
  {/* 主推荐区 - 默认显示 */}
  <RecommendationPanel>
    <Alert type="success" showIcon>
      <Space>
        <Text strong>智能推荐: </Text>
        <Tag color="blue" size="large">{recommendation.mode}</Tag>
        <Text>置信度: {recommendation.confidence}%</Text>
      </Space>
    </Alert>
    
    <Text type="secondary">
      {recommendation.explanation}
    </Text>
  </RecommendationPanel>
  
  {/* 高级配置 - 可折叠 */}
  <Collapse ghost>
    <Panel header="高级配置选项">
      <Space direction="vertical">
        <Switch checked={leafContextEnabled}>叶子控件：上下文骨架（默认开）</Switch>
        <Switch checked={subtreeEnabled}>卡片：子孙骨架（默认开）</Switch>
        <Radio.Group value={textMode}>
          <Radio value="non_empty">文本匹配：仅非空（默认）</Radio>
          <Radio value="prefix">前缀匹配</Radio>
          <Radio value="exact">强等值（检测到"关注/已关注"自动勾选）</Radio>
        </Radio.Group>
      </Space>
    </Panel>
    
    <Panel header="评分详情">
      {recommendation.scores.map(score => (
        <ScoreDetail 
          mode={score.mode} 
          confidence={score.conf}
          passed={score.passed_gate}
          explanation={score.explain}
        />
      ))}
    </Panel>
  </Collapse>
</StructuralMatchingModal>
```

#### **步骤5: StepCard契约统一（向后兼容）**

```typescript
// 统一写入格式，保持旧策略兼容
StepCardData = {
  strategy: {
    selected: "structure_match", // 不变
    mode: recommendation.mode,    // 新增：推荐模式标识
  },
  
  plan: {
    // A路：子孙骨架
    card_signature: {...},       // 卡片结构签名
    
    // B路：叶子上下文  
    slot: { 
      hint: "like_button",       // 槽位提示
      context: {...}             // 上下文线索
    },
    
    // C路：文本强等值
    text: { 
      mode: "exact",             // exact/prefix/non_empty
      patterns: ["关注", "已关注"] 
    }
  },
  
  config: {
    prefer_context_for_leaf: true,    // 默认配置
    card_use_subtree_shape: true,
    auto_container_scoped: true       // 新增：自动容器限域
  },
  
  intent: {
    action: "open_detail",            // 保持现有契约
    scope: "match-original"
  }
}
```

#### **步骤6: 旧六步策略融入新总线**

```rust
// 旧策略重新定位：从"用户选择项" → "特征提取器 + 回退链"
LegacyStrategiesIntegration = {
  // 融入特征提取（不再需要用户手选）
  自锚定: "融入三路评分的基础特征",
  子元素文本驱动: "融入叶子上下文的兄弟序列分析", 
  区域约束: "融入容器限域的前置过滤",
  
  // 移至回退链（降级使用）
  XPath绝对值: "移到RecoveryManager的降级链",
  XPath索引: "移到RecoveryManager的降级链", 
  应急兜底: "仍在Recovery层，但尽量少触发"
}
```

#### **步骤7: 统一闸门 + 强回退链**

```rust
// 执行前置检查
fn execute_with_fallback(mode: MatchMode, config: Config) -> ExecutionResult {
    // 统一闸门检查
    if !passes_confidence_gate(mode.confidence, 0.70) || 
       !passes_top_gap_check(mode.confidence, runner_up.confidence, 0.15) {
        return fallback_chain(mode, config);
    }
    
    // 模式特定回退
    match mode {
        MatchMode::LeafContext => {
            execute_leaf_with_fallback(&[
                "目标槽位", 
                "同区容器（底栏）", 
                "可点父（整卡）"
            ])
        },
        MatchMode::CardSubtree => {
            execute_card_with_fallback(&[
                "项根相似", 
                "可点父"
            ])
        },
        MatchMode::TextExact => {
            execute_text_with_fallback(&[
                "Exact", 
                "Prefix/NonEmpty", 
                "忽略文本走A/B路"
            ])
        }
    }
}
```

#### **步骤8: 度量埋点 + 数据化迭代**

```rust
// 推荐效果度量
struct RecommendationMetrics {
    hit_rate: f32,           // 推荐模式命中率
    fallback_rate: f32,      // 回退触发率  
    page_pattern: String,    // 页面/包名模式
    element_type: String,    // 元素类型模式
}

// 自动模板覆盖（数据化补丁）
fn auto_template_override() {
    // 若某页面在同一元素类型上"叶子上下文失败率" > 阈值
    // 自动下发模板覆盖，而非修改算法
    if leaf_context_failure_rate > 0.3 {
        deploy_template_patch(page_pattern, element_type, fallback_strategy);
    }
}
```

---

### **🎯 与现状的对位关系**

#### 问题根源:
```
❌ 当前: 点选 → 生成卡片 → 人工挑策略 → 后台按旧代码评分/六种策略执行
        ↑ 决策负担在用户    ↑ 结构匹配只是新增第7个选项
```

#### 解决方案:
```  
✅ 改进: 点选 → 三路评分 → 自动推荐 → 用户点"确定" → 执行
        ↑ 系统自动评价    ↑ 零配置体验      ↑ 强回退保障
```

#### 收敛效果:
- **策略数量**: 6+1种 → 3路（子孙骨架/叶子上下文/文本强等值）
- **用户决策**: 手动选择 → 自动推荐（可查看但无需配置）
- **失败处理**: 单点失败 → 强回退链（多层保障）

---

### **⚡ 两周上线里程碑**

#### **Week 1: 核心总线（P0）**
- ✅ 实现 `AutoModeSelector` 三路评分器
- ✅ 模态框默认勾选推荐项  
- ✅ 瀑布流"回收+容器限域"默认启用

#### **Week 2: 体验优化（P1）** 
- ✅ 评分详情面板展示
- ✅ 场景识别提示（瀑布流/按钮）
- ✅ StepCard契约最小扩展

#### **后续迭代（P2）**
- ✅ Recovery降级链统一（XPath/索引/应急）
- ✅ 埋点度量与模板覆盖通道

---

### **🏆 三赢效果预期**

#### **易用性**: 
- 用户"零配置"：直接点"确定"获得最优方案
- 系统"自解释"：显示推荐理由和评分详情

#### **稳定性**:
- 三路并行评分覆盖更多场景
- 强回退链确保兜底成功  
- 容器限域避免误匹配

#### **可解释性**:
- 详细评分展示便于调试
- 推荐算法透明可追溯
- 数据驱动的迭代优化

---

**结论**: 把"结构匹配"升级为**三路评分器 + 自动选型总线**，将旧六步融入特征提取与回退链，实现前台零配置、后台强回退的理想架构。通过两周迭代即可上线核心功能，同时获得易用性、稳定性、可解释性的全面提升。