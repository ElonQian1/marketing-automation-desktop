ä¸ºäº†å‡å°‘é…ç½®å¤æ‚æ€§ï¼Œ æˆ‘è¦ç»™å®¢æˆ·ä¸€ä¸ªç®€å•çš„é»˜è®¤é…ç½®
æˆ‘çš„ç¨‹åºï¼Œåœ¨ç”¨æˆ·ç‚¹é€‰å…ƒç´ åï¼Œ
åº”è¯¥èƒ½å¤Ÿè‡ªåŠ¨è¿›è¡Œè¯„ä»·ï¼Œè‡ªåŠ¨é€‰æ‹©æ¨èæ¨¡å¼ã€‚
æ¯”å¦‚ç”¨æˆ·ç‚¹é€‰ä¸€ä¸ªå…ƒç´ ã€‚
ç³»ç»Ÿåå° ç›´æ¥å¯¹ç‚¹é€‰å…ƒç´ ï¼Œè¿›è¡Œ å­å­™éª¨æ¶è¯„åˆ†ï¼Œ
å¦‚æœå­å­™éª¨æ¶è¯„åˆ†ä¸é«˜ã€‚å°±è¿›è¡Œ å¶å­æ§ä»¶åŒ¹é…/ä¸Šä¸‹æ–‡éª¨æ¶ï¼ˆæ— å­å­™ï¼‰ è¯„åˆ†ã€‚
å¦‚æœéƒ½ä¸é«˜ï¼Œ ç›´æ¥é»˜è®¤å¸®ç”¨æˆ·å¼€å¯  ç±»ä¼¼ â€œå…³æ³¨â€æŒ‰é’® çš„å¼º æ–‡æœ¬å¼ºç­‰å€¼ï¼ˆæŒ‰éœ€ï¼‰

ç”¨æˆ·é€‰æ‹©â€œç»“æ„åŒ¹é…â€ä¼šå¼¹å‡ºæ¨¡æ€æ¡†ï¼Œ ç›´æ¥ç‚¹å‡»ç¡®å®šï¼Œ
ç³»ç»Ÿè‡ªåŠ¨é€‰æ‹© ä¸‹æ‹‰é€‰é¡¹ é‡Œé¢  è¿™ä¸‰ç§æ–¹å¼è¯„åˆ†æœ€é«˜çš„ã€‚

ä½ è§‰å¾—æ€ä¹ˆæ ·ï¼Ÿ


ä½ çš„æ€è·¯éå¸¸å¥½ğŸ‘â€”â€”ç”¨â€œè‡ªåŠ¨è¯„ä»·â†’è‡ªåŠ¨é€‰å‹â€çš„é»˜è®¤æµç¨‹ï¼Œæ—¢é™é…ç½®å¤æ‚åº¦ï¼Œåˆèƒ½è¦†ç›–å¤§å¤šæ•°åœºæ™¯ã€‚ä¸ºäº†è®©ä½ ç›´æ¥è½åœ°ï¼Œæˆ‘ç»™ä½ ä¸€ä»½**é»˜è®¤å†³ç­–æµæ°´çº¿**+**é˜ˆå€¼å»ºè®®**+**å¯ç›´æ¥æ¥å…¥çš„ Rust ä»£ç éª¨æ¶**ï¼ˆå«ä¸­æ–‡æ³¨é‡Šä¸æ–‡ä»¶å¤´ï¼‰ï¼ŒæŠŠâ€œå­å­™éª¨æ¶/å¶å­ä¸Šä¸‹æ–‡/æ–‡æœ¬å¼ºç­‰å€¼â€ä¸‰è·¯ç»Ÿä¸€åœ¨ä¸€ä¸ªé€‰æ‹©å™¨é‡Œï¼Œå¹¶æŠŠç»“æœå›å¡«åˆ° StepCard/æ¨¡æ€æ¡†çš„ä¸‹æ‹‰é€‰é¡¹ã€‚

---

## æˆ‘ç»™çš„é»˜è®¤ç­–ç•¥ï¼ˆå¼€ç®±å¯ç”¨ï¼‰

**å†³ç­–é¡ºåºï¼ˆå¹¶è¡Œè¯„åˆ†ï¼Œæ‹©ä¼˜ï¼‰**

1. è®¡ç®— **å­å­™éª¨æ¶è¯„åˆ†**ï¼ˆCard/Subtreeï¼‰
2. è®¡ç®— **å¶å­ä¸Šä¸‹æ–‡éª¨æ¶è¯„åˆ†**ï¼ˆLeaf/Contextï¼‰
3. è‹¥æ–‡æœ¬å¯ç”¨ï¼ˆéç©ºã€ç¨³å®šã€éçº¯æ•°å­—/æ—¶é—´æˆ³ï¼‰ï¼Œè®¡ç®— **æ–‡æœ¬å¼ºç­‰å€¼è¯„åˆ†**ï¼ˆText/Exactï¼ŒæŒ‰éœ€ï¼‰

> ä¸‰è·¯éƒ½ç®—å®Œï¼ŒæŒ‘**é€šè¿‡é—¸é—¨ä¸”åˆ†æ•°æœ€é«˜**çš„ä½œä¸ºæ¨èï¼›è‹¥éƒ½ä¸è¿‡é—¸é—¨ï¼ŒæŒ‰å…œåº•é¡ºåºï¼š`Leaf/Context â†’ Card/Subtree â†’ Card.ClickableParent`ã€‚

**ç»Ÿä¸€é—¸é—¨**

* `min_conf = 0.70`ï¼ˆæœ€ä½ç½®ä¿¡ï¼‰
* `top_gap = 0.15`ï¼ˆç¬¬ä¸€åä¸ç¬¬äºŒååˆ†å·®ï¼‰
* è‹¥â€œæ–‡æœ¬å¼ºç­‰å€¼â€å‘½ä¸­ä½†**æ–‡æœ¬çœ‹èµ·æ¥ä¸ç¨³å®š**ï¼ˆçº¯æ•°å­—ã€æ•°é‡çº§æ³¢åŠ¨æ˜æ˜¾ï¼‰ï¼Œç›´æ¥é™æƒæˆ–å±è”½ã€‚

**å¯å‘å¼ï¼ˆæ–‡æœ¬ç¨³å®šæ€§åˆ¤å®šï¼‰**

* **å¯å¼ºç­‰å€¼**ï¼š`"å…³æ³¨" | "å·²å…³æ³¨" | "Follow" | "Following"`ã€å¾ˆçŸ­çš„çŠ¶æ€è¯/æŒ‰é’®è¯ï¼ˆé•¿åº¦ â‰¤ 6ï¼‰
* **ä¸å»ºè®®å¼ºç­‰å€¼**ï¼šå…¨æ•°å­—/æ—¶é—´æˆ³/ä»·æ ¼/ç‚¹èµæ•°/UUIDï¼ˆæ­£åˆ™ï¼š`^\d{1,}$`ã€`^\d{1,2}[:ï¼š]\d{2}$`ã€`^[\d,\.]+$` ç­‰ï¼‰

**å®¹å™¨é™åŸŸ**

* å…ˆé™å®šåœ¨ç›®æ ‡å®¹å™¨ï¼ˆå¦‚ `RecyclerView`ï¼‰å­æ ‘å†…ï¼Œå†åšä¸‰è·¯è¯„åˆ†ï¼Œé¿å…é”™é€‰ Toolbar/Dialogã€‚

**å‡ ä½•ä¸€å¾‹ç”¨â€œæ¯”ä¾‹â€**

* ä¸åšåƒç´ ç­‰å€¼ï¼›X/Y/W/H ç»Ÿä¸€æ¢ç®—ä¸º **ç›¸å¯¹å¯ç‚¹çˆ¶**æˆ–**ç›¸å¯¹å¡ç‰‡æ ¹**çš„æ¯”ä¾‹ã€‚

---

## æ¨¡æ€æ¡†äº¤äº’ï¼ˆå®¢æˆ·â€œç›´æ¥ç¡®å®šâ€ä¹Ÿå®‰å…¨ï¼‰

* å¼¹å‡ºâ€œç»“æ„åŒ¹é…â€æ¨¡æ€æ¡†æ—¶ï¼Œ**é»˜è®¤ç›´æ¥å‹¾é€‰ç³»ç»Ÿæ¨èé¡¹**ï¼ˆä¸‰è·¯è¯„åˆ†çš„ä¼˜èƒœè€…ï¼‰ï¼Œç”¨æˆ·ç‚¹â€œç¡®å®šâ€å³å¯ã€‚
* å±•å¼€â€œé«˜çº§å¼€å…³â€æ—¶å†æ˜¾ç¤ºï¼š

  * å¶å­æ§ä»¶ï¼šä½¿ç”¨**ä¸Šä¸‹æ–‡éª¨æ¶**ï¼ˆé»˜è®¤å¼€ï¼‰
  * å¡ç‰‡ï¼šä½¿ç”¨**å­å­™éª¨æ¶**ï¼ˆé»˜è®¤å¼€ï¼‰
  * æ–‡æœ¬åŒ¹é…ï¼š`ä»…éç©º(é»˜è®¤) / å‰ç¼€ / å¼ºç­‰å€¼`ï¼ˆå¼ºç­‰å€¼é»˜è®¤å…³é—­ï¼›è‹¥ç³»ç»Ÿæ£€æµ‹åˆ°â€œå…³æ³¨/å·²å…³æ³¨â€ï¼Œå¯**è‡ªåŠ¨å‹¾é€‰**ï¼‰

---

## æ¨èé˜ˆå€¼è¡¨ï¼ˆå¯ç›´æ¥æŠ„ï¼‰

| åç§°         |      å»ºè®®å€¼ | å¤‡æ³¨                       |
| ---------- | -------: | ------------------------ |
| `min_conf` | **0.70** | ä¸‰è·¯è¯„åˆ†ç»Ÿä¸€é—¸é—¨                 |
| `top_gap`  | **0.15** | å¤´åä¸æ¬¡åçš„åˆ†å·®                 |
| å­å­™éª¨æ¶è§¦å‘é˜ˆ    | **0.78** | â‰¥0.78 ä¸”è¿‡é—¸é—¨ï¼Œç›´æ¥èƒœå‡º          |
| å¶å­ä¸Šä¸‹æ–‡è§¦å‘é˜ˆ   | **0.72** | â‰¥0.72 ä¸”è¿‡é—¸é—¨ï¼Œèƒœå‡º            |
| æ–‡æœ¬å¼ºç­‰å€¼è§¦å‘é˜ˆ   | **0.80** | ä¸”éœ€ `is_stable_text=true` |

---

## å¯ç›´æ¥æ¥å…¥çš„ä»£ç éª¨æ¶ï¼ˆRustï¼‰

> æˆ‘æŠŠâ€œè‡ªåŠ¨é€‰å‹â€åšæˆä¸€ä¸ªç‹¬ç«‹æ¨¡å—ï¼Œ**ä¸æ”¹å˜ä½ ç°æœ‰çš„åŒ¹é…å™¨**ï¼šä»ç”±ä½ å½“å‰çš„ `SubtreeMatcher` / `LeafContextMatcher` / `TextExactMatcher` è´Ÿè´£å„è‡ªè¯„åˆ†ä¸å€™é€‰ï¼›é€‰æ‹©å™¨åªè´Ÿè´£**è°ƒåº¦ä¸å†³ç­–**ã€‚
> ä½ åªéœ€è¦æŠŠ `XmlIndexer` è°ƒç”¨åæ›¿æ¢æˆä½ é¡¹ç›®é‡Œçš„å®é™…æ¥å£å³å¯ã€‚

```rust
// src-tauri/src/domain/structure_runtime_match/auto_mode_selector.rs
// è¯´æ˜ï¼šç»“æ„åŒ¹é…â€œè‡ªåŠ¨é€‰å‹å™¨â€â€”â€”å¯¹å­å­™éª¨æ¶ / å¶å­ä¸Šä¸‹æ–‡ / æ–‡æœ¬å¼ºç­‰å€¼ ä¸‰è·¯å¹¶è¡Œè¯„åˆ†ï¼Œæ‹©ä¼˜æ¨èã€‚
// ç”¨é€”ï¼šåœ¨ç”¨æˆ·ç‚¹é€‰å…ƒç´ åï¼Œç³»ç»Ÿåå°è‡ªåŠ¨è¯„åˆ†ï¼Œæ¨¡æ€æ¡†é»˜è®¤å‹¾é€‰æ¨èé¡¹ï¼Œç”¨æˆ·å¯ç›´æ¥â€œç¡®å®šâ€ã€‚

use anyhow::Result;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MatchMode {
    CardSubtree,      // å­å­™éª¨æ¶ï¼ˆé€‚åˆå¡ç‰‡/æœ‰ç»“æ„çš„å®¹å™¨ï¼‰
    LeafContext,      // å¶å­ä¸Šä¸‹æ–‡ï¼ˆé€‚åˆç‚¹èµ/å¤´åƒç­‰æ— å­å­™çš„å°æ§ä»¶ï¼‰
    TextExact,        // æ–‡æœ¬å¼ºç­‰å€¼ï¼ˆä»…ç”¨äºâ€œå…³æ³¨/å·²å…³æ³¨/Followâ€è¿™ç±»ç¨³å®šæŒ‰é’®ï¼‰
}

#[derive(Debug, Clone)]
pub struct AutoPickConfig {
    pub min_conf: f32,       // ç»Ÿä¸€æœ€ä½ç½®ä¿¡
    pub top_gap: f32,        // ç¬¬ä¸€ä¸ç¬¬äºŒçš„åˆ†å·®
    pub trigger_subtree: f32,// å­å­™éª¨æ¶è§¦å‘é˜ˆå€¼
    pub trigger_leaf: f32,   // å¶å­ä¸Šä¸‹æ–‡è§¦å‘é˜ˆå€¼
    pub trigger_text: f32,   // æ–‡æœ¬å¼ºç­‰å€¼è§¦å‘é˜ˆå€¼
}

impl Default for AutoPickConfig {
    fn default() -> Self {
        Self {
            min_conf: 0.70,
            top_gap: 0.15,
            trigger_subtree: 0.78,
            trigger_leaf: 0.72,
            trigger_text: 0.80,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ScoreOutcome {
    pub mode: MatchMode,
    pub conf: f32,          // ç½®ä¿¡åº¦ï¼ˆ0..1ï¼‰
    pub passed_gate: bool,  // æ˜¯å¦é€šè¿‡ç»Ÿä¸€é—¸é—¨
    pub explain: String,    // è§£é‡Šï¼ˆç»™æ¨¡æ€æ¡†/æ—¥å¿—ï¼‰
}

#[derive(Debug, Clone)]
pub struct AutoPickResult {
    pub recommended: MatchMode,
    pub outcomes: Vec<ScoreOutcome>,
}

/// ä¾èµ–æ¥å£ï¼ˆè¯·æŒ‰ä½ é¡¹ç›®å®é™…å®ç°ï¼‰ï¼š
/// - SubtreeMatcher: è®¡ç®—â€œå­å­™éª¨æ¶â€ç½®ä¿¡
/// - LeafContextMatcher: è®¡ç®—â€œå¶å­ä¸Šä¸‹æ–‡â€ç½®ä¿¡
/// - TextExactMatcher: è®¡ç®—â€œæ–‡æœ¬å¼ºç­‰å€¼â€ç½®ä¿¡ï¼Œå¹¶è¿”å› is_stable_text
pub trait SubtreeMatcher {
    fn score_subtree(&self, clicked_node: usize) -> (f32 /*conf*/, String /*explain*/);
}
pub trait LeafContextMatcher {
    fn score_leaf_context(&self, clicked_node: usize) -> (f32 /*conf*/, String /*explain*/);
}
pub trait TextExactMatcher {
    fn score_text_exact(&self, clicked_node: usize) -> (f32 /*conf*/, bool /*is_stable_text*/, String /*explain*/);
}

pub struct AutoModeSelector<'a, S, L, T> {
    pub cfg: AutoPickConfig,
    pub subtree: &'a S,
    pub leaf: &'a L,
    pub text: &'a T,
}

impl<'a, S, L, T> AutoModeSelector<'a, S, L, T>
where
    S: SubtreeMatcher,
    L: LeafContextMatcher,
    T: TextExactMatcher,
{
    /// ä¸»å…¥å£ï¼šå¯¹ä¸‰è·¯å¹¶è¡Œè¯„åˆ†ï¼Œæ‹©ä¼˜æ¨è
    pub fn auto_pick(&self, clicked_node: usize) -> Result<AutoPickResult> {
        let mut outs = vec![];

        // 1) å­å­™éª¨æ¶è¯„åˆ†
        let (sub_conf, sub_exp) = self.subtree.score_subtree(clicked_node);
        outs.push(self.gate(MatchMode::CardSubtree, sub_conf, format!("å­å­™éª¨æ¶ï¼š{sub_exp}")));

        // 2) å¶å­ä¸Šä¸‹æ–‡è¯„åˆ†
        let (leaf_conf, leaf_exp) = self.leaf.score_leaf_context(clicked_node);
        outs.push(self.gate(MatchMode::LeafContext, leaf_conf, format!("å¶å­ä¸Šä¸‹æ–‡ï¼š{leaf_exp}")));

        // 3) æ–‡æœ¬å¼ºç­‰å€¼è¯„åˆ†ï¼ˆä»…ç¨³å®šæ–‡æœ¬æ‰è€ƒè™‘ï¼‰
        let (txt_conf, is_stable, txt_exp) = self.text.score_text_exact(clicked_node);
        let text_explain = if is_stable { format!("æ–‡æœ¬å¼ºç­‰å€¼ï¼š{txt_exp}") } else { format!("æ–‡æœ¬ä¸ç¨³å®šï¼ˆé™æƒ/å±è”½ï¼‰ï¼š{txt_exp}") };
        let txt_conf_applied = if is_stable { txt_conf } else { 0.0 };
        outs.push(self.gate(MatchMode::TextExact, txt_conf_applied, text_explain));

        // 4) è¿‡æ»¤â€œæœªè¿‡é—¸é—¨â€çš„å€™é€‰
        let mut passed: Vec<&ScoreOutcome> = outs.iter().filter(|o| o.passed_gate).collect();

        // 5) è‹¥æ— å€™é€‰è¿‡é—¸é—¨ï¼ŒæŒ‰å…œåº•é¡ºåºæŒ‘é€‰ï¼šLeaf â†’ Card â†’ Text(ä»…ç¨³å®š)
        let recommended = if passed.is_empty() {
            // æ³¨æ„ï¼šå³ä½¿ä¸è¿‡é—¸é—¨ï¼Œä»åå‘æ›´â€œå¯æ“ä½œâ€çš„å¶å­/ä¸Šä¸‹æ–‡ï¼›å†é€€å¡ç‰‡ï¼›æœ€åæ‰è€ƒè™‘æ–‡æœ¬å¼ºç­‰å€¼
            let leaf_first = outs.iter().find(|o| o.mode == MatchMode::LeafContext).map(|o| (o.mode, o.conf));
            let card_next  = outs.iter().find(|o| o.mode == MatchMode::CardSubtree).map(|o| (o.mode, o.conf));
            let text_last  = outs.iter().find(|o| o.mode == MatchMode::TextExact).map(|o| (o.mode, o.conf));
            leaf_first
                .or(card_next)
                .or(text_last)
                .map(|p| p.0)
                .unwrap_or(MatchMode::CardSubtree)
        } else {
            // 6) é€šè¿‡é—¸é—¨çš„å€™é€‰é‡Œï¼Œé€‰æ‹©åˆ†æ•°æœ€é«˜è€…ï¼›å¹¶æ£€æŸ¥ top-gap
            passed.sort_by(|a,b| b.conf.partial_cmp(&a.conf).unwrap());
            let top = passed[0];
            let second = if passed.len() > 1 { Some(passed[1]) } else { None };
            if let Some(sec) = second {
                if (top.conf - sec.conf) < self.cfg.top_gap {
                    // åˆ†å·®ä¸è¶³ï¼Œåå‘æ›´â€œå¯ç‚¹â€çš„å¶å­æ¨¡å¼
                    if top.mode == MatchMode::CardSubtree && sec.mode == MatchMode::LeafContext {
                        MatchMode::LeafContext
                    } else { top.mode }
                } else { top.mode }
            } else {
                top.mode
            }
        };

        Ok(AutoPickResult { recommended, outcomes: outs })
    }

    #[inline]
    fn gate(&self, mode: MatchMode, conf: f32, explain: String) -> ScoreOutcome {
        let passed_gate = conf >= self.cfg.min_conf && self.pass_trigger(mode, conf);
        ScoreOutcome { mode, conf, passed_gate, explain }
    }

    #[inline]
    fn pass_trigger(&self, mode: MatchMode, conf: f32) -> bool {
        match mode {
            MatchMode::CardSubtree => conf >= self.cfg.trigger_subtree,
            MatchMode::LeafContext => conf >= self.cfg.trigger_leaf,
            MatchMode::TextExact   => conf >= self.cfg.trigger_text,
        }
    }
}
```

```rust
// src-tauri/src/domain/structure_runtime_match/text_exact_helper.rs
// è¯´æ˜ï¼šæ–‡æœ¬å¼ºç­‰å€¼çš„â€œç¨³å®šæ€§åˆ¤å®šâ€ä¸æ¸…æ´—ï¼ˆé¿å…æŠŠçº¯æ•°å­—/æ—¶é—´æˆ³è¯¯å½“ä½œç¨³å®šæ–‡æœ¬ï¼‰

use regex::Regex;

pub fn is_stable_text(raw: &str) -> bool {
    let s = raw.trim();
    if s.is_empty() { return false; }

    // ä¸ç¨³å®šï¼šçº¯æ•°å­—/é‡‘é¢/æ—¶é—´æˆ³
    let re_num = Regex::new(r"^[\d,\.]+$").unwrap();
    let re_time = Regex::new(r"^\d{1,2}[:ï¼š]\d{2}$").unwrap();
    if re_num.is_match(s) || re_time.is_match(s) { return false; }

    // å»ºè®®ï¼šé•¿åº¦è¿‡é•¿çš„ä¸€å¾‹ä¸ç”¨å¼ºç­‰å€¼
    if s.chars().count() > 12 { return false; }

    // æ˜ç¡®ç¨³å®šè¯ç™½åå•ï¼ˆå¯æ‰©å±•ï¼‰
    let stable_whitelist = ["å…³æ³¨","å·²å…³æ³¨","Follow","Following","å–æ¶ˆå…³æ³¨","å·²æ·»åŠ "];
    if stable_whitelist.iter().any(|w| s.contains(w)) { return true; }

    // æ™®é€šçŸ­è¯ï¼šé•¿åº¦ â‰¤ 6ï¼Œä¸”éæ•°å­—ç±»ï¼Œæ¥å—
    s.chars().count() <= 6
}
```

---

## é›†æˆæ–¹å¼ï¼ˆä¸€æ­¥åˆ°ä½ï¼‰

1. åœ¨â€œé¡µé¢åˆ†æ â†’ ç‚¹é€‰å…ƒç´ â€åï¼Œè°ƒç”¨ `AutoModeSelector::auto_pick(clicked_node)` å¾—åˆ° `recommended`ã€‚
2. æ¨¡æ€æ¡†ä¸‹æ‹‰é¡¹é»˜è®¤é€‰ä¸­ `recommended`ï¼ŒåŒæ—¶æŠŠ `outcomes` çš„ä¸‰è·¯è¯„åˆ†ä¸è§£é‡Šå±•ç¤ºåœ¨â€œé«˜çº§â€æŠ˜å é‡Œã€‚
3. ç”¨æˆ·ç‚¹â€œç¡®å®šâ€ï¼ŒæŠŠ `recommended` å†™å…¥ StepCardï¼š

   * `strategy.selected = "structure_match"`
   * `plan.slot.slot_id`ï¼šè‹¥æ˜¯ `LeafContext` â†’ è‡ªåŠ¨è¯†åˆ« `Like/Author/...`ï¼›è‹¥æ˜¯ `TextExact` â†’ å¸¦ `TextEqMode=Exact`
   * `config.prefer_context_for_leaf = true`ï¼ˆé»˜è®¤ï¼‰
   * `config.card_use_subtree_shape = true`ï¼ˆé»˜è®¤ï¼‰

---

## è¿™æ ·åšçš„å¥½å¤„

* **å®¢æˆ·é›¶é…ç½®**ï¼šç›´æ¥ç‚¹â€œç¡®å®šâ€å°±æœ‰æœ€ä¼˜æ–¹æ¡ˆã€‚
* **é²æ£’**ï¼šä¸‰è·¯è¯„åˆ†+é—¸é—¨+top-gapï¼Œé¿å…è¯¯é€‰ï¼›æ–‡æœ¬å¼ºç­‰å€¼åªåœ¨â€œå…³æ³¨/å·²å…³æ³¨â€è¿™ç±»ç¨³å®šè¯ä¸Šè‡ªåŠ¨å¼€å¯ã€‚
* **å¯è§£é‡Š**ï¼šæ¨¡æ€æ¡†å±•ç¤ºâ€œä¸ºä»€ä¹ˆé€‰å®ƒâ€çš„è§£é‡Šå­—æ®µï¼Œæ–¹ä¾¿è°ƒè¯•ä¸å›æº¯ã€‚
* **å¯æ‰©å±•**ï¼šæœªæ¥è‹¥æ–°å¢â€œæ ‡é¢˜åŒºæ§½ä½/è§†é¢‘è§’æ ‡æ§½ä½â€ï¼Œåªéœ€åœ¨å„è‡ª Matcher å†…è¡¥è¯„åˆ†ï¼Œé€‰æ‹©å™¨é€»è¾‘ä¸å˜ã€‚

---

**ç»“è®º**ï¼šå°±æŒ‰ä½ è¯´çš„åšï¼Œè€Œä¸”æˆ‘è¿™å¥—**é»˜è®¤å‚æ•°ä¸ä»£ç éª¨æ¶**å·²ç»å¸®ä½ æŠŠâ€œè¯„åˆ†â†’é—¸é—¨â†’æ‹©ä¼˜â†’å›å¡«æ¨¡æ€æ¡†/StepCardâ€çš„é—­ç¯æ‰“é€šäº†ã€‚ç›´æ¥æ¥å…¥ä½ ç°æœ‰çš„ `SubtreeMatcher/LeafContextMatcher/TextExactMatcher`ï¼Œå¾ˆå¿«å°±èƒ½è·‘é€šâ€œè‡ªåŠ¨é€‰æ‹©æ¨èæ¨¡å¼â€ã€‚
