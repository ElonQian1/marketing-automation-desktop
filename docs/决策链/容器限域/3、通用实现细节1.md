你上面说的 容器限域  是通用的代码实现细节了吗？
通用的实现细节应该是怎么样？

好的！下面给出“容器限域（container_gate）”的**通用后端 Rust 模块**落地实现，按文件拆分。
说明：

* 我把它放在你项目推荐的位置：`src-tauri/src/domain/structure_runtime_match/container_gate/`
* **第一行保留文件名+路径**（按你的规范）。
* 这是一个可复用的“通用限域器”，任何策略（Self-Anchor、结构匹配、V3 智能链、批量找同类…）都能先调用它拿到“容器根节点”，之后只在该子树内匹配即可。
* 其中 `UiTree` 是一个**最小必要接口**的 trait。你可以用当前项目已有的 `ports/xml_view` 适配实现（或在适配层 `impl UiTree for YourUiTree`）。

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/mod.rs
//! 容器限域：统一“找对盒子”的第 0 步剪枝。
//! 暴露 resolve_container_scope() 给外部使用。

pub mod types;
pub mod scoring;
pub mod resolver;
pub mod heuristics {
    pub mod scrollable;
    pub mod semantic;
    pub mod geometry;
    pub mod exclusion;
    pub mod popup;
    pub mod vote;
}
pub mod providers {
    pub mod xpath_hint;
    pub mod bounds_hint;
    pub mod ancestor_chain;
}

// 便捷 re-export
pub use resolver::resolve_container_scope;
pub use types::{ContainerHints, ContainerScope, ContainerConfig, ScopeProfile, UiTree, NodeId, Bounds};
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/types.rs
//! 公共类型与 UiTree 抽象（最小必要接口）

use serde::{Serialize, Deserialize};

pub type NodeId = u32;

#[derive(Debug, Clone, Copy, Serialize, Deserialize, Default)]
pub struct Bounds { pub l:i32, pub t:i32, pub r:i32, pub b:i32 }

impl Bounds {
    #[inline] pub fn width(&self)->i32 { (self.r - self.l).max(0) }
    #[inline] pub fn height(&self)->i32 { (self.b - self.t).max(0) }
    #[inline] pub fn area(&self)->i64 { (self.width() as i64) * (self.height() as i64) }
    #[inline] pub fn contains(&self, other: &Bounds)->bool {
        self.l <= other.l && self.t <= other.t && self.r >= other.r && self.b >= other.b
    }
    #[inline] pub fn iou(&self, other: &Bounds)->f32 {
        let x1 = self.l.max(other.l);
        let y1 = self.t.max(other.t);
        let x2 = self.r.min(other.r);
        let y2 = self.b.min(other.b);
        let inter_w = (x2 - x1).max(0);
        let inter_h = (y2 - y1).max(0);
        let inter = (inter_w as i64 * inter_h as i64) as f32;
        let union = (self.area() + other.area() - inter as i64).max(1) as f32;
        inter / union
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ContainerHints {
    pub container_xpath: Option<String>,   // 卡片已知的容器 XPath（强提示）
    pub bounds: Option<Bounds>,            // 卡片提供的容器屏幕区域（强/弱提示）
    pub ancestor_sign_chain: Vec<String>,  // 祖先签名链（弱提示，语义/类名片段等）
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContainerScope {
    pub root_id: NodeId,            // 选中的容器根节点
    pub reason: String,             // 说明为何选择它（便于审计）
    pub confidence: f32,            // 0..1
    pub profile_used: ScopeProfile, // Speed | Default | Robust
    pub trail: Vec<String>,         // 决策轨迹（若干候选与得分）
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ScopeProfile { Speed, Default, Robust }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContainerConfig {
    pub profile: ScopeProfile,
    pub max_fullscreen_ratio: f32,  // >0.95 视为整屏，默认排除（除非确认为正确）
    pub min_area_ratio: f32,        // <0.05 过小或过薄，默认排除
    pub prefer_scrollable: bool,    // 是否给滚动容器加权
    pub enable_popup_priority: bool,// Dialog/BottomSheet 优先
}

impl Default for ContainerConfig {
    fn default() -> Self {
        Self {
            profile: ScopeProfile::Default,
            max_fullscreen_ratio: 0.95,
            min_area_ratio: 0.05,
            prefer_scrollable: true,
            enable_popup_priority: true,
        }
    }
}

/// 候选项（启发式输出）
#[derive(Debug, Clone)]
pub struct HeuristicResult {
    pub node: NodeId,
    pub score: f32,     // 局部分（0..1或更高，聚合层会归一/加权）
    pub tag: &'static str, // 标注来源：scrollable/semantic/geometry/…
    pub note: String,   // 附加说明
}

/// 统一的 UI 树抽象（最小必要接口）
/// 你可以在适配层实现：`impl UiTree for YourUiTree { … }`
pub trait UiTree {
    fn root_id(&self) -> NodeId;
    fn parent(&self, id: NodeId) -> Option<NodeId>;
    fn children(&self, id: NodeId) -> Vec<NodeId>;

    fn class(&self, id: NodeId) -> &str;
    fn resource_id(&self, id: NodeId) -> Option<&str>;
    fn content_desc(&self, id: NodeId) -> Option<&str>;
    fn text(&self, id: NodeId) -> Option<&str>;

    fn bounds(&self, id: NodeId) -> Bounds;
    fn is_clickable(&self, id: NodeId) -> bool;
    fn is_scrollable(&self, id: NodeId) -> bool;
    fn is_dialog_like(&self, id: NodeId) -> bool; // Dialog/BottomSheet/Sheet 等

    fn node_by_xpath(&self, xpath: &str) -> Option<NodeId>;
    fn screen_size(&self) -> (i32, i32); // (w, h)

    /// 便利函数：锚点是否在某节点子树内（结构判断）
    fn is_ancestor_of(&self, ancestor: NodeId, mut node: NodeId) -> bool {
        while let Some(p) = self.parent(node) {
            if p == ancestor { return true; }
            node = p;
        }
        false
    }
    /// 便利函数：沿祖先向上迭代（含自己，不含 root 之后）
    fn walk_ancestors(&self, mut node: NodeId) -> Vec<NodeId> {
        let mut v = vec![node];
        while let Some(p) = self.parent(node) {
            v.push(p);
            node = p;
        }
        v
    }
    /// 便利：节点面积占屏占比
    fn area_ratio(&self, id: NodeId) -> f32 {
        let (w,h) = self.screen_size();
        let vp = Bounds{ l:0, t:0, r:w, b:h };
        self.bounds(id).area() as f32 / (vp.area().max(1) as f32)
    }
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/scoring.rs
//! 最终打分调权与过滤

use super::types::{UiTree, NodeId, HeuristicResult, ContainerConfig};

pub fn adjust_and_penalize<T: UiTree>(
    tree: &T,
    cand: &mut Vec<HeuristicResult>,
    cfg: &ContainerConfig,
) {
    // 偏好：滚动容器加权
    if cfg.prefer_scrollable {
        for c in cand.iter_mut() {
            if tree.is_scrollable(c.node) { c.score += 0.20; }
        }
    }

    // 类似 Dialog/Sheet 给点加权（更可能是“当前业务面板”）
    for c in cand.iter_mut() {
        if tree.is_dialog_like(c.node) { c.score += 0.15; }
    }

    // 面积极端的惩罚（整屏 or 过薄/过小）
    for c in cand.iter_mut() {
        let ar = tree.area_ratio(c.node);
        if ar > cfg.max_fullscreen_ratio { c.score -= 0.50; } // 尽量避免整屏
        if ar < cfg.min_area_ratio { c.score -= 0.30; }       // 排除薄壳
    }
}

/// 决定性过滤：容器必须包含锚点（结构意义上的祖先关系）
pub fn must_contain_anchor<T: UiTree>(tree: &T, anchor: NodeId, cand: &mut Vec<HeuristicResult>) {
    cand.retain(|c| tree.is_ancestor_of(c.node, anchor));
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/heuristics/scrollable.rs
//! 可滚容器启发式：沿祖先寻找最近的 Scroll 容器

use super::super::types::{UiTree, NodeId, HeuristicResult};

const SCROLL_CLASSES: &[&str] = &[
    "RecyclerView","ListView","ScrollView","NestedScrollView","ViewPager","ViewPager2"
];

pub fn propose<T: UiTree>(tree: &T, anchor: NodeId) -> Vec<HeuristicResult> {
    let mut out = Vec::new();
    for n in tree.walk_ancestors(anchor) {
        let class = tree.class(n);
        let is_scroll = tree.is_scrollable(n) || SCROLL_CLASSES.iter().any(|k| class.contains(k));
        if is_scroll {
            out.push(HeuristicResult{
                node: n,
                score: 0.90,
                tag: "scrollable",
                note: format!("scrollable ancestor: {}", class),
            });
            break; // 最近的即可
        }
    }
    out
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/heuristics/semantic.rs
//! 语义面板启发式：*_container/*_panel/*_content/*_root 等

use super::super::types::{UiTree, NodeId, HeuristicResult};

const SEM_KEYS: &[&str] = &["container","panel","content","root","sheet","dialog"];

pub fn propose<T: UiTree>(tree: &T, anchor: NodeId) -> Vec<HeuristicResult> {
    let mut out = Vec::new();
    for n in tree.walk_ancestors(anchor) {
        let rid = tree.resource_id(n).unwrap_or_default();
        let desc = tree.content_desc(n).unwrap_or_default();
        let class = tree.class(n);
        let hit = SEM_KEYS.iter().any(|k| rid.contains(k) || desc.contains(k));
        if hit {
            out.push(HeuristicResult{
                node: n,
                score: 0.80,
                tag: "semantic",
                note: format!("semantic container: rid='{}' class='{}'", rid, class),
            });
            // 不 break：可能更近处还有更合适的
        }
    }
    out
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/heuristics/geometry.rs
//! 几何启发式：面积/包含关系/孩子数等

use super::super::types::{UiTree, NodeId, HeuristicResult};

pub fn propose<T: UiTree>(tree: &T, anchor: NodeId) -> Vec<HeuristicResult> {
    let mut out = Vec::new();
    let a_bounds = tree.bounds(anchor);
    for n in tree.walk_ancestors(anchor) {
        let b = tree.bounds(n);
        if !b.contains(&a_bounds) { continue; }
        let ar = tree.area_ratio(n);
        // 经验：容器面积在 [5%, 95%] 区间更合理
        if ar >= 0.05 && ar <= 0.95 {
            let children = tree.children(n).len();
            if children >= 2 {
                out.push(HeuristicResult{
                    node: n,
                    score: 0.60,
                    tag: "geometry",
                    note: format!("geom ok (area={:.2}%, children={})", ar*100.0, children),
                });
            }
        }
    }
    out
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/heuristics/exclusion.rs
//! 排除规则：Toolbar/TabBar/整屏/薄壳等

use super::super::types::{UiTree, NodeId};

const AVOID_CLASSES: &[&str] = &[
    "Toolbar","ActionBar","TabLayout","BottomNavigationView",
];

pub fn should_exclude<T: UiTree>(tree: &T, cfg_max_fullscreen_ratio: f32, id: NodeId) -> bool {
    let class = tree.class(id);
    if AVOID_CLASSES.iter().any(|k| class.contains(k)) { return true; }

    // 过薄/过小：
    let ar = tree.area_ratio(id);
    if ar < 0.02 { return true; }

    // 整屏（强排除在大多数场景；若确实需要，将由上层兜底处理）
    if ar > cfg_max_fullscreen_ratio { return true; }

    // 只有一个孩子且不可滚（常见包裹壳）
    if !tree.is_scrollable(id) && tree.children(id).len() <= 1 { return true; }

    false
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/heuristics/popup.rs
//! 弹层优先：Dialog/BottomSheet 命中时优先提名

use super::super::types::{UiTree, NodeId, HeuristicResult};

pub fn propose<T: UiTree>(tree: &T, anchor: NodeId) -> Vec<HeuristicResult> {
    for n in tree.walk_ancestors(anchor) {
        if tree.is_dialog_like(n) {
            return vec![HeuristicResult{
                node: n,
                score: 1.00,
                tag: "popup",
                note: format!("dialog-like container: {}", tree.class(n)),
            }];
        }
    }
    vec![]
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/heuristics/vote.rs
//! 候选聚合与排序

use std::collections::HashMap;
use super::super::types::{HeuristicResult, UiTree, NodeId, ContainerConfig};
use super::super::scoring;

pub struct Picked {
    pub ranked: Vec<(NodeId, f32, String)>, // (id, score, merged_note)
}

pub fn aggregate_and_pick<T: UiTree>(
    tree: &T,
    mut all: Vec<HeuristicResult>,
    anchor: NodeId,
    cfg: &ContainerConfig,
) -> Picked {
    // 先做必要调权与“必须包含锚点”的过滤
    scoring::adjust_and_penalize(tree, &mut all, cfg);
    scoring::must_contain_anchor(tree, anchor, &mut all);

    // 聚合：同一 NodeId 的分数相加，note 合并
    let mut acc: HashMap<NodeId, (f32, Vec<String>)> = HashMap::new();
    for h in all {
        let e = acc.entry(h.node).or_insert((0.0, Vec::new()));
        e.0 += h.score;
        e.1.push(format!("[{}] {}", h.tag, h.note));
    }

    let mut ranked: Vec<(NodeId, f32, String)> = acc.into_iter()
        .map(|(id, (s, notes))| (id, s, notes.join(" | ")))
        .collect();

    // 排序
    ranked.sort_by(|a,b| b.1.partial_cmp(&a.1).unwrap());

    Picked { ranked }
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/providers/xpath_hint.rs
//! 强提示：container_xpath 直接定位

use super::super::types::{UiTree, NodeId, ContainerHints, HeuristicResult};

pub fn propose<T: UiTree>(tree: &T, hints: &ContainerHints, anchor: NodeId) -> Vec<HeuristicResult> {
    let Some(xpath) = &hints.container_xpath else { return vec![]; };
    if let Some(n) = tree.node_by_xpath(xpath) {
        // 要求至少是锚点祖先
        if tree.is_ancestor_of(n, anchor) {
            return vec![HeuristicResult{
                node: n,
                score: 2.0, // 强提示高权重
                tag: "hint_xpath",
                note: format!("by container_xpath {}", xpath),
            }];
        }
    }
    vec![]
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/providers/bounds_hint.rs
//! 强/弱提示：bounds 限定区域（优先在祖先中找与 bounds 高 IoU 的节点）

use super::super::types::{UiTree, NodeId, ContainerHints, HeuristicResult, Bounds};

pub fn propose<T: UiTree>(tree: &T, hints: &ContainerHints, anchor: NodeId) -> Vec<HeuristicResult> {
    let Some(hb) = hints.bounds else { return vec![]; };

    let mut best: Option<(NodeId, f32)> = None;
    for n in tree.walk_ancestors(anchor) {
        let iou = tree.bounds(n).iou(&hb);
        let score = (iou * 1.5).min(1.2); // IoU 越高越好
        if best.map(|(_,s)| score>s).unwrap_or(true) {
            best = Some((n, score));
        }
    }
    if let Some((node, score)) = best {
        return vec![HeuristicResult{
            node,
            score,
            tag: "hint_bounds",
            note: format!("best IoU with hinted bounds: {:.2}", score),
        }];
    }
    vec![]
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/providers/ancestor_chain.rs
//! 弱提示：祖先签名链（字符串片段，如类名/语义片段）
//! 简化实现：若某祖先的 class 或 resource_id 含任一签名片段，则提名，链越靠上分越低（衰减）

use super::super::types::{UiTree, NodeId, ContainerHints, HeuristicResult};

pub fn propose<T: UiTree>(tree: &T, hints: &ContainerHints, anchor: NodeId) -> Vec<HeuristicResult> {
    if hints.ancestor_sign_chain.is_empty() { return vec![]; }
    let mut out = Vec::new();
    let chain = tree.walk_ancestors(anchor);
    for (depth, n) in chain.iter().enumerate() {
        let class = tree.class(*n);
        let rid = tree.resource_id(*n).unwrap_or_default();
        let hit = hints.ancestor_sign_chain.iter().any(|sig| {
            class.contains(sig) || rid.contains(sig)
        });
        if hit {
            // 越靠上（depth 大）分越轻
            let base = 0.75f32 * (1.0 / (1.0 + depth as f32*0.25));
            out.push(HeuristicResult{
                node: *n,
                score: base,
                tag: "hint_ancestor",
                note: format!("hit ancestor sig at depth {} (class='{}')", depth, class),
            });
        }
    }
    out
}
```

---

```rust
src-tauri/src/domain/structure_runtime_match/container_gate/resolver.rs
//! 统一入口：resolve_container_scope()

use anyhow::{Result, anyhow};
use super::types::{UiTree, NodeId, ContainerHints, ContainerScope, ContainerConfig, ScopeProfile, HeuristicResult};
use super::heuristics::{scrollable, semantic, geometry, exclusion, popup, vote};
use super::providers::{xpath_hint, bounds_hint, ancestor_chain};

pub fn resolve_container_scope<T: UiTree>(
    tree: &T,
    anchor: NodeId,
    hints: &ContainerHints,
    cfg: &ContainerConfig,
) -> Result<ContainerScope> {

    let mut cand: Vec<HeuristicResult> = Vec::new();
    let mut trail: Vec<String> = Vec::new();

    // 0) 强提示（优先）
    cand.extend(xpath_hint::propose(tree, hints, anchor));
    cand.extend(bounds_hint::propose(tree, hints, anchor));
    cand.extend(ancestor_chain::propose(tree, hints, anchor));

    // 1) 弹层优先（如开启）
    if cfg.enable_popup_priority {
        cand.extend(popup::propose(tree, anchor));
    }

    // 2) 常规启发式
    cand.extend(scrollable::propose(tree, anchor));
    cand.extend(semantic::propose(tree, anchor));
    cand.extend(geometry::propose(tree, anchor));

    // 3) 排除明显不合格的
    cand.retain(|c| !exclusion::should_exclude(tree, cfg.max_fullscreen_ratio, c.node));

    // 4) 聚合 + 排序
    let picked = vote::aggregate_and_pick(tree, cand, anchor, cfg);

    // 5) 择优，必要时兜底
    let chosen = picked.ranked.get(0).cloned().or_else(|| {
        // 兜底：最近滚动祖先 or 根内容区
        if let Some(n) = scrollable::propose(tree, anchor).get(0).map(|h| (h.node, h.score, h.note.clone())) {
            Some((n.0, n.1, n.2))
        } else {
            Some((tree.root_id(), 0.1, "fallback_root".into()))
        }
    }).ok_or_else(|| anyhow!("no container candidate"))?;

    // 6) 审计轨迹（前 5 名）
    for (id, s, note) in picked.ranked.iter().take(5) {
        trail.push(format!("#cand id={} score={:.2} {}", id, s, note));
    }

    Ok(ContainerScope{
        root_id: chosen.0,
        reason: format!("picked score={:.2} {}", chosen.1, chosen.2),
        confidence: (chosen.1/2.0).clamp(0.0, 1.0), // 简单归一
        profile_used: cfg.profile,
        trail,
    })
}
```

---

## 怎么用（示例）

* 在你的任意策略代码里（Self-Anchor / 结构匹配 / V3 引擎），先调用：

```rust
// 示例：先限域，再在 scope.root_id 子树中做后续匹配
use crate::domain::structure_runtime_match::container_gate::{
    resolve_container_scope, ContainerConfig, ContainerHints, UiTree
};

let cfg = ContainerConfig::default();
let hints = ContainerHints{
    container_xpath: step_card.container_xpath.clone(),
    bounds: step_card.bounds.clone(),
    ancestor_sign_chain: step_card.ancestor_sign_chain.clone(),
};

let scope = resolve_container_scope(&ui_tree, anchor_id, &hints, &cfg)?;
// 之后只在 scope.root_id 子树内收集候选与匹配
```

---

## 集成说明

1. **适配 UiTree**
   在你的 `ports/xml_view` 或适配层，实现上面 `UiTree` trait 所需的方法（大多是从现有节点结构读取 class/resource-id/bounds 等）。

2. **统一缓存**
   强烈建议用 `snapshot_hash + anchor_id + profile` 做容器结果缓存，Self-Anchor/结构匹配/V3 共用，避免重复计算。

3. **可调权重**

* 通过 `ContainerConfig` 切 Speed/Default/Robust（扩展：你可把 profile 影响的权重下放到 `scoring.rs`）。
* 如果需要更细粒度的策略，你可以在 `heuristics/vote.rs` 里对 `tag` 分别设定权重映射。

---

需要我再加一组**最小单元测试**（基于你上传的 XML 做几个断言）或给一个**适配 UiTree 的模板**吗？我可以继续补上。
