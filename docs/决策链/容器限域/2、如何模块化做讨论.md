容器限域 应该是后端 rust 代码的 一个通用模块是吧？ 

而不是前端的。

如果是， 我要如何单独做好这个模块的通用性， 给不同功能模块随时调用？

如何保持 子文件夹/子文件 模块化 的做好这件事

怎么感觉容器限域 本身就是 一种 结构匹配， 选找到某种的结构的意思？


对，你理解得对：**“容器限域”应做成后端 Rust 的通用模块**，任何功能（静态结构匹配、Self-Anchor、V3 智能链、批量找同类…）都可以随时调用。它的职责是——**给“要找东西”的算法先圈定一块合适的大盒子**（容器/面板），只在这块里搜索，变快也更稳。

下面给你一套能直接落地的模块化方案（含目录结构、Trait 设计、API、集成点），以及它和“结构匹配”的关系。

---

# 要做成“通用容器限域模块”，怎么设计？

## 目录与分层（贴合你现有 domain 分层）

建议直接放进你已有的分层里（和你记忆里的一致）：

```
src-tauri/
  src/
    domain/
      structure_runtime_match/
        container_gate/          ← 本模块（通用）
          mod.rs
          types.rs               ← 公共类型（Scope/Hints/Config）
          resolver.rs            ← 入口：resolve()
          scoring.rs             ← 打分与权重
          heuristics/            ← 各种启发式“提名器”
            scrollable.rs        ← 滚动容器识别
            semantic.rs          ← 业务面板（*_container/*_panel/*_content）
            geometry.rs          ← 几何/面积阈值过滤
            exclusion.rs         ← 顶栏/底栏/整屏等排除
            popup.rs             ← dialog/sheet 弹层优先
            vote.rs              ← 多启发式投票融合
          providers/             ← 从卡片线索转化为“强提示”
            xpath_hint.rs        ← container_xpath 强定位（有就用）
            bounds_hint.rs       ← bounds 强/弱定位
            ancestor_chain.rs    ← 祖先签名链→容器候选
          tests/
            sample_xml_*.rs
```

> 如果后续希望更独立，也可以抽成 `domain/container_scope/` 模块，但先放在 `structure_runtime_match` 下最省改动，并能被别的策略直接复用。

---

## 公共类型（types.rs）

```rust
// src-tauri/src/domain/structure_runtime_match/container_gate/types.rs
use serde::{Serialize, Deserialize};

pub type NodeId = u32;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Bounds { pub l:i32, pub t:i32, pub r:i32, pub b:i32 }

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ContainerHints {
    pub container_xpath: Option<String>,   // 卡片直接给的容器 XPath
    pub bounds: Option<Bounds>,            // 卡片或前端给的屏幕区域
    pub ancestor_sign_chain: Vec<String>,  // 祖先签名链（3~5 层）
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContainerScope {
    pub root_id: NodeId,                   // 选中的“容器根”节点
    pub reason: String,                    // 为审计而留，说明为什么选它
    pub confidence: f32,                   // 0~1
    pub profile_used: ScopeProfile,        // Speed | Default | Robust
    pub trail: Vec<String>,                // 决策轨迹（可选，便于日志）
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ScopeProfile { Speed, Default, Robust }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContainerConfig {
    pub profile: ScopeProfile,
    pub max_fullscreen_ratio: f32,  // >0.95 视为整屏，默认排除
    pub min_area_ratio: f32,        // 太薄/太小的壳排除
    pub prefer_scrollable: bool,    // 优先滚动容器
    pub enable_popup_priority: bool,// Dialog/BottomSheet 优先
}
```

---

## 统一入口 API（resolver.rs）

```rust
// src-tauri/src/domain/structure_runtime_match/container_gate/resolver.rs
use super::types::*;
use crate::domain::ports::xml_view::{UiTree, NodeRef}; // 你已有的视图接口

pub fn resolve_container_scope(
    tree: &UiTree,
    anchor: NodeId,              // “被点元素”或当前匹配锚点
    hints: &ContainerHints,      // 卡片线索（可空）
    cfg: &ContainerConfig,
) -> anyhow::Result<ContainerScope> {
    // 1) 强提示：container_xpath / bounds 命中直接落位（带合法性校验）
    // 2) 弹层优先：dialog/sheet/popup 面板若覆盖 anchor，直接当容器
    // 3) 滚动祖先：自下而上找最近的 RecyclerView/ScrollView/…（可配）
    // 4) 语义面板：resource-id/name 命中 *_container/*_panel/*_content
    // 5) 几何过滤：排除整屏/过薄/只有一个孩子的空壳
    // 6) 多候选投票：scoring.rs 融合，取分最高者
    // 7) 兜底：Activity/Fragment 内容根（排除工具栏/底栏）

    // 返回 ContainerScope { root_id, reason, confidence, profile_used, trail }
}
```

**调用很简单：**

```rust
let scope = resolve_container_scope(&tree, anchor_id, &hints, &cfg)?;
let only_in_container = tree.iter_subtree(scope.root_id); // 之后的匹配只在这里
```

> 你可以在任意策略前统一先调用它，然后把 `scope.root_id` 传给结构匹配 / Self-Anchor / 智能链，作为 **pre 限域**；匹配完还可 `post` 校验候选确实落在该容器里。

---

## Heuristics（启发式）是可插拔的

把每个“识别线索”做成小插件，统一 Trait，便于扩展：

```rust
pub trait ContainerHeuristic: Send + Sync {
    fn propose(&self, tree:&UiTree, anchor:NodeId, hints:&ContainerHints)
        -> Vec<(NodeId, f32, String)>; // (候选节点, 局部分, 说明)
}
```

* `scrollable.rs`：沿祖先链找 `RecyclerView/ListView/ScrollView/NestedScrollView/ViewPager2…`；
* `semantic.rs`：匹配 id/name 里的 `*_container/*_panel/*_content/*_root/*_sheet/*_dialog`；
* `geometry.rs`：面积比例阈、包裹程度（包含 anchor）、子节点数量；
* `exclusion.rs`：排除 Toolbar/TabBar/整屏、只剩一个孩子的“纯壳”；
* `popup.rs`：存在 Dialog/BottomSheet 顶层时优先；
* `vote.rs`：把多启发式产出的候选**聚合打分**（支持 Speed/Default/Robust 三档权重）。

这样别的功能要加新线索（比如“分段面板”、“卡片栅格”）只需加一个文件实现 Trait 即可。

---

## 打分与权重（scoring.rs）

沿用你项目既有口径（你之前给过权重偏好）：

* id/desc ≈ **0.85**
* text ≈ **0.70**
* class ≈ **0.30**
* 容器限定（是滚动祖先/语义面板）**+0.30**
* 父可点 **+0.20**
* 局部索引 −0.15（配轻校验 +0.10）
* 全局索引 −0.60
* 约束：**唯一性==1** 或 **top-gap ≥ 0.15**；`min_conf ≥ 0.70`；避免整屏节点

> `ScopeProfile::Speed|Default|Robust` 通过不同权重/早停规则实现“快/稳”的切换。

---

## 缓存与复用（强烈建议）

* 缓存键：`snapshot_hash + anchor_id + profile`
* 值：`ContainerScope` + 决策轨迹（方便在日志里回放）
* 端到端：页面分析视图、结构匹配、Self-Anchor、V3 引擎**共用同一缓存**，避免重复算。

---

## 与三条执行链的集成顺序

1. **Self-Anchor / 智能单步 / 智能自动链**

   * 首行：`scope = resolve_container_scope(...)`
   * 之后所有候选收集与匹配，都在 `scope.root_id` 子树里进行（pre 限域）。
2. **静态策略—结构匹配**

   * 卡片里没有结构参数时：先 `resolve_container_scope`，然后**从快照 + 选中节点**推导 StructuralMatchPlan；
   * 有参数时：也先限域，可明显降复杂度。
3. **批量找同类**

   * 先限域，再“同类”扫描（按 class/id/shape），避免把全页工具栏/底栏误入。

---

# 容器限域是不是“结构匹配”？

**算是“浅层结构匹配”的一个子问题**。

* 目标不同：

  * **容器限域**只解决“**在哪一块里找**”的问题（确定区域/根）。
  * **结构匹配**解决“**具体是谁**”的问题（定位唯一节点）。
* 手段相似：两者都会用到 class、祖先/子树形状、几何、语义等**结构线索**。
* 实操关系：**先容器，后匹配**。容器选对了，后面的精确匹配就又快又准。

> 可以把容器限域看成“结构匹配的第 0 步”：先给搜索空间做一个聪明的剪枝。

---

# 最小可用示例（你可以马上接到现有代码）

```rust
// 1) 组装 cfg + hints（卡片可直接提供）：
let cfg = ContainerConfig {
    profile: ScopeProfile::Default,
    max_fullscreen_ratio: 0.95,
    min_area_ratio: 0.05,
    prefer_scrollable: true,
    enable_popup_priority: true,
};

let hints = ContainerHints {
    container_xpath: step_card.container_xpath.clone(),
    bounds: step_card.bounds.clone(),
    ancestor_sign_chain: step_card.ancestor_sign_chain.clone(),
};

// 2) 解析 dump → UiTree …（你已有）
// 3) 解析卡片选中元素 → anchor_id …（你已有）

// 4) 统一先限域：
let scope = resolve_container_scope(&tree, anchor_id, &hints, &cfg)?;

// 5) 把 scope.root_id 传给后续所有策略：
let subtree = tree.iter_subtree(scope.root_id);
// … 结构匹配 / Self-Anchor / V3 执行都在 subtree 中工作
```

---

# 小结

* **是后端的通用模块**：放在 `domain/structure_runtime_match/container_gate`，暴露一个 `resolve_container_scope()` 即可，所有功能统一先用它“圈盒子”。
* **做成可插拔**：不同启发式（滚动容器、语义面板、几何过滤、弹层优先…）用 Trait 拆分，`vote.rs` 融合打分。
* **和结构匹配的关系**：它是“第 0 步”的**浅层结构匹配**，用途是**裁剪搜索空间**。
* **工程收益**：速度更快、唯一性更高、日志更可审计，且方便后续扩展与 A/B 权重调参。

需要我把 `mod.rs / types.rs / resolver.rs` 的起始骨架代码写出来吗？我可以按上面的接口直接给你一版可编译的 stub。
