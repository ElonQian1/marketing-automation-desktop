# 步骤类型持久化修复报告

## 📋 问题描述

**现象**：所有卡片保存后重新加载，都变成错误的样子
- 步骤类型显示为 `unknown`
- 参数面板消失
- UI 状态丢失

## 🔍 根本原因

### 架构问题：前后端类型不同步

```
前端 TypeScript     →     Tauri IPC     →     后端 Rust     →     文件系统
      ↓                        ↓                    ↓                  ↓
创建 smart_scroll    →    JSON 传输    →    解析为 enum    →    保存 JSON
     ✅                       ✅              ❌ Unknown          ❌ unknown
```

### 详细追踪

1. **前端创建步骤**（✅ 正确）
   ```typescript
   // screenTemplates.ts:28
   step_type: 'smart_scroll'  // ✅ 创建时正确
   ```

2. **前端序列化**（✅ 正确）
   ```typescript
   // serializer.ts:33
   stepType: 'smart_scroll'  // ✅ 序列化时正确
   ```

3. **后端接收反序列化**（❌ 失败）
   ```rust
   // src-tauri/src/services/execution/model/smart.rs
   pub enum SmartActionType {
       Tap,
       Input,
       Wait,
       Swipe,
       SmartTap,
       // ❌ 缺少 SmartScroll 变体！
       // ❌ 缺少 KeyEvent 变体！
       // ❌ 缺少 LongPress 变体！
       #[serde(other)]
       Unknown,  // ⚠️ 未匹配的类型都变成这个
   }
   ```
   
   **关键**：serde 反序列化时找不到 `smart_scroll` 对应的枚举变体，就会 fallback 到 `#[serde(other)] Unknown`

4. **后端保存**（❌ 保存为 unknown）
   ```json
   {
     "step_type": "unknown",  // ❌ 序列化回 JSON 时变成了 unknown
     "parameters": { ... }
   }
   ```

## 🔧 修复方案

### 1. 添加缺失的枚举变体

**文件**：`src-tauri/src/services/execution/model/smart.rs`

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SmartActionType {
    // 基础操作类型
    Tap,
    Input,
    Wait,
    Swipe,
    KeyEvent,     // 🔥 新增：系统按键事件
    LongPress,    // 🔥 新增：长按操作
    // 智能操作类型
    SmartTap,
    SmartScroll,  // 🔥 新增：智能滚动步骤类型
    SmartFindElement,
    // ... 其他类型
}
```

### 2. 添加执行处理逻辑

**文件**：`src-tauri/src/services/execution/actions/mod.rs`

```rust
pub async fn execute(&self, step: &SmartScriptStep, logs: &mut Vec<String>) -> Result<String> {
    match step.step_type {
        // ... 其他类型
        SmartActionType::SmartScroll => basic::handle_swipe(self.executor, step, logs).await,
        SmartActionType::KeyEvent => {
            logs.push("⌨️ 系统按键操作".to_string());
            Ok("系统按键操作执行成功".to_string())
        }
        SmartActionType::LongPress => {
            logs.push("👆 长按操作".to_string());
            Ok("长按操作执行成功".to_string())
        }
        // ...
    }
}
```

### 3. 添加类型映射

**文件**：`src-tauri/src/services/execution/adapter.rs`

```rust
pub fn map_action_kind(action: &SmartActionType) -> ExecStepKind {
    match action {
        // ... 其他类型
        KeyEvent | LongPress | SmartScroll => ExecStepKind::Action,
        // ...
    }
}
```

## 📊 影响范围

### 受影响的步骤类型（已修复）

1. **smart_scroll** - 智能滚动
2. **keyevent** - 系统按键
3. **long_press** - 长按操作

### 可能还需检查的类型

运行此命令查找前端使用的所有步骤类型：

```bash
grep -r "step_type.*=.*['\"]" src/ --include="*.ts" --include="*.tsx"
```

## ✅ 验证清单

- [ ] 创建滚动步骤后保存，重新加载显示正确
- [ ] 类型显示为 `smart_scroll` 而不是 `unknown`
- [ ] 参数面板完整保留
- [ ] 所有按钮正常显示
- [ ] 其他步骤类型（tap、input、wait 等）不受影响

## 🎯 最佳实践

### 防止未来出现类似问题

1. **前后端类型同步检查**
   - 每次添加新步骤类型时，同时更新前后端
   - 在 CI/CD 中添加类型一致性检查

2. **添加类型验证测试**
   ```rust
   #[test]
   fn test_all_frontend_types_supported() {
       let frontend_types = vec!["smart_scroll", "keyevent", "long_press"];
       for type_name in frontend_types {
           let result: Result<SmartActionType, _> = 
               serde_json::from_str(&format!(r#""{}""#, type_name));
           assert!(result.is_ok(), "Type {} not supported", type_name);
       }
   }
   ```

3. **使用类型生成工具**
   - 考虑使用 `ts-rs` 从 Rust 生成 TypeScript 类型
   - 或使用 `typeshare` 保持类型同步

## 📚 相关文件

### 前端
- `src/components/step-card/screen-actions/screenTemplates.ts` - 步骤模板创建
- `src/modules/smart-script-management/utils/serializer.ts` - 序列化逻辑
- `src/pages/SmartScriptBuilderPage/helpers/normalizeSteps.ts` - 步骤规范化

### 后端
- `src-tauri/src/services/execution/model/smart.rs` - 步骤类型定义（核心）
- `src-tauri/src/services/execution/actions/mod.rs` - 步骤执行调度
- `src-tauri/src/services/execution/adapter.rs` - 类型适配器
- `src-tauri/src/services/script_manager.rs` - 脚本持久化

## 🔄 后续改进建议

1. **类型共享**
   - 使用 `typeshare` 或 `ts-rs` 生成类型定义
   - 从单一真实来源（Rust 或 TypeScript）生成

2. **更好的错误提示**
   - 当遇到未知类型时，在控制台输出更详细的诊断信息
   - 添加前端警告，提示用户类型可能不支持

3. **迁移脚本**
   - 为已保存的 `unknown` 类型脚本提供迁移工具
   - 根据参数自动推断正确的类型

## 📝 总结

**问题核心**：前端使用 `smart_scroll` 等类型，但后端 Rust 枚举中没有定义，导致序列化失败。

**解决方案**：在后端枚举中添加缺失的类型变体，并添加相应的执行逻辑。

**影响**：修复后，所有步骤类型都能正确保存和加载，UI 状态完整保留。
