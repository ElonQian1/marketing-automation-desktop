# 小红书关注脚本核心逻辑提取文档

## 📋 项目概述

本文档提取了小红书关注脚本的核心逻辑，重点关注通讯录好友自动关注的具体实现，用于集成到GUI桌面程序中。

### 🎯 核心功能
- 小红书应用状态检查
- 智能页面识别与导航
- 通讯录好友批量自动关注
- UI自动化操作与错误处理

---

## 🏗️ 技术架构

### 核心组件

#### 1. XiaohongshuAutomator 主控制器
```rust
pub struct XiaohongshuAutomator {
    device_id: String,    // Android设备ID
    adb_path: String,     // ADB命令路径
}
```

#### 2. 数据结构定义
```rust
// 应用状态检查结果
pub struct AppStatusResult {
    pub app_installed: bool,
    pub app_running: bool,
    pub message: String,
}

// 导航操作结果
pub struct NavigationResult {
    pub success: bool,
    pub message: String,
}

// 关注操作配置
pub struct XiaohongshuFollowOptions {
    pub max_pages: Option<usize>,           // 最大处理页数
    pub follow_interval: Option<u64>,       // 关注间隔(毫秒)
    pub skip_existing: Option<bool>,        // 跳过已关注用户
    pub return_to_home: Option<bool>,       // 完成后返回主页
}

// 关注操作结果
pub struct XiaohongshuFollowResult {
    pub success: bool,
    pub total_followed: usize,
    pub pages_processed: usize,
    pub duration: u64,
    pub details: Vec<FollowDetail>,
    pub message: String,
}

// 页面状态枚举
pub enum PageState {
    Unknown,         // 未知页面
    MainPage,        // 小红书主页
    SidebarOpen,     // 侧边栏已打开
    DiscoverFriends, // 发现好友页面
    ContactsList,    // 通讯录列表页面
    UserProfile,     // 用户资料页面
}
```

---

## 🔧 核心API接口

### 1. 应用状态检查
```rust
/// 检查小红书应用状态
pub async fn check_app_status(&self) -> Result<AppStatusResult> {
    info!("检查小红书应用状态...");
    
    let app_installed = self.is_app_installed("com.xingin.xhs").await?;
    let app_running = if app_installed {
        self.is_app_running("com.xingin.xhs").await?
    } else {
        false
    };
    
    let message = match (app_installed, app_running) {
        (false, _) => "小红书应用未安装".to_string(),
        (true, false) => "小红书应用已安装但未运行".to_string(),
        (true, true) => "小红书应用已安装且正在运行".to_string(),
    };
    
    Ok(AppStatusResult {
        app_installed,
        app_running,
        message,
    })
}
```

### 2. 智能页面识别
```rust
/// 智能页面识别
pub async fn recognize_current_page(&self) -> Result<PageRecognitionResult> {
    info!("🔍 开始识别当前页面状态...");
    
    let ui_dump = self.get_ui_dump().await?;
    let ui_elements = self.parse_ui_elements(&ui_dump).await?;
    
    // 分析页面特征
    let (page_state, confidence, key_elements) = self.analyze_page_state(&ui_dump, &ui_elements).await?;
    
    Ok(PageRecognitionResult {
        current_state: page_state,
        confidence,
        key_elements,
        ui_elements,
        message: format!("识别到页面: {:?}, 信心度: {:.2}", page_state, confidence),
    })
}
```

### 3. 导航到通讯录页面
```rust
/// 导航到小红书通讯录页面（基于手动验证的流程）
pub async fn navigate_to_contacts(&self) -> Result<NavigationResult> {
    info!("🧭 基于手动验证流程导航到小红书通讯录页面...");
    
    // 步骤1: 确保应用运行状态
    let app_status = self.check_app_status().await?;
    if !app_status.app_installed {
        return Ok(NavigationResult {
            success: false,
            message: "小红书应用未安装".to_string(),
        });
    }
    
    if !app_status.app_running {
        info!("启动小红书应用...");
        self.open_xiaohongshu_app().await?;
        sleep(Duration::from_secs(3)).await;
    }
    
    // 步骤2: 点击头像打开侧边栏（坐标: 60, 100）
    info!("📱 步骤1: 点击头像打开侧边栏");
    self.adb_tap(60, 100).await?;
    sleep(Duration::from_secs(2)).await;
    
    // 步骤3: 验证侧边栏状态并点击发现好友
    let sidebar_check = self.recognize_current_page().await?;
    if matches!(sidebar_check.current_state, PageState::SidebarOpen) {
        info!("👥 步骤2: 点击发现好友选项");
        let discover_coords = self.find_discover_friends_coords().await?;
        self.adb_tap(discover_coords.0, discover_coords.1).await?;
        sleep(Duration::from_secs(2)).await;
        
        // 步骤4: 点击通讯录朋友选项
        info!("📋 步骤3: 点击通讯录朋友选项");
        let contacts_coords = self.find_contacts_option_coords().await?;
        self.adb_tap(contacts_coords.0, contacts_coords.1).await?;
        sleep(Duration::from_secs(3)).await;
        
        Ok(NavigationResult {
            success: true,
            message: "成功导航到通讯录页面".to_string(),
        })
    } else {
        Ok(NavigationResult {
            success: false,
            message: "侧边栏打开失败".to_string(),
        })
    }
}
```

### 4. 批量自动关注
```rust
/// 执行小红书自动关注
pub async fn auto_follow(&self, options: Option<XiaohongshuFollowOptions>) -> Result<XiaohongshuFollowResult> {
    let start_time = std::time::Instant::now();
    info!("开始小红书自动关注流程");
    
    let opts = options.unwrap_or_default();
    let max_pages = opts.max_pages.unwrap_or(5);
    let follow_interval = opts.follow_interval.unwrap_or(2000);
    let skip_existing = opts.skip_existing.unwrap_or(true);
    
    let mut total_followed = 0;
    let mut pages_processed = 0;
    let mut details = Vec::new();
    
    // 确保在通讯录页面
    match self.navigate_to_contacts().await? {
        result if !result.success => {
            return Ok(XiaohongshuFollowResult {
                success: false,
                total_followed: 0,
                pages_processed: 0,
                duration: start_time.elapsed().as_secs(),
                details: vec![],
                message: "无法导航到通讯录页面".to_string(),
            });
        }
        _ => {}
    }
    
    // 批量关注逻辑
    for page in 0..max_pages {
        pages_processed = page + 1;
        info!("处理第 {} 页", pages_processed);
        
        // 获取当前页面的关注按钮
        let follow_buttons = self.find_follow_buttons().await?;
        
        if follow_buttons.is_empty() {
            if page > 0 { break; } // 可能已经到底了
            if page < max_pages - 1 {
                self.scroll_down().await?;
                sleep(Duration::from_millis(2000)).await;
            }
            continue;
        }
        
        // 逐个点击关注按钮
        for (x, y) in follow_buttons.iter() {
            let button_text_before = self.get_button_text_at(*x, *y).await.unwrap_or("关注".to_string());
            
            if skip_existing && (button_text_before.contains("已关注") || button_text_before.contains("following")) {
                info!("跳过已关注用户 ({}, {})", x, y);
                continue;
            }
            
            // 点击关注按钮
            match self.click_follow_button(*x, *y).await {
                Ok(true) => {
                    total_followed += 1;
                    info!("成功关注用户 #{}: ({}, {})", total_followed, x, y);
                }
                Ok(false) => {
                    warn!("关注失败: ({}, {})", x, y);
                }
                Err(e) => {
                    error!("关注出错: ({}, {}) - {}", x, y, e);
                }
            }
            
            // 关注间隔
            sleep(Duration::from_millis(follow_interval)).await;
        }
        
        // 滚动到下一页
        if pages_processed < max_pages {
            self.scroll_down().await?;
            sleep(Duration::from_millis(2000)).await;
        }
    }
    
    let duration = start_time.elapsed().as_secs();
    let success = total_followed > 0;
    
    Ok(XiaohongshuFollowResult {
        success,
        total_followed,
        pages_processed,
        duration,
        details,
        message: if success {
            format!("成功关注 {} 个用户", total_followed)
        } else {
            "未关注任何用户".to_string()
        },
    })
}
```

---

## 🔍 UI自动化核心方法

### 1. UI Dump获取
```rust
/// 获取UI dump
async fn get_ui_dump(&self) -> Result<String> {
    // 方法1: 直接输出到stdout
    let output1 = Command::new(&self.adb_path)
        .args(&["-s", &self.device_id, "shell", "uiautomator", "dump", "/dev/stdout"])
        .output()
        .context("获取UI dump失败")?;
    
    let result1 = String::from_utf8_lossy(&output1.stdout).to_string();
    
    if result1.len() > 100 && result1.contains("<?xml") {
        return Ok(result1);
    }
    
    // 方法2: 先dump到文件，再cat
    let _dump_output = Command::new(&self.adb_path)
        .args(&["-s", &self.device_id, "shell", "uiautomator", "dump", "/sdcard/ui_dump.xml"])
        .output()
        .context("dump到文件失败")?;
    
    let output2 = Command::new(&self.adb_path)
        .args(&["-s", &self.device_id, "shell", "cat", "/sdcard/ui_dump.xml"])
        .output()
        .context("读取UI dump文件失败")?;
    
    let result2 = String::from_utf8_lossy(&output2.stdout).to_string();
    
    if result2.len() > 100 && result2.contains("<?xml") {
        return Ok(result2);
    }
    
    anyhow::bail!("无法获取有效的UI dump");
}
```

### 2. 智能按钮查找
```rust
/// 智能查找关注按钮
async fn find_follow_buttons(&self) -> Result<Vec<(i32, i32)>> {
    info!("🔍 智能分析页面中的关注按钮...");
    
    let page_recognition = self.recognize_current_page().await?;
    
    if page_recognition.current_state != PageState::ContactsList {
        warn!("⚠️ 当前不在通讯录页面，状态: {:?}", page_recognition.current_state);
        return Ok(vec![]);
    }
    
    let mut buttons = Vec::new();
    
    // 从UI元素中查找关注按钮
    for element in &page_recognition.ui_elements {
        if element.element_type == UIElementType::Button && element.clickable {
            let button_text = element.text.to_lowercase();
            
            // 检查是否是关注相关按钮
            if button_text.contains("关注") || button_text.contains("follow") || 
               button_text.contains("已关注") || button_text.contains("following") {
                
                let center_x = (element.bounds.0 + element.bounds.2) / 2;
                let center_y = (element.bounds.1 + element.bounds.3) / 2;
                
                buttons.push((center_x, center_y));
                info!("✅ 找到关注按钮 坐标:({}, {}) 文本:'{}'", center_x, center_y, element.text);
            }
        }
    }
    
    // 如果通过UI元素没找到，尝试通过UI dump的文本定位
    if buttons.is_empty() {
        info!("🔄 UI元素分析未找到按钮，尝试文本定位...");
        buttons = self.find_buttons_by_text_pattern().await?;
    }
    
    info!("📊 总共找到 {} 个关注按钮位置", buttons.len());
    Ok(buttons)
}
```

### 3. ADB命令操作
```rust
/// ADB点击坐标
async fn adb_tap(&self, x: i32, y: i32) -> Result<()> {
    let _output = Command::new(&self.adb_path)
        .args(&[
            "-s", &self.device_id,
            "shell", "input", "tap",
            &x.to_string(), &y.to_string()
        ])
        .output()
        .context("ADB点击失败")?;
    
    Ok(())
}

/// 滚动页面向下
async fn scroll_down(&self) -> Result<()> {
    info!("向下滚动页面");
    
    let _output = Command::new(&self.adb_path)
        .args(&[
            "-s", &self.device_id,
            "shell", "input", "swipe",
            "500", "800", "500", "300", "1000"
        ])
        .output()
        .context("滚动页面失败")?;
    
    Ok(())
}

/// 启动小红书应用
async fn open_xiaohongshu_app(&self) -> Result<()> {
    info!("启动小红书应用...");
    
    let _output = Command::new(&self.adb_path)
        .args(&[
            "-s", &self.device_id,
            "shell", "am", "start",
            "-n", "com.xingin.xhs/.index.v2.IndexActivityV2"
        ])
        .output()
        .context("启动小红书应用失败")?;
    
    sleep(Duration::from_secs(3)).await;
    Ok(())
}
```

---

## 🚀 GUI集成方案

### 1. Tauri后端集成

在 `src-tauri/src/` 中创建 `xiaohongshu_service.rs`:

```rust
use anyhow::Result;
use serde::{Deserialize, Serialize};
use tauri::State;
use tokio::sync::Mutex;

// 集成核心自动化结构体
pub struct XiaohongshuService {
    automator: Option<XiaohongshuAutomator>,
}

impl XiaohongshuService {
    pub fn new() -> Self {
        Self { automator: None }
    }
    
    pub fn initialize(&mut self, device_id: String) {
        self.automator = Some(XiaohongshuAutomator::new(device_id));
    }
}

// Tauri命令定义
#[tauri::command]
pub async fn check_xiaohongshu_status(
    service: State<'_, Mutex<XiaohongshuService>>,
) -> Result<AppStatusResult, String> {
    let service = service.lock().await;
    
    if let Some(automator) = &service.automator {
        automator.check_app_status().await.map_err(|e| e.to_string())
    } else {
        Err("服务未初始化".to_string())
    }
}

#[tauri::command]
pub async fn navigate_to_contacts_page(
    service: State<'_, Mutex<XiaohongshuService>>,
) -> Result<NavigationResult, String> {
    let service = service.lock().await;
    
    if let Some(automator) = &service.automator {
        automator.navigate_to_contacts().await.map_err(|e| e.to_string())
    } else {
        Err("服务未初始化".to_string())
    }
}

#[tauri::command]
pub async fn auto_follow_contacts(
    service: State<'_, Mutex<XiaohongshuService>>,
    options: Option<XiaohongshuFollowOptions>,
) -> Result<XiaohongshuFollowResult, String> {
    let service = service.lock().await;
    
    if let Some(automator) = &service.automator {
        automator.auto_follow(options).await.map_err(|e| e.to_string())
    } else {
        Err("服务未初始化".to_string())
    }
}

#[tauri::command]
pub async fn initialize_xiaohongshu_service(
    service: State<'_, Mutex<XiaohongshuService>>,
    device_id: String,
) -> Result<(), String> {
    let mut service = service.lock().await;
    service.initialize(device_id);
    Ok(())
}
```

### 2. 前端React/TypeScript集成

在 `src/services/xiaohongshuService.ts` 中创建服务：

```typescript
import { invoke } from '@tauri-apps/api/tauri';

export interface AppStatusResult {
  app_installed: boolean;
  app_running: boolean;
  message: string;
}

export interface NavigationResult {
  success: boolean;
  message: string;
}

export interface XiaohongshuFollowOptions {
  max_pages?: number;
  follow_interval?: number;
  skip_existing?: boolean;
  return_to_home?: boolean;
}

export interface XiaohongshuFollowResult {
  success: boolean;
  total_followed: number;
  pages_processed: number;
  duration: number;
  details: FollowDetail[];
  message: string;
}

export interface FollowDetail {
  user_position: [number, number];
  follow_success: boolean;
  button_text_before?: string;
  button_text_after?: string;
  error?: string;
}

export class XiaohongshuService {
  
  static async initializeService(deviceId: string): Promise<void> {
    return invoke('initialize_xiaohongshu_service', { deviceId });
  }
  
  static async checkAppStatus(): Promise<AppStatusResult> {
    return invoke('check_xiaohongshu_status');
  }
  
  static async navigateToContacts(): Promise<NavigationResult> {
    return invoke('navigate_to_contacts_page');
  }
  
  static async autoFollowContacts(
    options?: XiaohongshuFollowOptions
  ): Promise<XiaohongshuFollowResult> {
    return invoke('auto_follow_contacts', { options });
  }
  
  // 完整工作流程
  static async executeCompleteWorkflow(
    deviceId: string,
    options?: XiaohongshuFollowOptions
  ): Promise<{
    initialization: boolean;
    appStatus: AppStatusResult;
    navigation: NavigationResult;
    followResult: XiaohongshuFollowResult;
  }> {
    try {
      // 1. 初始化服务
      await this.initializeService(deviceId);
      
      // 2. 检查应用状态
      const appStatus = await this.checkAppStatus();
      
      // 3. 导航到通讯录页面
      const navigation = await this.navigateToContacts();
      
      // 4. 执行自动关注
      const followResult = await this.autoFollowContacts(options);
      
      return {
        initialization: true,
        appStatus,
        navigation,
        followResult,
      };
    } catch (error) {
      throw new Error(`工作流程执行失败: ${error}`);
    }
  }
}
```

### 3. React组件集成示例

```tsx
import React, { useState } from 'react';
import { XiaohongshuService, XiaohongshuFollowOptions } from '../services/xiaohongshuService';

export const XiaohongshuFollowComponent: React.FC = () => {
  const [deviceId, setDeviceId] = useState('emulator-5554');
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<any>(null);
  const [options, setOptions] = useState<XiaohongshuFollowOptions>({
    max_pages: 5,
    follow_interval: 2000,
    skip_existing: true,
    return_to_home: true,
  });

  const handleExecuteWorkflow = async () => {
    setIsLoading(true);
    try {
      const result = await XiaohongshuService.executeCompleteWorkflow(deviceId, options);
      setResult(result);
      
      if (result.followResult.success) {
        alert(`成功关注了 ${result.followResult.total_followed} 个好友！`);
      } else {
        alert(`关注失败: ${result.followResult.message}`);
      }
    } catch (error) {
      alert(`执行失败: ${error}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="xiaohongshu-follow-component">
      <h2>小红书自动关注</h2>
      
      <div className="device-config">
        <label>
          设备ID:
          <input 
            type="text" 
            value={deviceId}
            onChange={(e) => setDeviceId(e.target.value)}
          />
        </label>
      </div>

      <div className="follow-options">
        <label>
          最大页数:
          <input 
            type="number" 
            value={options.max_pages}
            onChange={(e) => setOptions({...options, max_pages: parseInt(e.target.value)})}
          />
        </label>
        
        <label>
          关注间隔(毫秒):
          <input 
            type="number" 
            value={options.follow_interval}
            onChange={(e) => setOptions({...options, follow_interval: parseInt(e.target.value)})}
          />
        </label>
        
        <label>
          <input 
            type="checkbox" 
            checked={options.skip_existing}
            onChange={(e) => setOptions({...options, skip_existing: e.target.checked})}
          />
          跳过已关注用户
        </label>
      </div>

      <button 
        onClick={handleExecuteWorkflow}
        disabled={isLoading}
        className="execute-button"
      >
        {isLoading ? '执行中...' : '开始自动关注'}
      </button>

      {result && (
        <div className="result-display">
          <h3>执行结果</h3>
          <pre>{JSON.stringify(result, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};
```

---

## 📝 集成步骤总结

### 1. 依赖添加
在 `Cargo.toml` 中添加：
```toml
[dependencies]
anyhow = "1.0"
tokio = { version = "1.0", features = ["full"] }
tracing = "0.1"
serde = { version = "1.0", features = ["derive"] }
```

### 2. 核心文件拷贝
- 复制 `xiaohongshu_automator.rs` 到 `src-tauri/src/services/`
- 复制 `types.rs` 到 `src-tauri/src/`
- 创建 `xiaohongshu_service.rs` 包装器

### 3. Tauri配置
在 `main.rs` 中注册命令：
```rust
fn main() {
    tauri::Builder::default()
        .manage(Mutex::new(XiaohongshuService::new()))
        .invoke_handler(tauri::generate_handler![
            initialize_xiaohongshu_service,
            check_xiaohongshu_status,
            navigate_to_contacts_page,
            auto_follow_contacts,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 4. 前端集成
- 创建TypeScript服务类
- 创建React组件
- 添加UI界面和交互逻辑

---

## ⚠️ 重要注意事项

### 环境要求
- Windows系统
- ADB工具已安装并配置
- Android设备/模拟器已连接
- 小红书应用已安装且已登录

### 关键坐标（基于测试验证）
- 头像按钮: (60, 100)
- 发现好友选项: (270, 168)
- 通讯录选项: (194, 205)
- 滚动区域: (500, 800) -> (500, 300)

### 安全考虑
- 默认2秒关注间隔，避免被检测
- 跳过已关注用户，避免重复操作
- 完善的错误处理和重试机制
- 详细的操作日志记录

### 扩展性
- 可配置的操作参数
- 模块化的代码结构
- 支持多设备并行操作
- 易于集成到不同UI框架

---

## 🎯 总结

本文档提取了小红书关注脚本的核心逻辑，包括：

1. **完整的数据结构定义** - 支持各种操作结果和配置
2. **核心API接口** - 提供状态检查、导航、关注等功能
3. **UI自动化方法** - 基于ADB和uiautomator的设备控制
4. **GUI集成方案** - 详细的Tauri + React集成示例
5. **部署指南** - 完整的集成步骤和注意事项

通过这些核心逻辑，可以将小红书自动关注功能无缝集成到任何GUI桌面程序中，提供用户友好的界面和可靠的自动化体验。

*文档更新日期: 2025年1月13日*