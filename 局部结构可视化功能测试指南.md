# 悬浮式局部结构可视化功能测试指南

## 🎯 功能概述

在结构匹配模态框中，实现了悬浮式局部可视化预览功能：

- **左侧：元素结构树** - 层级配置和字段匹配规则（全屏显示）
- **右上角：悬浮可视化预览** - 智能定位的悬浮窗口，显示选中元素周围的局部结构
- **悬浮联动高亮** - 鼠标悬停左侧树节点时，右上角悬浮窗口中对应元素高亮

## 🔧 核心技术实现

### 1. 悬浮可视化组件 (`FloatingVisualOverlay`)

```typescript
// src/modules/structural-matching/ui/components/visual-preview/floating-visual-overlay.tsx

✅ 悬浮窗口覆盖层设计
✅ 智能位置定位系统
✅ 从完整XML中提取局部相关元素
✅ 2.5倍区域扩展 + 最小尺寸保证
✅ 支持父子元素关系
✅ 与树节点联动高亮
✅ 专业级动画效果
```

### 2. 增强的联动系统

```typescript
// 悬停事件处理
const handleTreeHover = useCallback((nodeKey: string | null) => {
  // 将树节点key转换为元素ID
  const elementId = deriveElementIdFromNodeKey(nodeKey);
  handleTreeNodeHover(elementId);
}, [deriveElementIdFromNodeKey, handleTreeNodeHover]);
```

### 3. 元素范围提取策略

- **以选中元素为中心**
- **1.5倍区域扩展**
- **包含父子关系元素**
- **视觉接近的同级元素**

## 🧪 测试步骤

### 步骤 1：打开结构匹配模态框

1. 启动应用：`npm run tauri dev`
2. 进入页面分析功能
3. 选择任一元素
4. 点击"结构匹配配置"按钮

### 步骤 2：验证悬浮可视化预览

1. 观察右上角是否显示"🎈 局部结构可视化预览"悬浮窗口
2. 检查悬浮窗口是否有蓝色边框和阴影效果
3. 验证设备框架和元素布局显示是否正确
4. 确认元素数量显示是否准确（例：显示 15 个局部元素）

### 步骤 3：测试悬浮联动

1. **鼠标悬停左侧树节点**：
   - 悬停"外层"节点 → 右上角悬浮窗口应高亮选中元素
   - 悬停"第1层"节点 → 悬浮窗口应高亮对应子元素
   - 悬停"第2层"节点 → 悬浮窗口应高亮对应孙元素

2. **观察状态反馈**：
   - 悬浮窗口标题栏显示当前高亮元素ID
   - 底部状态栏显示联动状态
   - 悬浮窗口位置智能调整，避免超出屏幕

### 步骤 4：验证悬浮窗口特性

1. **位置智能定位**：
   - 默认显示在右上角
   - 鼠标悬停时跟随鼠标位置
   - 自动避免超出视口边界

2. **视觉效果**：
   - 背景半透明遮罩
   - 窗口淡入缩放动画
   - 蓝色主题突出显示

1. **元素颜色区分**：
   - 🟢 绿色：可点击元素
   - 🔵 蓝色：有文本元素  
   - 🟠 橙色：有描述元素
   - ⚫ 灰色：普通元素

2. **高亮效果**：
   - 高亮元素有红色边框
   - 放大效果 (scale 1.05)
   - 阴影效果增强

3. **设备框架**：
   - 模拟手机外观
   - 正确的比例缩放
   - 设备信息显示

## 🐛 常见问题排查

### 问题 1：右上角无悬浮窗口

**症状**：悬浮可视化窗口不显示

**排查步骤**：
1. 检查控制台是否有XML缓存错误
2. 确认选中元素是否包含`xmlCacheId`
3. 验证XML解析是否成功
4. 检查悬浮窗口的z-index是否被其他元素覆盖

**解决方案**：
```bash
# 检查控制台日志
🎈 [FloatingVisualOverlay] 组件挂载
✅ [FloatingVisualOverlay] XML数据加载成功
� [FloatingVisualOverlay] 正在渲染悬浮层
```

### 问题 2：悬停无联动效果

**症状**：鼠标悬停树节点但悬浮窗口无高亮

**排查步骤**：
1. 检查树节点是否正确捕获hover事件
2. 验证`deriveElementIdFromNodeKey`函数返回值
3. 确认悬浮窗口的`highlightedElementId`更新

**调试日志**：
```bash
🎯 [ElementStructureTreeWithPreview] Tree hover: root-0-1
🎈 [FloatingVisualOverlay] 高亮元素更新: element_xx_child_1
```

### 问题 3：悬浮窗口位置错误

**症状**：悬浮窗口显示在错误位置或超出屏幕

**原因**：
- 鼠标位置获取失败
- 视口边界计算错误
- z-index层级冲突

**解决方案**：
检查`getOverlayPosition`函数和边界计算逻辑

## 📊 性能监控

### 关键指标

1. **XML解析时间**：< 500ms
2. **元素转换时间**：< 100ms  
3. **渲染帧率**：60fps
4. **内存占用**：< 50MB

### 性能优化

1. **缓存XML解析结果**
2. **虚拟化长列表**
3. **防抖hover事件**
4. **按需加载元素**

## 🎨 样式规范

### 色彩系统

```css
/* 元素类型颜色 */
--clickable-color: #52c41a;     /* 可点击 - 绿色 */
--text-color: #1890ff;          /* 文本 - 蓝色 */
--desc-color: #faad14;          /* 描述 - 橙色 */
--normal-color: #8c8c8c;        /* 普通 - 灰色 */

/* 高亮效果 */
--highlight-border: #ff4d4f;    /* 高亮边框 - 红色 */
--hover-border: #faad14;        /* 悬停边框 - 橙色 */
```

### 动画效果

```css
/* 元素过渡 */
transition: all 0.2s ease;

/* 高亮缩放 */
transform: scale(1.05);

/* 阴影增强 */
box-shadow: 0 4px 12px rgba(255,77,79,0.4);
```

## 🚀 后续优化

### 短期优化

1. **增强hover精度**：更精确的树节点事件捕获
2. **添加快捷键**：支持键盘导航
3. **优化移动端**：触摸设备适配

### 长期规划

1. **3D可视化**：立体层级展示
2. **动画过渡**：元素切换动画
3. **智能布局**：自适应最佳显示角度
4. **导出功能**：可视化图片导出

### 📝 测试清单

- [ ] 模态框正常打开
- [ ] 右上角显示悬浮可视化窗口
- [ ] 左侧树节点hover正常
- [ ] 悬浮窗口元素高亮联动
- [ ] 悬浮窗口位置智能定位
- [ ] 状态栏信息准确
- [ ] 设备框架显示正确
- [ ] 元素颜色区分清晰
- [ ] 缩放比例合适
- [ ] 悬浮动画流畅
- [ ] 背景遮罩效果正常
- [ ] 性能表现良好
- [ ] 无控制台错误

---

## 💡 使用提示

1. **最佳悬停方式**：缓慢移动鼠标到树节点上，悬浮窗口会立即响应高亮
2. **查看详细信息**：悬停可视化元素查看tooltip信息
3. **调整视图**：悬浮窗口会自动缩放以适应内容大小
4. **理解层级**：深度标识帮助理解元素层级关系
5. **专注模式**：悬浮窗口提供专注的可视化体验，避免界面干扰

通过这个悬浮式局部可视化功能，用户可以更直观地理解元素的结构关系，提升结构匹配配置的准确性！悬浮窗口的设计既不干扰主工作流程，又能在需要时提供清晰的可视化支持。