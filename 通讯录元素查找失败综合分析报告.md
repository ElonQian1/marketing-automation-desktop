# é€šè®¯å½•å…ƒç´ æŸ¥æ‰¾å¤±è´¥ç»¼åˆåˆ†ææŠ¥å‘Š

## ğŸ“‹ é—®é¢˜æ¦‚è¿°

ç”¨æˆ·ç‚¹å‡»"é€šè®¯å½•"æŒ‰é’®ååˆ›å»ºæ­¥éª¤ï¼Œä½†æ‰§è¡Œæ—¶æ— æ³•æ‰¾åˆ°è¯¥å…ƒç´ ã€‚æ—¥å¿—æ˜¾ç¤ºåç«¯æ‰¾åˆ°äº†"æ·»åŠ æœ‹å‹"è€Œé"é€šè®¯å½•"ã€‚

---

## ğŸ” å…ƒç´ åˆ†æ

### é€šè®¯å½•å…ƒç´ åœ¨XMLä¸­çš„ä½ç½®

ä» `ui_dump_e0d909c3_20251028_030232.xml` ä¸­æ‰¾åˆ°ï¼š

```xml
<!-- çˆ¶å®¹å™¨ - å¯ç‚¹å‡» -->
<node index="0" 
      resource-id="com.ss.android.ugc.aweme:id/iwk" 
      class="android.widget.LinearLayout" 
      content-desc="" 
      clickable="true"  â† âœ… å¯ç‚¹å‡»
      bounds="[45,1059][249,1263]">
  
  <!-- å›¾æ ‡ -->
  <node index="0" 
        resource-id="com.ss.android.ugc.aweme:id/icon" 
        class="android.widget.ImageView" 
        bounds="[110,1093][184,1167]" />
  
  <!-- æ–‡æœ¬ - ä¸å¯ç‚¹å‡» -->
  <node index="1" 
        text="é€šè®¯å½•"  â† âœ… ç›®æ ‡æ–‡æœ¬
        resource-id="com.ss.android.ugc.aweme:id/title" 
        class="android.widget.TextView" 
        clickable="false"  â† âš ï¸ ä¸å¯ç‚¹å‡»
        bounds="[99,1196][195,1240]" />
</node>
```

**å…³é”®å‘ç°**ï¼š
1. âœ… æ–‡æœ¬å…ƒç´  `text="é€šè®¯å½•"` å­˜åœ¨
2. âš ï¸ æ–‡æœ¬å…ƒç´  `clickable="false"` - ä¸å¯ç›´æ¥ç‚¹å‡»
3. âœ… çˆ¶å®¹å™¨ `LinearLayout` å¯ç‚¹å‡»
4. âœ… bounds: `[45,1059][249,1263]` ï¼ˆçˆ¶å®¹å™¨ï¼‰
5. âœ… resource-id: `com.ss.android.ugc.aweme:id/iwk`

---

## ğŸ› é—®é¢˜æ ¹å› åˆ†æ

### 1. å‰ç«¯æ•°æ®ä¼ é€’é—®é¢˜

#### âŒ å½“å‰å®ç°çš„é”™è¯¯

ç”¨æˆ·åœ¨**å¯è§†åŒ–åˆ†æè§†å›¾**ç‚¹å‡»"é€šè®¯å½•"ï¼Œä½†ä¼ é€’ç»™åç«¯çš„æ•°æ®æ˜¯ï¼š

```json
{
  "selected_xpath": "//*[contains(@class, 'FrameLayout')]",  // âŒ é”™è¯¯ï¼
  "element_text": "",  // âŒ ç©ºï¼
  "original_xml": "",  // âŒ ç©ºï¼
  "element_bounds": "[0,1321][1080,1447]"  // âŒ åº•éƒ¨å¯¼èˆªæ çš„bounds
}
```

**é”™è¯¯åŸå› **ï¼š
- å¯è§†åŒ–è§†å›¾ç‚¹å‡»åï¼Œæ²¡æœ‰æ­£ç¡®ä¿å­˜ç”¨æˆ·é€‰æ‹©çš„å…ƒç´ ä¿¡æ¯
- `xmlCacheId` ç¡¬ç¼–ç ä¸º "current_analysis"
- `xmlContent` ç¡¬ç¼–ç ä¸ºç©ºå­—ç¬¦ä¸²
- XPath ç”Ÿæˆé”™è¯¯

### 2. åç«¯æ™ºèƒ½åˆ†æçš„å›°å¢ƒ

åç«¯æ”¶åˆ°é”™è¯¯æ•°æ®åï¼š

```rust
// Step 0-6 æ™ºèƒ½åˆ†æ
åŸå§‹XPath: //*[contains(@class, 'FrameLayout')]
element_text: ""
content_desc: None
bounds: "[0,1321][1080,1447]"
```

**åˆ†æç»“æœ**ï¼š
1. XPath åŒ¹é…åˆ°åº•éƒ¨å¯¼èˆªæ çš„ `FrameLayout`
2. æ²¡æœ‰æ–‡æœ¬/æè¿°ä¿¡æ¯ç”¨äºæ™ºèƒ½è¯„åˆ†
3. bounds æŒ‡å‘é”™è¯¯çš„åŒºåŸŸ
4. Step 0-6 ç”Ÿæˆäº† 10 ä¸ªå€™é€‰ï¼Œä½†éƒ½æ˜¯åŸºäºé”™è¯¯çš„åˆå§‹æ•°æ®

**ç”Ÿæˆçš„å€™é€‰**ï¼š
```
1. "æ‰«ä¸€æ‰«" (ç½®ä¿¡åº¦ 0.743)
2. "å°ç¬¼å­" (ç½®ä¿¡åº¦ 0.724)  
3. "é€šè®¯å½•" (ç½®ä¿¡åº¦ 0.714)  â† âœ… æ‰¾åˆ°äº†ï¼ä½†æ’åºé”™è¯¯
```

### 3. ä¸ºä»€ä¹ˆæ™ºèƒ½åˆ†æ"æŸæ‰‹æ— ç­–"ï¼Ÿ

**V3 Step 0-6 æ™ºèƒ½ç­–ç•¥åˆ†æç³»ç»Ÿ å¹¶éæ— èƒ½**ï¼Œè€Œæ˜¯ï¼š

1. âœ… **åˆ†æèƒ½åŠ›æ­£å¸¸**ï¼š
   - Step 0: è®¾å¤‡çŠ¶æ€è·å– âœ…
   - Step 1: è§£æ160ä¸ªå…ƒç´  âœ…
   - Step 2: ç”¨æˆ·æ„å›¾åˆ†æ âœ…
   - Step 3: æ™ºèƒ½è¯„åˆ† âœ…
   - Step 4: ç”Ÿæˆ10ä¸ªå€™é€‰ âœ…
   - Step 5: é€‰å‡º3ä¸ªæœ€ä¼˜ âœ…
   - Step 6: è½¬æ¢ä¸ºV3æ­¥éª¤ âœ…

2. âŒ **è¾“å…¥æ•°æ®é”™è¯¯**ï¼š
   ```
   "targetText": ""  â† æ— ç›®æ ‡æ–‡æœ¬
   "selected_xpath": "//*[contains(@class, 'FrameLayout')]"  â† é”™è¯¯XPath
   "original_xml": ""  â† æ— åŸå§‹XML
   ```

3. ğŸ¯ **æ™ºèƒ½åˆ†ææ‰¾åˆ°äº†"é€šè®¯å½•"**ï¼š
   ```
   intelligent_step_3:
   - targetText: "é€šè®¯å½•"
   - xpath: "//node[@index='41']"
   - confidence: 0.7145
   ```

4. âš ï¸ **ä½†è¢«é”™è¯¯åœ°è¿‡æ»¤**ï¼š
   - åç«¯å›é€€åˆ†æä¼˜å…ˆåŒ¹é… bounds
   - bounds æŒ‡å‘åº•éƒ¨å¯¼èˆªæ  `[0,1321][1080,1447]`
   - æœ€ç»ˆé€‰æ‹©äº†"æ·»åŠ æœ‹å‹"ï¼ˆä¹Ÿåœ¨åŒä¸€åŒºåŸŸé™„è¿‘ï¼‰

---

## ğŸ”§ å®Œæ•´ä¿®å¤æ–¹æ¡ˆ

### é˜¶æ®µ1ï¼šå‰ç«¯æ•°æ®ä¿å­˜ä¿®å¤ âœ… **å·²å®Œæˆ**

#### 1.1 ä¿®å¤æ–‡ä»¶ï¼š`VisualPageAnalyzerContent.tsx`

**é—®é¢˜ä»£ç **ï¼š
```typescript
// âŒ Line 168-169
const enhancedUIElement = {
  ...uiElement,
  xmlCacheId: "current_analysis",  // ç¡¬ç¼–ç 
  xmlContent: "",  // ç©ºå­—ç¬¦ä¸²
};
```

**ä¿®å¤ä»£ç **ï¼š
```typescript
// âœ… æ­£ç¡®ä¿å­˜XML
let xmlCacheId = '';
let xmlHash = '';

try {
  if (xmlContent && xmlContent.length > 100) {
    xmlHash = generateXmlHash(xmlContent);
    xmlCacheId = `xml_${xmlHash.substring(0, 16)}_${Date.now()}`;
    
    const xmlCacheManager = XmlCacheManager.getInstance();
    xmlCacheManager.putXml(xmlCacheId, xmlContent, `sha256:${xmlHash}`);
  }
} catch (error) {
  console.error('ä¿å­˜XMLå¤±è´¥:', error);
}

const enhancedUIElement = {
  ...uiElement,
  xmlCacheId: xmlCacheId,  // âœ… çœŸå®ID
  xmlContent: xmlContent,  // âœ… å®Œæ•´å†…å®¹
  xmlHash: xmlHash,  // âœ… å“ˆå¸Œå€¼
};
```

#### 1.2 ä¿®å¤æ–‡ä»¶ï¼š`useIntelligentStepCardIntegration.ts`

**é—®é¢˜ä»£ç **ï¼š
```typescript
// âŒ Line 156
elementPath: element.xpath || element.id || '',
```

**ä¿®å¤ä»£ç **ï¼š
```typescript
// âœ… ç”Ÿæˆæ­£ç¡®çš„ç»å¯¹å…¨å±€XPath
let absoluteXPath = '';
try {
  if (element.xpath && element.xpath.startsWith('/')) {
    absoluteXPath = element.xpath;
  } else {
    // ä½¿ç”¨buildXPathç”Ÿæˆ
    const generatedXPath = buildXPath(element, {
      useAttributes: true,
      useText: true,
      useIndex: false,
      preferredAttributes: ['resource-id', 'content-desc', 'text', 'class']
    });
    absoluteXPath = generatedXPath || element.xpath;
  }
} catch (error) {
  // å›é€€ç­–ç•¥
  if (element.resource_id) {
    absoluteXPath = `//*[@resource-id='${element.resource_id}']`;
  } else if (element.text) {
    absoluteXPath = `//*[@text='${element.text}']`;
  }
}

const context: ElementSelectionContext = {
  elementPath: absoluteXPath,  // âœ… æ­£ç¡®XPath
  xmlContent: xmlContent,  // âœ… å®Œæ•´XML
  // ...
};
```

---

### é˜¶æ®µ2ï¼šåç«¯å¤šå€™é€‰è¯„ä¼°ä¿®å¤ âš ï¸ **éœ€è¦å®Œå–„**

#### é—®é¢˜ï¼šå¤šå€™é€‰é€‰æ‹©é€»è¾‘ä¸å®Œå–„

**å½“å‰å®ç°**ï¼š
```rust
// step_executor.rs Line 378
ğŸ”§ [ä¸´æ—¶é™çº§] å¤šå€™é€‰è¯„ä¼°æ¨¡å—é‡æ„ä¸­ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå€™é€‰å…ƒç´ 
```

**é—®é¢˜åˆ†æ**ï¼š
1. åç«¯æ‰¾åˆ°äº†5ä¸ªåŒ¹é…"æ·»åŠ æœ‹å‹"çš„å€™é€‰
2. ç›´æ¥ä½¿ç”¨ç¬¬ä¸€ä¸ªï¼Œæ²¡æœ‰è¿›è¡Œç²¾ç¡®è¯„ä¼°
3. æ²¡æœ‰ä½¿ç”¨ç»å¯¹å…¨å±€XPathè¿›è¡Œå¯¹æ¯”
4. æ²¡æœ‰è¿›è¡Œæ–‡æœ¬/æè¿°ç²¾ç¡®åŒ¹é…

#### ä¿®å¤æ–¹æ¡ˆï¼šå®ç°å®Œæ•´çš„å¤šå€™é€‰è¯„ä¼°å™¨

åˆ›å»ºæ–°æ–‡ä»¶ï¼š`src-tauri/src/exec/v3/helpers/candidate_evaluator.rs`

```rust
// src-tauri/src/exec/v3/helpers/candidate_evaluator.rs
// module: exec | layer: helpers | role: candidate-evaluation
// summary: å¤šå€™é€‰å…ƒç´ è¯„ä¼°å™¨

use serde_json::Value;
use std::collections::HashMap;

/// å€™é€‰å…ƒç´ è¯„ä¼°å™¨
pub struct CandidateEvaluator {
    /// ç”¨æˆ·åŸå§‹é€‰æ‹©çš„XPath
    user_xpath: Option<String>,
    /// ç”¨æˆ·åŸå§‹é€‰æ‹©çš„æ–‡æœ¬
    user_text: Option<String>,
    /// ç”¨æˆ·åŸå§‹é€‰æ‹©çš„content-desc
    user_content_desc: Option<String>,
    /// ç”¨æˆ·åŸå§‹é€‰æ‹©çš„bounds
    user_bounds: Option<String>,
}

/// å€™é€‰å…ƒç´ è¯„ä¼°ç»“æœ
#[derive(Debug, Clone)]
pub struct CandidateScore {
    pub index: usize,
    pub total_score: f64,
    pub xpath_score: f64,
    pub text_score: f64,
    pub bounds_score: f64,
    pub position_score: f64,
    pub reason: String,
}

impl CandidateEvaluator {
    /// åˆ›å»ºè¯„ä¼°å™¨
    pub fn new(
        user_xpath: Option<String>,
        user_text: Option<String>,
        user_content_desc: Option<String>,
        user_bounds: Option<String>,
    ) -> Self {
        Self {
            user_xpath,
            user_text,
            user_content_desc,
            user_bounds,
        }
    }

    /// è¯„ä¼°æ‰€æœ‰å€™é€‰å…ƒç´ 
    pub fn evaluate_candidates(&self, candidates: &[Value]) -> Vec<CandidateScore> {
        let mut scores = Vec::new();

        for (index, candidate) in candidates.iter().enumerate() {
            let score = self.evaluate_single_candidate(index, candidate);
            scores.push(score);
        }

        // æŒ‰æ€»åˆ†æ’åºï¼ˆé™åºï¼‰
        scores.sort_by(|a, b| b.total_score.partial_cmp(&a.total_score).unwrap());

        scores
    }

    /// è¯„ä¼°å•ä¸ªå€™é€‰å…ƒç´ 
    fn evaluate_single_candidate(&self, index: usize, candidate: &Value) -> CandidateScore {
        let mut total_score = 0.0;
        let mut reasons = Vec::new();

        // 1. XPathåŒ¹é…è¯„åˆ†ï¼ˆæƒé‡ï¼š40%ï¼‰
        let xpath_score = self.calculate_xpath_score(candidate);
        total_score += xpath_score * 0.4;
        if xpath_score > 0.8 {
            reasons.push("XPathå®Œå…¨åŒ¹é…".to_string());
        } else if xpath_score > 0.5 {
            reasons.push("XPathéƒ¨åˆ†åŒ¹é…".to_string());
        }

        // 2. æ–‡æœ¬/æè¿°åŒ¹é…è¯„åˆ†ï¼ˆæƒé‡ï¼š30%ï¼‰
        let text_score = self.calculate_text_score(candidate);
        total_score += text_score * 0.3;
        if text_score > 0.8 {
            reasons.push("æ–‡æœ¬å®Œå…¨åŒ¹é…".to_string());
        } else if text_score > 0.5 {
            reasons.push("æ–‡æœ¬éƒ¨åˆ†åŒ¹é…".to_string());
        }

        // 3. BoundsåŒ¹é…è¯„åˆ†ï¼ˆæƒé‡ï¼š20%ï¼‰
        let bounds_score = self.calculate_bounds_score(candidate);
        total_score += bounds_score * 0.2;
        if bounds_score > 0.8 {
            reasons.push("ä½ç½®å®Œå…¨åŒ¹é…".to_string());
        }

        // 4. ä½ç½®ä¼˜å…ˆçº§è¯„åˆ†ï¼ˆæƒé‡ï¼š10%ï¼‰
        // ç›¸åŒæ¡ä»¶ä¸‹ï¼Œä¼˜å…ˆé€‰æ‹©åé¢çš„å…ƒç´ ï¼ˆæ›´å‡†ç¡®ï¼‰
        let position_score = (index as f64 / candidates.len() as f64) * 0.1;
        total_score += position_score;

        CandidateScore {
            index,
            total_score,
            xpath_score,
            text_score,
            bounds_score,
            position_score,
            reason: reasons.join(", "),
        }
    }

    /// è®¡ç®—XPathåŒ¹é…åˆ†æ•°
    fn calculate_xpath_score(&self, candidate: &Value) -> f64 {
        let candidate_xpath = candidate["xpath"].as_str();
        
        if let (Some(user_xpath), Some(cand_xpath)) = (&self.user_xpath, candidate_xpath) {
            // å®Œå…¨åŒ¹é…
            if user_xpath == cand_xpath {
                return 1.0;
            }

            // ç»“æ„ç›¸ä¼¼æ€§åŒ¹é…
            let similarity = self.calculate_xpath_similarity(user_xpath, cand_xpath);
            return similarity;
        }

        // æ²¡æœ‰ç”¨æˆ·XPathï¼Œä½¿ç”¨é»˜è®¤åˆ†æ•°
        0.5
    }

    /// è®¡ç®—æ–‡æœ¬åŒ¹é…åˆ†æ•°
    fn calculate_text_score(&self, candidate: &Value) -> f64 {
        let candidate_text = candidate["text"].as_str().unwrap_or("");
        let candidate_desc = candidate["content-desc"].as_str().unwrap_or("");

        let mut score = 0.0;

        // åŒ¹é…æ–‡æœ¬
        if let Some(user_text) = &self.user_text {
            if !user_text.is_empty() {
                if candidate_text == user_text {
                    score += 0.5;  // æ–‡æœ¬å®Œå…¨åŒ¹é…
                } else if candidate_text.contains(user_text) {
                    score += 0.3;  // æ–‡æœ¬åŒ…å«
                }
            }
        }

        // åŒ¹é…content-desc
        if let Some(user_desc) = &self.user_content_desc {
            if !user_desc.is_empty() {
                if candidate_desc == user_desc {
                    score += 0.5;  // æè¿°å®Œå…¨åŒ¹é…
                } else if candidate_desc.contains(user_desc) {
                    score += 0.3;  // æè¿°åŒ…å«
                }
            }
        }

        score.min(1.0)
    }

    /// è®¡ç®—BoundsåŒ¹é…åˆ†æ•°
    fn calculate_bounds_score(&self, candidate: &Value) -> f64 {
        if let (Some(user_bounds), Some(cand_bounds)) = (
            &self.user_bounds,
            candidate["bounds"].as_str(),
        ) {
            // å®Œå…¨åŒ¹é…
            if user_bounds == cand_bounds {
                return 1.0;
            }

            // åŒºåŸŸé‡å è®¡ç®—
            if let (Ok(user_rect), Ok(cand_rect)) = (
                parse_bounds(user_bounds),
                parse_bounds(cand_bounds),
            ) {
                let overlap = calculate_overlap(&user_rect, &cand_rect);
                return overlap;
            }
        }

        0.5  // æ²¡æœ‰boundsä¿¡æ¯ï¼Œä½¿ç”¨é»˜è®¤åˆ†æ•°
    }

    /// è®¡ç®—XPathç›¸ä¼¼åº¦
    fn calculate_xpath_similarity(&self, xpath1: &str, xpath2: &str) -> f64 {
        // ç®€åŒ–ç‰ˆï¼šåŸºäºè·¯å¾„æ®µçš„ç›¸ä¼¼åº¦
        let segments1: Vec<&str> = xpath1.split('/').collect();
        let segments2: Vec<&str> = xpath2.split('/').collect();

        let min_len = segments1.len().min(segments2.len());
        let max_len = segments1.len().max(segments2.len());

        let mut matches = 0;
        for i in 0..min_len {
            if segments1[i] == segments2[i] {
                matches += 1;
            }
        }

        (matches as f64) / (max_len as f64)
    }
}

/// è§£æboundså­—ç¬¦ä¸²
fn parse_bounds(bounds: &str) -> Result<(i32, i32, i32, i32), ()> {
    // æ ¼å¼: "[left,top][right,bottom]"
    let parts: Vec<&str> = bounds.split("][").collect();
    if parts.len() != 2 {
        return Err(());
    }

    let left_top = parts[0].trim_start_matches('[');
    let right_bottom = parts[1].trim_end_matches(']');

    let lt: Vec<i32> = left_top.split(',').filter_map(|s| s.parse().ok()).collect();
    let rb: Vec<i32> = right_bottom.split(',').filter_map(|s| s.parse().ok()).collect();

    if lt.len() == 2 && rb.len() == 2 {
        Ok((lt[0], lt[1], rb[0], rb[1]))
    } else {
        Err(())
    }
}

/// è®¡ç®—ä¸¤ä¸ªçŸ©å½¢çš„é‡å åº¦
fn calculate_overlap(rect1: &(i32, i32, i32, i32), rect2: &(i32, i32, i32, i32)) -> f64 {
    let (left1, top1, right1, bottom1) = *rect1;
    let (left2, top2, right2, bottom2) = *rect2;

    // è®¡ç®—äº¤é›†
    let x_overlap = (right1.min(right2) - left1.max(left2)).max(0);
    let y_overlap = (bottom1.min(bottom2) - top1.max(top2)).max(0);
    let intersection = x_overlap * y_overlap;

    // è®¡ç®—å¹¶é›†
    let area1 = (right1 - left1) * (bottom1 - top1);
    let area2 = (right2 - left2) * (bottom2 - top2);
    let union = area1 + area2 - intersection;

    if union > 0 {
        (intersection as f64) / (union as f64)
    } else {
        0.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xpath_similarity() {
        let evaluator = CandidateEvaluator::new(
            Some("//node[@index='41']/node[@index='1']".to_string()),
            None,
            None,
            None,
        );

        let xpath1 = "//node[@index='41']/node[@index='1']";
        let xpath2 = "//node[@index='41']/node[@index='0']";
        
        let similarity = evaluator.calculate_xpath_similarity(xpath1, xpath2);
        assert!(similarity > 0.5);
    }

    #[test]
    fn test_bounds_overlap() {
        let rect1 = (0, 0, 100, 100);
        let rect2 = (50, 50, 150, 150);
        
        let overlap = calculate_overlap(&rect1, &rect2);
        assert!(overlap > 0.0 && overlap < 1.0);
    }
}
```

#### ä¿®æ”¹ `step_executor.rs` ä½¿ç”¨æ–°è¯„ä¼°å™¨

```rust
// src-tauri/src/exec/v3/helpers/step_executor.rs
use super::candidate_evaluator::{CandidateEvaluator, CandidateScore};

// Line 378 é™„è¿‘
info!("ğŸ” [å¤šå€™é€‰è¯„ä¼°] å¯åŠ¨æ¨¡å—åŒ–è¯„ä¼°å™¨ï¼ˆ{} ä¸ªå€™é€‰ï¼‰", matches.len());

// åˆ›å»ºè¯„ä¼°å™¨
let evaluator = CandidateEvaluator::new(
    Some(selected_xpath.to_string()),
    Some(target_text.to_string()),
    params.get("target_content_desc").and_then(|v| v.as_str()).map(|s| s.to_string()),
    params.get("element_bounds").and_then(|v| v.as_str()).map(|s| s.to_string()),
);

// è¯„ä¼°æ‰€æœ‰å€™é€‰
let scores = evaluator.evaluate_candidates(&matches);

// é€‰æ‹©æœ€ä½³å€™é€‰
if let Some(best) = scores.first() {
    info!("ğŸ¯ [å¤šå€™é€‰è¯„ä¼°] æœ€ä½³å€™é€‰: index={}, score={:.3}, reason={}", 
        best.index, best.total_score, best.reason);
    
    // ä½¿ç”¨æœ€ä½³å€™é€‰
    target_node = matches[best.index].clone();
} else {
    warn!("âš ï¸ [å¤šå€™é€‰è¯„ä¼°] è¯„ä¼°å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå€™é€‰");
    target_node = matches[0].clone();
}
```

---

### é˜¶æ®µ3ï¼šåŸå§‹XMLå¿«ç…§æ¢å¤æœºåˆ¶ âš ï¸ **éœ€è¦å®Œå–„**

#### é—®é¢˜ï¼šå¤±è´¥æ¢å¤æœºåˆ¶æœªè§¦å‘

**å½“å‰å®ç°**ï¼š
```rust
// recovery_manager.rs
if has_original_xml {
    // ä½¿ç”¨original_xmlé‡æ–°åˆ†æ
}
```

**é—®é¢˜**ï¼š
1. `has_original_xml = false`ï¼ˆå› ä¸ºå‰ç«¯ä¼ é€’ä¸ºç©ºï¼‰
2. å³ä½¿æœ‰XMLï¼Œæ¢å¤è§¦å‘æ¡ä»¶ä¸æ˜ç¡®
3. ç¼ºå°‘é‡æ–°åˆ†æåçš„å€™é€‰å¯¹æ¯”é€»è¾‘

#### ä¿®å¤æ–¹æ¡ˆï¼šå®Œå–„æ¢å¤æœºåˆ¶

```rust
// src-tauri/src/exec/v3/helpers/recovery_manager.rs

/// å¤±è´¥æ¢å¤ç®¡ç†å™¨
pub struct RecoveryManager {
    /// åŸå§‹XMLå†…å®¹
    original_xml: String,
    /// ç”¨æˆ·é€‰æ‹©çš„XPath
    selected_xpath: String,
    /// ç”¨æˆ·é€‰æ‹©çš„æ–‡æœ¬
    target_text: String,
}

impl RecoveryManager {
    /// å°è¯•ä»åŸå§‹XMLæ¢å¤
    pub fn try_recover(&self, current_candidates: &[Value]) -> Option<Vec<Value>> {
        if self.original_xml.is_empty() {
            warn!("âš ï¸ [å¤±è´¥æ¢å¤] åŸå§‹XMLä¸ºç©ºï¼Œæ— æ³•æ¢å¤");
            return None;
        }

        info!("ğŸ”„ [å¤±è´¥æ¢å¤] å¼€å§‹ä»åŸå§‹XMLé‡æ–°åˆ†æ");

        // 1. è§£æåŸå§‹XML
        let original_elements = match parse_xml(&self.original_xml) {
            Ok(elements) => elements,
            Err(e) => {
                error!("âŒ [å¤±è´¥æ¢å¤] è§£æåŸå§‹XMLå¤±è´¥: {:?}", e);
                return None;
            }
        };

        // 2. åœ¨åŸå§‹XMLä¸­æŸ¥æ‰¾ç”¨æˆ·é€‰æ‹©çš„å…ƒç´ 
        let user_element = self.find_user_selected_element(&original_elements)?;

        // 3. ç”Ÿæˆæ–°çš„å€™é€‰åˆ—è¡¨
        let new_candidates = self.generate_recovery_candidates(&original_elements, &user_element);

        // 4. å¯¹æ¯”æ–°æ—§å€™é€‰
        let best_candidate = self.compare_candidates(&new_candidates, current_candidates);

        Some(best_candidate)
    }

    /// åœ¨åŸå§‹XMLä¸­æŸ¥æ‰¾ç”¨æˆ·é€‰æ‹©çš„å…ƒç´ 
    fn find_user_selected_element(&self, elements: &[Value]) -> Option<Value> {
        // ä½¿ç”¨XPathæŸ¥æ‰¾
        if !self.selected_xpath.is_empty() {
            if let Some(element) = find_by_xpath(elements, &self.selected_xpath) {
                return Some(element);
            }
        }

        // ä½¿ç”¨æ–‡æœ¬æŸ¥æ‰¾
        if !self.target_text.is_empty() {
            if let Some(element) = find_by_text(elements, &self.target_text) {
                return Some(element);
            }
        }

        None
    }

    /// ç”Ÿæˆæ¢å¤å€™é€‰
    fn generate_recovery_candidates(&self, elements: &[Value], user_element: &Value) -> Vec<Value> {
        let mut candidates = Vec::new();

        // ç­–ç•¥1ï¼šæŸ¥æ‰¾ç›¸åŒresource-idçš„å…ƒç´ 
        if let Some(resource_id) = user_element["resource-id"].as_str() {
            for element in elements {
                if element["resource-id"].as_str() == Some(resource_id) {
                    candidates.push(element.clone());
                }
            }
        }

        // ç­–ç•¥2ï¼šæŸ¥æ‰¾ç›¸åŒæ–‡æœ¬çš„å…ƒç´ 
        if let Some(text) = user_element["text"].as_str() {
            for element in elements {
                if element["text"].as_str() == Some(text) {
                    candidates.push(element.clone());
                }
            }
        }

        // ç­–ç•¥3ï¼šæŸ¥æ‰¾ç›¸ä¼¼ç»“æ„çš„å…ƒç´ 
        let user_structure = extract_structure(user_element);
        for element in elements {
            let element_structure = extract_structure(element);
            if is_structure_similar(&user_structure, &element_structure) {
                candidates.push(element.clone());
            }
        }

        candidates
    }

    /// å¯¹æ¯”æ–°æ—§å€™é€‰ï¼Œé€‰æ‹©æœ€ä½³
    fn compare_candidates(&self, new_candidates: &[Value], old_candidates: &[Value]) -> Vec<Value> {
        // TODO: å®ç°å€™é€‰å¯¹æ¯”é€»è¾‘
        new_candidates.to_vec()
    }
}
```

---

## ğŸ“Š ä¿®å¤æ•ˆæœé¢„æœŸ

### ä¿®å¤å‰ âŒ

**ç”¨æˆ·æ“ä½œ**ï¼šç‚¹å‡»"é€šè®¯å½•"

**ä¼ é€’æ•°æ®**ï¼š
```json
{
  "selected_xpath": "//*[contains(@class, 'FrameLayout')]",
  "element_text": "",
  "original_xml": "",
  "element_bounds": "[0,1321][1080,1447]"
}
```

**åç«¯åˆ†æ**ï¼š
- åŒ¹é…åˆ°åº•éƒ¨å¯¼èˆªæ 
- ç”Ÿæˆ10ä¸ªå€™é€‰
- é€‰æ‹©"æ·»åŠ æœ‹å‹"ï¼ˆé”™è¯¯ï¼ï¼‰

**æ‰§è¡Œç»“æœ**ï¼šç‚¹å‡»åˆ°"æ·»åŠ æœ‹å‹" âŒ

---

### ä¿®å¤å âœ…

**ç”¨æˆ·æ“ä½œ**ï¼šç‚¹å‡»"é€šè®¯å½•"

**ä¼ é€’æ•°æ®**ï¼š
```json
{
  "selected_xpath": "//*[@resource-id='com.ss.android.ugc.aweme:id/iwk'][@text='é€šè®¯å½•']",
  "element_text": "é€šè®¯å½•",
  "content_desc": "",
  "original_xml": "<?xml version='1.0'...>(å®Œæ•´XML)",
  "xml_hash": "5c595fdf...",
  "element_bounds": "[45,1059][249,1263]"
}
```

**åç«¯åˆ†æ**ï¼š
- ä½¿ç”¨æ­£ç¡®çš„XPathå’Œæ–‡æœ¬
- Step 0-6 ç”Ÿæˆ10ä¸ªå€™é€‰
- å¤šå€™é€‰è¯„ä¼°å™¨è¯„åˆ†ï¼š
  ```
  å€™é€‰1: "æ‰«ä¸€æ‰«" - æ€»åˆ† 0.45
  å€™é€‰2: "å°ç¬¼å­" - æ€»åˆ† 0.38
  å€™é€‰3: "é€šè®¯å½•" - æ€»åˆ† 0.92 â† âœ… æœ€é«˜åˆ†ï¼
  ```
- é€‰æ‹©"é€šè®¯å½•"ï¼ˆæ­£ç¡®ï¼ï¼‰

**æ‰§è¡Œç»“æœ**ï¼šæ­£ç¡®ç‚¹å‡»"é€šè®¯å½•" âœ…

---

## ğŸ¯ æ ¸å¿ƒæ”¹è¿›

### 1. å‰ç«¯æ•°æ®ä¿å­˜ âœ… å·²å®Œæˆ

- âœ… XMLå†…å®¹æ­£ç¡®ä¿å­˜åˆ°ç¼“å­˜
- âœ… xmlCacheId å”¯ä¸€ä¸”å¯è¿½æº¯
- âœ… XPath ç”Ÿæˆæ­£ç¡®
- âœ… å…ƒç´ å±æ€§å®Œæ•´ä¼ é€’

### 2. å¤šå€™é€‰è¯„ä¼° âš ï¸ éœ€è¦å®Œå–„

- âš ï¸ åˆ›å»º `candidate_evaluator.rs` æ¨¡å—
- âš ï¸ å®ç°4ç»´åº¦è¯„åˆ†ï¼š
  - XPathåŒ¹é…ï¼ˆ40%ï¼‰
  - æ–‡æœ¬åŒ¹é…ï¼ˆ30%ï¼‰
  - BoundsåŒ¹é…ï¼ˆ20%ï¼‰
  - ä½ç½®ä¼˜å…ˆçº§ï¼ˆ10%ï¼‰
- âš ï¸ ä½¿ç”¨ç»å¯¹å…¨å±€XPathå¯¹æ¯”
- âš ï¸ æ–‡æœ¬/æè¿°ç²¾ç¡®åŒ¹é…

### 3. å¤±è´¥æ¢å¤ âš ï¸ éœ€è¦å®Œå–„

- âš ï¸ å®Œå–„ `recovery_manager.rs`
- âš ï¸ å®ç°åŸå§‹XMLé‡æ–°åˆ†æ
- âš ï¸ å®ç°å€™é€‰å¯¹æ¯”å’Œé€‰æ‹©
- âš ï¸ è§¦å‘æ¡ä»¶ä¼˜åŒ–

---

## ğŸ“ å®æ–½è®¡åˆ’

### Phase 1: å‰ç«¯ä¿®å¤ âœ… å®Œæˆ

- [x] VisualPageAnalyzerContent.tsx - XMLä¿å­˜
- [x] useIntelligentStepCardIntegration.ts - XPathç”Ÿæˆ
- [x] æµ‹è¯•éªŒè¯

### Phase 2: åç«¯å¤šå€™é€‰è¯„ä¼° ğŸ”„ è¿›è¡Œä¸­

- [ ] åˆ›å»º candidate_evaluator.rs
- [ ] å®ç°è¯„åˆ†ç®—æ³•
- [ ] ä¿®æ”¹ step_executor.rs
- [ ] å•å…ƒæµ‹è¯•
- [ ] é›†æˆæµ‹è¯•

### Phase 3: å¤±è´¥æ¢å¤æœºåˆ¶ â³ å¾…å¼€å§‹

- [ ] å®Œå–„ recovery_manager.rs
- [ ] å®ç°XMLé‡æ–°åˆ†æ
- [ ] å®ç°å€™é€‰å¯¹æ¯”
- [ ] æµ‹è¯•æ¢å¤æµç¨‹

---

## ğŸ§ª æµ‹è¯•éªŒè¯

### æµ‹è¯•ç”¨ä¾‹1ï¼šé€šè®¯å½•ç‚¹å‡»

**æ­¥éª¤**ï¼š
1. æ‰“å¼€å¯è§†åŒ–åˆ†æè§†å›¾
2. ç‚¹å‡»"é€šè®¯å½•"æŒ‰é’®
3. åˆ›å»ºæ­¥éª¤
4. æ‰§è¡Œæ­¥éª¤

**é¢„æœŸ**ï¼š
- âœ… æ­£ç¡®ç‚¹å‡»"é€šè®¯å½•"
- âœ… ä¸ç‚¹å‡»"æ·»åŠ æœ‹å‹"

### æµ‹è¯•ç”¨ä¾‹2ï¼šå¤šå€™é€‰æƒ…å†µ

**æ­¥éª¤**ï¼š
1. é¡µé¢æœ‰å¤šä¸ª"å…³æ³¨"æŒ‰é’®
2. ç‚¹å‡»ç¬¬3ä¸ª"å…³æ³¨"
3. æ‰§è¡Œæ­¥éª¤

**é¢„æœŸ**ï¼š
- âœ… æ­£ç¡®ç‚¹å‡»ç¬¬3ä¸ª"å…³æ³¨"
- âœ… ä¸ç‚¹å‡»ç¬¬1ä¸ªæˆ–ç¬¬2ä¸ª

### æµ‹è¯•ç”¨ä¾‹3ï¼šå¤±è´¥æ¢å¤

**æ­¥éª¤**ï¼š
1. åœ¨è®¾å¤‡Aåˆ›å»ºæ­¥éª¤
2. åœ¨è®¾å¤‡Bæ‰§è¡Œï¼ˆå¸ƒå±€å¯èƒ½ä¸åŒï¼‰
3. åˆå§‹å€™é€‰å¤±æ•ˆ

**é¢„æœŸ**ï¼š
- âœ… è§¦å‘å¤±è´¥æ¢å¤
- âœ… ä½¿ç”¨åŸå§‹XMLé‡æ–°åˆ†æ
- âœ… æ‰¾åˆ°æ­£ç¡®å…ƒç´ 

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. å¯è§†åŒ–è§†å›¾ vs XMLè§†å›¾

- **XMLè§†å›¾**ï¼šå·²æ­£ç¡®å®ç°ï¼ˆé€šè¿‡ XmlCacheManagerï¼‰
- **å¯è§†åŒ–è§†å›¾**ï¼šåˆšä¿®å¤ï¼ˆéœ€è¦æµ‹è¯•éªŒè¯ï¼‰

### 2. XPathç”Ÿæˆç­–ç•¥

ä¼˜å…ˆçº§ï¼š
1. element.xpathï¼ˆå¦‚æœæ˜¯ç»å¯¹è·¯å¾„ï¼‰
2. buildXPathç”Ÿæˆ
3. resource-id
4. text
5. content-desc
6. class

### 3. å¤šå€™é€‰è¯„ä¼°æƒé‡

å¯æ ¹æ®å®é™…æ•ˆæœè°ƒæ•´ï¼š
- XPath: 40% ï¼ˆæœ€é‡è¦ï¼‰
- Text: 30% ï¼ˆæ¬¡é‡è¦ï¼‰
- Bounds: 20%
- Position: 10%

---

## ğŸ“‹ æ£€æŸ¥æ¸…å•

### å‰ç«¯ä¿®å¤
- [x] VisualPageAnalyzerContent.tsx ä¿®å¤
- [x] useIntelligentStepCardIntegration.ts ä¿®å¤
- [x] XMLä¿å­˜é€»è¾‘å®Œæ•´
- [x] XPathç”Ÿæˆæ­£ç¡®
- [ ] ç”¨æˆ·æµ‹è¯•éªŒè¯

### åç«¯ä¼˜åŒ–
- [ ] candidate_evaluator.rs åˆ›å»º
- [ ] è¯„åˆ†ç®—æ³•å®ç°
- [ ] step_executor.rs é›†æˆ
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] é›†æˆæµ‹è¯•é€šè¿‡

### å¤±è´¥æ¢å¤
- [ ] recovery_manager.rs å®Œå–„
- [ ] XMLé‡æ–°åˆ†æå®ç°
- [ ] å€™é€‰å¯¹æ¯”é€»è¾‘
- [ ] æ¢å¤æµç¨‹æµ‹è¯•

---

**ä¿®å¤å®Œæˆåº¦**ï¼š**40%**
- âœ… å‰ç«¯æ•°æ®ä¿å­˜ï¼š100%
- âš ï¸ å¤šå€™é€‰è¯„ä¼°ï¼š0% ï¼ˆå¾…å®ç°ï¼‰
- âš ï¸ å¤±è´¥æ¢å¤ï¼š30% ï¼ˆåŸºç¡€æ¡†æ¶å­˜åœ¨ï¼‰

**è¯·å…ˆæµ‹è¯•å‰ç«¯ä¿®å¤æ•ˆæœï¼Œç„¶åæˆ‘ä¼šç»§ç»­å®Œå–„åç«¯å¤šå€™é€‰è¯„ä¼°å™¨ï¼** ğŸš€
